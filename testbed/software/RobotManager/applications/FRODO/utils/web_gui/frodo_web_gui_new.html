<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Reactive 2D Elements Plotter with CLI-GUI Connector</title>
  <!-- Include Vue 3 from CDN -->
  <script src="https://unpkg.com/vue@3"></script>
  <!-- Import Roboto font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>
    /* Global styling for a modern look */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #fafafa;
      color: #333;
    }
    h2 {
      text-align: center;
      margin: 20px 0;
      color: #444;
    }
    /* Header connection status bar always at the top */
    #connection-status-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background-color: #fff;
      border-bottom: 1px solid #ccc;
      z-index: 200;
      padding: 5px 10px;
      display: flex;
      gap: 15px;
      font-size: 14px;
    }
    /* Adjust app margin so content does not hide behind the header */
    #app {
      margin-top: 40px;
    }
    /* Main container layout: three side-by-side panels */
    #main-container {
      display: flex;
      align-items: stretch;
      padding: 10px;
    }
    /* Resizable map container with panning cursor */
    #mapContainer {
      border: 1px solid #ccc;
      resize: both;
      overflow: auto;
      position: relative;
      min-width: 300px;
      min-height: 300px;
      cursor: grab;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    canvas {
      display: block;
    }
    /* Settings toggle button inside the map container */
    #settings-toggle {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 100;
      padding: 5px 10px;
      font-size: 14px;
      cursor: pointer;
    }
    /* Teleplot container: resizable horizontally.
       Removed the width binding so the user’s manual resizing is not overridden.
       Its height and overflow-y are still bound.
       The table inside will adjust its font size based on a CSS variable (--table-font-size). */
    #teleplotContainer {
      margin-left: 10px;
      border: 1px solid #ccc;
      resize: horizontal;
      overflow-x: auto;
      /* overflow-y set dynamically below */
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
      min-width: 300px;
      position: relative;
      flex-shrink: 0;
    }
    /* Responsive table font size, reduced padding, and allow text wrapping for teleplot container */
    #teleplotContainer table,
    #teleplotContainer th,
    #teleplotContainer td {
        font-size: var(--table-font-size, 16px);
        white-space: normal;
        padding: 2px 4px;
    }
    /* Objects list on right: takes the remaining space and is not resizable */
    #objectsList {
      margin-left: 10px;
      border: 1px solid #ccc;
      flex: 1;
      overflow: auto;
      font-size: 13px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
      position: relative;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
    }
    th, td {
      border: 1px solid #e0e0e0;
      padding: 4px 6px;
      text-align: center;
    }
    /* Highlight the selected table row */
    tr.selected {
      background-color: #def;
    }
    /* Styles for a group panel */
    .group-panel {
      border: 1px solid #ddd;
      margin-bottom: 10px;
      padding: 5px;
      border-radius: 4px;
      background-color: #fdfdfd;
    }
    .group-header {
      background: #f0f0f0;
      padding: 5px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      border-radius: 4px;
      margin-bottom: 4px;
    }
    .group-header input {
      margin-right: 5px;
    }
    .group-header span {
      flex-grow: 1;
    }
    .group-header .arrow {
      display: inline-block;
      width: 0;
      height: 0;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 5px solid #333;
      margin-right: 5px;
      transition: transform 0.2s;
    }
    .group-header .arrow.expanded {
      transform: rotate(90deg);
    }
    /* Table header for each object type */
    .table-header {
      background: #e8e8e8;
      padding: 4px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      border-radius: 4px;
      margin-bottom: 2px;
      font-weight: 500;
    }
    .table-header .arrow {
      display: inline-block;
      width: 0;
      height: 0;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      border-left: 4px solid #333;
      margin-right: 5px;
      transition: transform 0.2s;
    }
    .table-header .arrow.expanded {
      transform: rotate(90deg);
    }
    /* Map offset controls below the map */
    #map-offset-controls label, #controls label {
      display: inline-block;
      margin-right: 15px;
      margin-bottom: 5px;
    }
    /* Global controls styling */
    #controls {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      max-width: 1000px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    /* Delete Trails Button styling */
    #trail-controls {
      margin-top: 10px;
    }
    #trail-controls button {
      padding: 6px 12px;
      border: none;
      background-color: #4285f4;
      color: #fff;
      font-size: 14px;
      border-radius: 4px;
      cursor: pointer;
    }
    #trail-controls button:hover {
      background-color: #357ae8;
    }
    /* Checkbox for group name in label */
    #group-label-control {
      margin-top: 10px;
    }
    /* Styles for video container and videos */
    #video-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin: 10px;
    }
    .video-frame {
      /* The fixed width is calculated so that 4 videos span roughly the full browser width */
      flex: 0 0 calc((100vw - 80px) / 4);
      border: 1px solid #ccc;
      border-radius: 4px;
      text-align: center;
      position: relative;
    }
    .video-frame iframe,
    .video-placeholder {
      width: 100%;
      height: calc((100vw - 50px) / 4 * (540 / 960));
      border: none;
      margin: 0;
      padding: 0;
      display: block;
      overflow: hidden;
    }
    .refresh-button {
      position: absolute;
      top: 5px;
      left: 5px;
      z-index: 10;
      padding: 3px 6px;
      font-size: 10px;
      background: rgba(255, 255, 255, 0.7);
      border: 1px solid #ccc;
      border-radius: 2px;
      cursor: pointer;
    }
    .enlarge-button {
      position: absolute;
      top: 5px;
      right: 5px;
      z-index: 10;
      padding: 3px 6px;
      font-size: 10px;
      background: rgba(0, 0, 0, 0.5);
      color: #fff;
      border: none;
      border-radius: 2px;
      cursor: pointer;
    }
    .enlarged-video-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      z-index: 300;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .enlarged-video-container {
      position: relative;
      width: 80vw;
      height: 80vh;
      background: #000;
      border: 2px solid #fff;
      border-radius: 8px;
    }
    .enlarged-video-container iframe {
      width: 100%;
      height: 100%;
      border: none;
    }
    .close-enlarged-button {
      position: absolute;
      top: 10px;
      right: 10px;
      background: red;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 16px;
      cursor: pointer;
      z-index: 310;
    }
    /* Terminal view additional styling */
    #terminal-path, #terminal-suggestions {
      background-color: #222;
      color: #fff;
      padding: 5px;
      font-family: monospace;
      font-size: 13px;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Connection Status Bar -->
    <div id="connection-status-bar">
      <span>
        <span :style="{ color: mainWsStatus.connected ? 'green' : 'red' }">●</span>
        Main WS ({{ mainWsStatus.frequency }} msg/sec)
      </span>
      <span>
        <span :style="{ color: terminalWsStatus.connected ? 'green' : 'red' }">●</span>
        Terminal WS ({{ terminalWsStatus.frequency }} msg/sec)
      </span>
    </div>
    <!-- Display meta title if provided -->
    <h2 v-if="metaTitle">{{ metaTitle }}</h2>
    <!-- Main container: Map, Teleplot and objects list -->
    <div id="main-container">
      <div id="mapContainer" ref="mapContainer" :style="mapContainerStyle">
        <!-- The canvas for drawing -->
        <canvas ref="canvas"></canvas>
        <!-- Settings toggle button -->
        <button id="settings-toggle" @click="showSettings = !showSettings">Settings</button>
        <!-- New Enlarge/Revert Button -->
        <button id="enlarge-map" @click="toggleMapSize" style="position: absolute; top: 10px; right: 10px; z-index: 100; padding: 5px 10px; font-size: 14px; cursor: pointer;">
          {{ mapEnlarged ? "Revert" : "Enlarge" }}
        </button>
      </div>
      <!-- Removed the inline width binding below so manual resizing is not overridden -->
      <div id="teleplotContainer" ref="teleplotContainer"
           :style="{ height: canvasHeight + 'px', overflowY: showTeleplotIframe ? 'hidden' : 'auto' }">
        <!-- Toggle Button for Teleplot vs Tables -->
        <button id="teleplot-toggle" @click="showTeleplotIframe = !showTeleplotIframe"
                style="position: absolute; top: 10px; left: 10px; z-index: 100;">
          Toggle {{ showTeleplotIframe ? 'Tables' : 'Teleplot' }}
        </button>
        <!-- Teleplot iframe view with refresh button -->
        <div v-show="showTeleplotIframe" style="position: relative;">
          <button class="refresh-button" @click="refreshTeleplot" style="top: 10px; right: 10px; left: auto;">Refresh</button>
          <div v-if="teleplotRunning">
            <iframe :src="teleplotUrl" frameborder="0" :style="{ width: '100%', height: '1000px' }"></iframe>
          </div>
          <div v-else class="video-placeholder"
               style="display: flex; align-items: center; justify-content: center; height: 100%;">
            Teleplot server is not running.
          </div>
        </div>
        <div v-show="!showTeleplotIframe">
          <!-- Display Groups (tables view) in place of teleplot -->
          <group-panel
            v-for="(groupData, groupName) in groups"
            :key="groupData.fullPath || groupName"
            :group-name="groupName"
            :group-data="groupData"
            :format-color="formatColor"
            :format-number="formatNumber"
            :selected-element="selectedElement"
            @select-element="selectElement"
          ></group-panel>
        </div>
      </div>
      <div id="objectsList" :style="{ height: canvasHeight + 'px' }">
        <!-- Terminal Log is now always displayed in this container -->
        <div style="display: flex; flex-direction: column; height: 100%;">
          <div ref="terminalLogContainer" style="flex: 1; overflow-y: auto; background-color: #333; padding: 10px; font-family: monospace;">
            <div v-for="(log, index) in terminalLogs" :key="index">
              <span :style="{ color: log.color }">{{ log.text }}</span>
            </div>
          </div>
          <div id="terminal-path">Current Path: {{ currentPath }}</div>
          <div id="terminal-suggestions" v-html="suggestions"></div>
          <div style="display: flex; border-top: 1px solid #333;">
            <input v-model="terminalInput" @input="updateSuggestions" @keydown="handleKeydown" @keydown.enter.prevent="handleTerminalSubmit" style="flex: 1; padding: 5px; font-family: monospace;" placeholder="Enter command..."/>
            <button @click="handleTerminalSubmit" style="padding: 5px;">Send</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Settings Panel (toggleable) -->
    <div id="settings-panel" v-if="showSettings">
      <!-- Map Offset Controls -->
      <div id="map-offset-controls">
        <label>
          Offset X:
          <input type="number" v-model.number="manualOffsetXRounded" step="0.01">
        </label>
        <label>
          Offset Y:
          <input type="number" v-model.number="manualOffsetYRounded" step="0.01">
        </label>
        <span v-if="!useManualOffset && (metaOffset[0] !== 0 || metaOffset[1] !== 0)">
          (Meta Offset in use: [{{ metaOffset[0] }}, {{ metaOffset[1] }}])
        </span>
      </div>

      <!-- Global Controls -->
      <div id="controls">
        <label>
          X (meters):
          <input type="number" v-model="worldWidthFormatted" step="0.01">
        </label>
        <label>
          Y (meters):
          <input type="number" v-model="worldHeightFormatted" step="0.01">
        </label>
        <label>
          Grid (meters):
          <input type="number" v-model="gridSize" step="0.1">
        </label>
        <div id="global-controls">
          <label>
            Point Size:
            <input type="range" min="0" max="1" step="0.01" v-model.number="logGlobalPointSize">
            <span>{{ globalPointSize.toFixed(2) }}</span>
          </label>
          <label>
            Agent Size:
            <input type="range" min="0" max="1" step="0.01" v-model.number="logGlobalAgentSize">
            <span>{{ globalAgentSize.toFixed(2) }}</span>
          </label>
          <label>
            Vector Size:
            <input type="range" min="0" max="1" step="0.01" v-model.number="logGlobalVectorSize">
            <span>{{ globalVectorSize.toFixed(2) }}</span>
          </label>
          <label>
            Trail Size:
            <input type="range" min="0" max="1" step="0.01" v-model.number="logGlobalTrailSize">
            <span>{{ globalTrailSize.toFixed(2) }}</span>
          </label>
          <label>
            Text Size:
            <input type="range" min="8" max="40" step="1" v-model.number="globalTextSize">
            <span>{{ globalTextSize }}</span>
          </label>
          <label>
            Line Thickness:
            <input type="range" min="0.5" max="10" step="0.1" v-model.number="globalLineThickness">
            <span>{{ globalLineThickness.toFixed(2) }}</span>
          </label>
        </div>
        <div id="trail-controls">
          <button @click="deleteTrails">Delete Trails</button>
        </div>
        <div id="group-label-control">
          <label>
            <input type="checkbox" v-model="addGroupNameToLabel"> Add Groupname to Label
          </label>
        </div>
      </div>
    </div>

    <!-- Video Streams -->
    <div id="video-container" v-if="hasVideos">
      <div class="video-frame" v-for="(video, key) in videos" :key="key">
        <div class="video-title">{{ video.title }}</div>
        <button class="refresh-button" @click="refreshVideo(key)">Refresh</button>
        <button class="enlarge-button" @click="enlargeVideo(key)">Enlarge</button>
        <div v-if="video.placeholder" class="video-placeholder">
          {{ video.title }}
        </div>
        <iframe v-else :src="'http://' + video.address + ':' + video.port + (video.refreshKey ? '?_t=' + video.refreshKey : '')" :key="video.refreshKey" frameborder="0"></iframe>
      </div>
    </div>

    <!-- Enlarged Video Modal Overlay -->
    <div class="enlarged-video-overlay" v-if="enlargedVideoKey !== null" @click.self="closeEnlargedVideo">
      <div class="enlarged-video-container">
        <button class="close-enlarged-button" @click="closeEnlargedVideo">X</button>
        <iframe :src="'http://' + videos[enlargedVideoKey].address + ':' + videos[enlargedVideoKey].port + (videos[enlargedVideoKey].refreshKey ? '?_t=' + videos[enlargedVideoKey].refreshKey : '')"></iframe>
      </div>
    </div>

  </div>

  <script>
    const { createApp, ref, reactive, computed, watch, defineComponent, onMounted, nextTick } = Vue;

    // --- GroupPanel: recursive component to display a group with object tables and nested groups ---
    const GroupPanel = defineComponent({
      name: "GroupPanel",
      props: {
        groupName: { type: String, required: true },
        groupData: { type: Object, required: true },
        formatColor: { type: Function, required: true },
        formatNumber: { type: Function, required: true },
        selectedElement: { type: Object, default: null }
      },
      emits: ["select-element"],
      data() {
        return {
          tableCollapsed: {}
        };
      },
      methods: {
        toggleCollapse() {
          this.groupData.collapsed = !this.groupData.collapsed;
          const collapseKey = "groupCollapse_" + this.fullPath;
          localStorage.setItem(collapseKey, JSON.stringify(this.groupData.collapsed));
        },
        persistGroupVisibility() {
          const visibleKey = "groupVisible_" + this.fullPath;
          localStorage.setItem(visibleKey, JSON.stringify(this.groupData.visible));
        },
        isSelected(type, id) {
          return (
            this.selectedElement &&
            this.selectedElement.type === type &&
            this.selectedElement.id === id &&
            this.selectedElement.group === this.fullPath
          );
        },
        toggleTable(tableType) {
          this.tableCollapsed[tableType] = !this.tableCollapsed[tableType];
          const key = "tableToggle_" + this.fullPath + "_" + tableType;
          localStorage.setItem(key, JSON.stringify(this.tableCollapsed[tableType]));
        },
        persistCheckboxState(type, id, prop, value) {
          const key = "elemState_" + this.fullPath + "_" + type + "_" + id + "_" + prop;
          localStorage.setItem(key, JSON.stringify(value));
        },
        forwardSelect(...args) {
          this.$emit('select-element', ...args);
        }
      },
      computed: {
        fullPath() {
          return this.groupData.fullPath || this.groupName;
        }
      },
      mounted() {
        const tableTypes = ["agents", "visionagents", "points", "vectors", "coordinate_systems", "lines", "rectangles", "circles"];
        tableTypes.forEach(tt => {
          if (this.groupData[tt] && Object.keys(this.groupData[tt]).length > 0) {
            const key = "tableToggle_" + this.fullPath + "_" + tt;
            const stored = localStorage.getItem(key);
            this.tableCollapsed[tt] = stored !== null ? JSON.parse(stored) : false;
          }
        });
        const persistMapping = {
          agents: ['visible','showTrail','dim','showName','showCoordinates'],
          visionagents: ['visible','showTrail','dim','showName','showCoordinates'],
          points: ['visible','showTrail','dim','showName','showCoordinates'],
          vectors: ['visible','dim','showName'],
          coordinate_systems: ['visible','dim','showName'],
          lines: ['visible','dim','showName'],
          rectangles: ['visible','dim'],
          circles: ['visible','dim']
        };
        for (const type in persistMapping) {
          if (this.groupData[type]) {
            for (const id in this.groupData[type]) {
              persistMapping[type].forEach(prop => {
                const key = "elemState_" + this.fullPath + "_" + type + "_" + id + "_" + prop;
                const stored = localStorage.getItem(key);
                if (stored !== null) {
                  this.groupData[type][id][prop] = JSON.parse(stored);
                }
              });
            }
          }
        }
        const collapseKey = "groupCollapse_" + this.fullPath;
        const storedCollapse = localStorage.getItem(collapseKey);
        if (storedCollapse !== null) {
          this.groupData.collapsed = JSON.parse(storedCollapse);
        }
        const visibleKey = "groupVisible_" + this.fullPath;
        const storedVisible = localStorage.getItem(visibleKey);
        if (storedVisible !== null) {
          this.groupData.visible = JSON.parse(storedVisible);
        }
      },
      template:
        `<div class="group-panel">
          <div class="group-header" @click="toggleCollapse">
            <input type="checkbox" v-model="groupData.visible" @click.stop @change.stop="persistGroupVisibility">
            <div class="arrow" :class="{ expanded: !groupData.collapsed }"></div>
            <span>{{ groupName }}</span>
          </div>
          <div v-show="!groupData.collapsed" class="group-content">
            <div v-if="Object.keys(groupData.agents).length > 0">
              <div class="table-header" @click="toggleTable('agents')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.agents }"></div>
                <span>Agents</span>
              </div>
              <div v-show="!tableCollapsed.agents">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>x</th>
                      <th>y</th>
                      <th>Psi</th>
                      <th>Visible</th>
                      <th>Trails</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Show Coordinates</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(agent, id) in groupData.agents" :key="id" :class="{ selected: isSelected('agent', id) }">
                      <td @click.stop="$emit('select-element', 'agent', id, fullPath)"><span :style="{ background: agent.color ? formatColor(agent.color) : 'black', display: 'inline-block', width: '10px', height: '10px', borderRadius: '50%', marginRight: '4px' }"></span>{{ id }}</td>
                      <td>{{ formatNumber(agent.position[0]) }}</td>
                      <td>{{ formatNumber(agent.position[1]) }}</td>
                      <td>{{ formatNumber(agent.psi) }}</td>
                      <td><input type="checkbox" v-model="agent.visible" @change.stop="persistCheckboxState('agents', id, 'visible', agent.visible)"></td>
                      <td><input type="checkbox" v-model="agent.showTrail" @change.stop="persistCheckboxState('agents', id, 'showTrail', agent.showTrail)"></td>
                      <td><input type="checkbox" v-model="agent.dim" @change.stop="persistCheckboxState('agents', id, 'dim', agent.dim)"></td>
                      <td><input type="checkbox" v-model="agent.showName" @change.stop="persistCheckboxState('agents', id, 'showName', agent.showName)"></td>
                      <td><input type="checkbox" v-model="agent.showCoordinates" @change.stop="persistCheckboxState('agents', id, 'showCoordinates', agent.showCoordinates)"></td>
                      <td><span>{{ agent.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div v-if="Object.keys(groupData.visionagents).length > 0">
              <div class="table-header" @click="toggleTable('visionagents')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.visionagents }"></div>
                <span>Vision Agents</span>
              </div>
              <div v-show="!tableCollapsed.visionagents">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>x</th>
                      <th>y</th>
                      <th>Psi</th>
                      <th>Radius</th>
                      <th>FOV (rad)</th>
                      <th>Visible</th>
                      <th>Trails</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Show Coordinates</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(agent, id) in groupData.visionagents" :key="id" :class="{ selected: isSelected('visionagent', id) }">
                      <td @click.stop="$emit('select-element', 'visionagent', id, fullPath)"><span :style="{ background: agent.color ? formatColor(agent.color) : 'black', display: 'inline-block', width: '10px', height: '10px', borderRadius: '50%', marginRight: '4px' }"></span>{{ id }}</td>
                      <td>{{ formatNumber(agent.position[0]) }}</td>
                      <td>{{ formatNumber(agent.position[1]) }}</td>
                      <td>{{ formatNumber(agent.psi) }}</td>
                      <td>{{ formatNumber(agent.vision_radius) }}</td>
                      <td>{{ formatNumber(agent.vision_fov) }}</td>
                      <td><input type="checkbox" v-model="agent.visible" @change.stop="persistCheckboxState('visionagents', id, 'visible', agent.visible)"></td>
                      <td><input type="checkbox" v-model="agent.showTrail" @change.stop="persistCheckboxState('visionagents', id, 'showTrail', agent.showTrail)"></td>
                      <td><input type="checkbox" v-model="agent.dim" @change.stop="persistCheckboxState('visionagents', id, 'dim', agent.dim)"></td>
                      <td><input type="checkbox" v-model="agent.showName" @change.stop="persistCheckboxState('visionagents', id, 'showName', agent.showName)"></td>
                      <td><input type="checkbox" v-model="agent.showCoordinates" @change.stop="persistCheckboxState('visionagents', id, 'showCoordinates', agent.showCoordinates)"></td>
                      <td><span>{{ agent.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div v-if="Object.keys(groupData.points).length > 0">
              <div class="table-header" @click="toggleTable('points')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.points }"></div>
                <span>Points</span>
              </div>
              <div v-show="!tableCollapsed.points">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>x</th>
                      <th>y</th>
                      <th>Visible</th>
                      <th>Trails</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Show Coordinates</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(pt, id) in groupData.points" :key="id" :class="{ selected: isSelected('point', id) }">
                      <td @click.stop="$emit('select-element', 'point', id, fullPath)"><span :style="{ background: pt.color ? formatColor(pt.color) : 'black', display: 'inline-block', width: '10px', height: '10px', borderRadius: '50%', marginRight: '4px' }"></span>{{ id }}</td>
                      <td>{{ formatNumber(pt.x) }}</td>
                      <td>{{ formatNumber(pt.y) }}</td>
                      <td><input type="checkbox" v-model="pt.visible" @change.stop="persistCheckboxState('points', id, 'visible', pt.visible)"></td>
                      <td><input type="checkbox" v-model="pt.showTrail" @change.stop="persistCheckboxState('points', id, 'showTrail', pt.showTrail)"></td>
                      <td><input type="checkbox" v-model="pt.dim" @change.stop="persistCheckboxState('points', id, 'dim', pt.dim)"></td>
                      <td><input type="checkbox" v-model="pt.showName" @change.stop="persistCheckboxState('points', id, 'showName', pt.showName)"></td>
                      <td><input type="checkbox" v-model="pt.showCoordinates" @change.stop="persistCheckboxState('points', id, 'showCoordinates', pt.showCoordinates)"></td>
                      <td><span>{{ pt.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div v-if="Object.keys(groupData.vectors).length > 0">
              <div class="table-header" @click="toggleTable('vectors')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.vectors }"></div>
                <span>Vectors</span>
              </div>
              <div v-show="!tableCollapsed.vectors">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Origin</th>
                      <th>Vec</th>
                      <th>Visible</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(vec, id) in groupData.vectors" :key="id" :class="{ selected: isSelected('vector', id) }">
                      <td @click.stop="$emit('select-element', 'vector', id, fullPath)">{{ id }}</td>
                      <td>[{{ formatNumber(vec.origin[0]) }}, {{ formatNumber(vec.origin[1]) }}]</td>
                      <td>[{{ formatNumber(vec.vec[0]) }}, {{ formatNumber(vec.vec[1]) }}]</td>
                      <td><input type="checkbox" v-model="vec.visible" @change.stop="persistCheckboxState('vectors', id, 'visible', vec.visible)"></td>
                      <td><input type="checkbox" v-model="vec.dim" @change.stop="persistCheckboxState('vectors', id, 'dim', vec.dim)"></td>
                      <td><input type="checkbox" v-model="vec.showName" @change.stop="persistCheckboxState('vectors', id, 'showName', vec.showName)"></td>
                      <td><span>{{ vec.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div v-if="Object.keys(groupData.coordinate_systems).length > 0">
              <div class="table-header" @click="toggleTable('coordinate_systems')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.coordinate_systems }"></div>
                <span>Coordinate Systems</span>
              </div>
              <div v-show="!tableCollapsed.coordinate_systems">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Origin</th>
                      <th>ex</th>
                      <th>ey</th>
                      <th>Visible</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(cs, id) in groupData.coordinate_systems" :key="id" :class="{ selected: isSelected('coordinate_system', id) }">
                      <td @click.stop="$emit('select-element', 'coordinate_system', id, fullPath)">{{ id }}</td>
                      <td>[{{ formatNumber(cs.origin[0]) }}, {{ formatNumber(cs.origin[1]) }}]</td>
                      <td>[{{ formatNumber(cs.ex[0]) }}, {{ formatNumber(cs.ex[1]) }}]</td>
                      <td>[{{ formatNumber(cs.ey[0]) }}, {{ formatNumber(cs.ey[1]) }}]</td>
                      <td><input type="checkbox" v-model="cs.visible" @change.stop="persistCheckboxState('coordinate_systems', id, 'visible', cs.visible)"></td>
                      <td><input type="checkbox" v-model="cs.dim" @change.stop="persistCheckboxState('coordinate_systems', id, 'dim', cs.dim)"></td>
                      <td><input type="checkbox" v-model="cs.showName" @change.stop="persistCheckboxState('coordinate_systems', id, 'showName', cs.showName)"></td>
                      <td><span>{{ cs.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div v-if="Object.keys(groupData.lines).length > 0">
              <div class="table-header" @click="toggleTable('lines')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.lines }"></div>
                <span>Lines</span>
              </div>
              <div v-show="!tableCollapsed.lines">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Start</th>
                      <th>End</th>
                      <th>Visible</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(line, id) in groupData.lines" :key="id" :class="{ selected: isSelected('line', id) }">
                      <td @click.stop="$emit('select-element', 'line', id, fullPath)">{{ id }}</td>
                      <td>{{ line.start }}</td>
                      <td>{{ line.end }}</td>
                      <td><input type="checkbox" v-model="line.visible" @change.stop="persistCheckboxState('lines', id, 'visible', line.visible)"></td>
                      <td><input type="checkbox" v-model="line.dim" @change.stop="persistCheckboxState('lines', id, 'dim', line.dim)"></td>
                      <td><input type="checkbox" v-model="line.showName" @change.stop="persistCheckboxState('lines', id, 'showName', line.showName)"></td>
                      <td><span>{{ line.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div v-if="Object.keys(groupData.rectangles).length > 0">
              <div class="table-header" @click="toggleTable('rectangles')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.rectangles }"></div>
                <span>Rectangles</span>
              </div>
              <div v-show="!tableCollapsed.rectangles">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Mid</th>
                      <th>x</th>
                      <th>Visible</th>
                      <th>Dim</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(rect, id) in groupData.rectangles" :key="id" :class="{ selected: isSelected('rectangle', id) }">
                      <td @click.stop="$emit('select-element', 'rectangle', id, fullPath)">{{ id }}</td>
                      <td>[{{ formatNumber(rect.mid[0]) }}, {{ formatNumber(rect.mid[1]) }}]</td>
                      <td>{{ rect.x }}</td>
                      <td><input type="checkbox" v-model="rect.visible" @change.stop="persistCheckboxState('rectangles', id, 'visible', rect.visible)"></td>
                      <td><input type="checkbox" v-model="rect.dim" @change.stop="persistCheckboxState('rectangles', id, 'dim', rect.dim)"></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <div v-if="Object.keys(groupData.circles).length > 0">
              <div class="table-header" @click="toggleTable('circles')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.circles }"></div>
                <span>Circles</span>
              </div>
              <div v-show="!tableCollapsed.circles">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Mid</th>
                      <th>Diameter</th>
                      <th>Visible</th>
                      <th>Dim</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(circle, id) in groupData.circles" :key="id" :class="{ selected: isSelected('circle', id) }">
                      <td @click.stop="$emit('select-element', 'circle', id, fullPath)">{{ id }}</td>
                      <td>[{{ formatNumber(circle.mid[0]) }}, {{ formatNumber(circle.mid[1]) }}]</td>
                      <td>{{ circle.diameter }}</td>
                      <td><input type="checkbox" v-model="circle.visible" @change.stop="persistCheckboxState('circles', id, 'visible', circle.visible)"></td>
                      <td><input type="checkbox" v-model="circle.dim" @change.stop="persistCheckboxState('circles', id, 'dim', circle.dim)"></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Nested groups -->
            <div v-if="groupData.groups && Object.keys(groupData.groups).length > 0">
              <group-panel
                v-for="(subGroupData, subGroupName) in groupData.groups"
                :key="subGroupData.fullPath || subGroupName"
                :group-name="subGroupName"
                :group-data="subGroupData"
                :format-color="formatColor"
                :format-number="formatNumber"
                :selected-element="selectedElement"
                @select-element="forwardSelect"
              ></group-panel>
            </div>
          </div>
        </div>
      `
    });

    // --- Main Vue app ---
    createApp({
      components: { GroupPanel },
      setup() {
        function formatNumber(num) {
          return (num >= 0 ? " " : "") + Number(num).toFixed(2);
        }
        function formatColor(colorArray) {
          const r = Math.round(colorArray[0] * 255);
          const g = Math.round(colorArray[1] * 255);
          const b = Math.round(colorArray[2] * 255);
          return `rgb(${r},${g},${b})`;
        }
        function darkenColor(colorArray, factor = 0.7) {
          const r = Math.round(Math.max(0, colorArray[0] * 255 * factor));
          const g = Math.round(Math.max(0, colorArray[1] * 255 * factor));
          const b = Math.round(Math.max(0, colorArray[2] * 255 * factor));
          return `rgb(${r},${g},${b})`;
        }
        const effectiveAlpha = (elem) => {
          let a = elem.alpha !== undefined ? elem.alpha : 1;
          if (elem.dim) a *= 0.5;
          return a;
        };
        function drawArrow(ctx, from, to, color, lineWidth) {
          const headLength = lineWidth * 5;
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const angle = Math.atan2(dy, dx);
          const arrowTip = {
            x: to.x - (headLength * 0.6) * Math.cos(angle),
            y: to.y - (headLength * 0.6) * Math.sin(angle)
          };
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(arrowTip.x, arrowTip.y);
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(to.x, to.y);
          ctx.lineTo(
            to.x - headLength * Math.cos(angle - Math.PI / 6),
            to.y - headLength * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            to.x - headLength * Math.cos(angle + Math.PI / 6),
            to.y - headLength * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
        function drawShapeAt(ctx, pos, size, shape, fillColor, strokeColor, lineWidth, rotation = 0) {
          if (!shape || shape === 'circle') {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, size, 0, 2 * Math.PI);
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
          } else if (shape === 'square') {
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(-rotation + Math.PI / 4);
            ctx.beginPath();
            ctx.rect(-size, -size, 2 * size, 2 * size);
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
            ctx.restore();
          } else if (shape === 'triangle') {
            ctx.save();
            ctx.translate(pos.x, pos.y);
            ctx.rotate(-rotation);
            const vertices = [];
            for (let i = 0; i < 3; i++) {
              const a = i * 2 * Math.PI / 3;
              vertices.push({ x: size * Math.cos(a), y: size * Math.sin(a) });
            }
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
            ctx.restore();
          }
        }
        const worldWidth = ref(10);
        const worldHeight = ref(10);
        const gridSize = ref(0.5);
        if (localStorage.getItem('gridSize')) {
          gridSize.value = parseFloat(localStorage.getItem('gridSize'));
        }
        watch(gridSize, (newVal) => localStorage.setItem('gridSize', newVal));
        const globalPointSize = ref(1);
        const globalAgentSize = ref(1);
        const globalVectorSize = ref(1);
        const globalTrailSize = ref(1);
        const globalTextSize = ref(12);
        const globalDefaultSize = ref(1);
        if (localStorage.getItem('globalPointSize')) {
          globalPointSize.value = parseFloat(localStorage.getItem('globalPointSize'));
        }
        if (localStorage.getItem('globalAgentSize')) {
          globalAgentSize.value = parseFloat(localStorage.getItem('globalAgentSize'));
        }
        if (localStorage.getItem('globalVectorSize')) {
          globalVectorSize.value = parseFloat(localStorage.getItem('globalVectorSize'));
        }
        if (localStorage.getItem('globalTrailSize')) {
          globalTrailSize.value = parseFloat(localStorage.getItem('globalTrailSize'));
        }
        if (localStorage.getItem('globalTextSize')) {
          globalTextSize.value = parseFloat(localStorage.getItem('globalTextSize'));
        }
        const globalLineThickness = ref(2);
        if (localStorage.getItem('globalLineThickness')) {
          globalLineThickness.value = parseFloat(localStorage.getItem('globalLineThickness'));
        }
        watch(globalPointSize, (nv) => localStorage.setItem('globalPointSize', nv));
        watch(globalAgentSize, (nv) => localStorage.setItem('globalAgentSize', nv));
        watch(globalVectorSize, (nv) => localStorage.setItem('globalVectorSize', nv));
        watch(globalTrailSize, (nv) => localStorage.setItem('globalTrailSize', nv));
        watch(globalTextSize, (nv) => localStorage.setItem('globalTextSize', nv));
        watch(globalLineThickness, (nv) => localStorage.setItem('globalLineThickness', nv));
        const logGlobalPointSize = computed({
          get() { return Math.log(globalPointSize.value / 0.1) / Math.log(100); },
          set(val) { globalPointSize.value = 0.1 * Math.pow(100, val); }
        });
        const logGlobalAgentSize = computed({
          get() { return Math.log(globalAgentSize.value / 0.1) / Math.log(100); },
          set(val) { globalAgentSize.value = 0.1 * Math.pow(100, val); }
        });
        const logGlobalVectorSize = computed({
          get() { return Math.log(globalVectorSize.value / 0.1) / Math.log(100); },
          set(val) { globalVectorSize.value = 0.1 * Math.pow(100, val); }
        });
        const logGlobalTrailSize = computed({
          get() { return Math.log(globalTrailSize.value / 0.1) / Math.log(100); },
          set(val) { globalTrailSize.value = 0.1 * Math.pow(100, val); }
        });
        const worldWidthFormatted = computed({
          get() { return worldWidth.value.toFixed(2); },
          set(val) { worldWidth.value = parseFloat(val); }
        });
        const worldHeightFormatted = computed({
          get() { return worldHeight.value.toFixed(2); },
          set(val) { worldHeight.value = parseFloat(val); }
        });
        const canvasHeight = ref(localStorage.getItem('canvasHeight') ? parseInt(localStorage.getItem('canvasHeight')) : 600);
        const canvasWidth = ref(localStorage.getItem('canvasWidth') ? parseInt(localStorage.getItem('canvasWidth')) : 600);
        const scale = ref(60);
        let initialScale = localStorage.getItem('initialScale') ? parseFloat(localStorage.getItem('initialScale')) : null;
        const canvas = ref(null);
        const mapContainer = ref(null);
        // New ref for teleplot container and its width (persisted)
        const teleplotContainer = ref(null);
        const teleplotWidth = ref(localStorage.getItem('teleplotWidth') ? parseInt(localStorage.getItem('teleplotWidth')) : 600);
        // Toggle between teleplot iframe and tables; default is false (tables view)
        const showTeleplotIframe = ref(false);
        const groups = reactive({});
        const showPoints = ref(true);
        const showVectors = ref(true);
        const showCoordinateSystems = ref(true);
        const showLines = ref(true);
        const showAgents = ref(true);
        const showManual = ref(false);
        const manualOffsetX = ref(0);
        if (localStorage.getItem('manualOffsetX')) {
          manualOffsetX.value = parseFloat(localStorage.getItem('manualOffsetX'));
        }
        const manualOffsetY = ref(0);
        if (localStorage.getItem('manualOffsetY')) {
          manualOffsetY.value = parseFloat(localStorage.getItem('manualOffsetY'));
        }
        watch(manualOffsetX, (newVal) => localStorage.setItem('manualOffsetX', newVal));
        watch(manualOffsetY, (newVal) => localStorage.setItem('manualOffsetY', newVal));
        const useManualOffset = ref(false);
        const metaOffset = ref([0, 0]);
        const metaTitle = ref("");
        const manualOffsetXRounded = computed({
          get() { return Number(manualOffsetX.value.toFixed(2)); },
          set(val) { manualOffsetX.value = Number(val); }
        });
        const manualOffsetYRounded = computed({
          get() { return Number(manualOffsetY.value.toFixed(2)); },
          set(val) { manualOffsetY.value = Number(val); }
        });
        const selectedElement = ref(null);
        const selectElement = (type, id, groupPath) => {
          selectedElement.value = { type, id, group: groupPath };
          redraw();
        };
        const addGroupNameToLabel = ref(false);
        const showSettings = ref(false);
        const videos = ref({});
        const terminalLogs = ref([]);
        const terminalInput = ref("");
        const terminalLogContainer = ref(null);
        let terminalWs = null;
        const commandHistory = ref([]);
        const historyIndex = ref(null);
        function isNegativeNumber(str) {
          return /^-\d+(\.\d+)?$/.test(str);
        }
        function castValue(val) {
          if (/^-?\d+$/.test(val)) return parseInt(val, 10);
          if (/^-?\d+\.\d+$/.test(val)) return parseFloat(val);
          if (val.toLowerCase() === "true") return true;
          if (val.toLowerCase() === "false") return false;
          return val;
        }
        const commandSets = ref({});
        const activeSet = ref([]);
        const suggestions = ref("");
        const currentPath = computed(() => activeSet.value.join(" / ") || "");
        function splitTokens(text) {
          return text.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
        }
        function getSetByPath(pathArr) {
          let current = commandSets.value;
          for (let i = 1; i < pathArr.length; i++) {
            if (current.child_sets && current.child_sets[pathArr[i]]) {
              current = current.child_sets[pathArr[i]];
            } else {
              return null;
            }
          }
          return current;
        }
        function getSuggestions(inputText) {
          const tokens = splitTokens(inputText);
          const completeToken = inputText.endsWith(" ");
          let path = activeSet.value.length ? [...activeSet.value] : (commandSets.value.name ? [commandSets.value.name] : []);
          let currentSetLocal = getSetByPath(path) || commandSets.value;
          let tokensCopy = [...tokens];
          if (tokensCopy.length > 0) {
            if (tokensCopy[0] === "..") {
              if (path.length > 1) {
                path.pop();
                currentSetLocal = getSetByPath(path);
              }
              tokensCopy.shift();
            } else if (tokensCopy[0] === ".") {
              path = [commandSets.value.name];
              currentSetLocal = commandSets.value;
              tokensCopy.shift();
            }
          }
          let recognizedCommand = null;
          let tokensToTraverse = completeToken ? tokensCopy : tokensCopy.slice(0, tokensCopy.length - 1);
          let partialToken = completeToken ? "" : (tokensCopy[tokensCopy.length - 1] || "");
          for (let token of tokensToTraverse) {
            if (currentSetLocal.child_sets && currentSetLocal.child_sets[token]) {
              path.push(token);
              currentSetLocal = currentSetLocal.child_sets[token];
            } else if (currentSetLocal.commands && currentSetLocal.commands[token]) {
              recognizedCommand = currentSetLocal.commands[token];
              break;
            } else {
              break;
            }
          }
          if (recognizedCommand) {
            const args = recognizedCommand.arguments;
            if (args) {
              let argSuggestions = [];
              for (let argName in args) {
                let argDef = args[argName];
                let argType = argDef.type || "str";
                if (argType.toLowerCase() === "flag" || argType.toLowerCase() === "bool") {
                  argType = "FLAG";
                }
                if (argDef.short_name) {
                  argSuggestions.push("--" + argName + " (-" + argDef.short_name + ", " + argType + ")");
                } else {
                  argSuggestions.push("--" + argName + " (" + argType + ")");
                }
              }
              return "Inputs: " + argSuggestions.join(" ");
            }
            return "Inputs: none";
          } else {
            let extras = [];
            if (path.length > 1 && (!partialToken || "..".startsWith(partialToken))) {
              extras.push("..");
            }
            if (!partialToken || ".".startsWith(partialToken)) {
              extras.push(".");
            }
            let sets = [];
            if (currentSetLocal.child_sets) {
              for (let s in currentSetLocal.child_sets) {
                if (!partialToken || s.toLowerCase().startsWith(partialToken.toLowerCase())) {
                  sets.push(s);
                }
              }
            }
            let cmds = [];
            if (currentSetLocal.commands) {
              for (let c in currentSetLocal.commands) {
                if (!partialToken || c.toLowerCase().startsWith(partialToken.toLowerCase())) {
                  cmds.push(c);
                }
              }
            }
            const extrasFormatted = extras.map(x => "<span>" + x + "</span>");
            const setsFormatted = sets.map(x => "<span style=\"color: orange;\">" + x + "</span>");
            const cmdsFormatted = cmds.map(x => "<span style=\"color: cyan;\">" + x + "</span>");
            const allFormatted = extrasFormatted.concat(setsFormatted).concat(cmdsFormatted);
            return "Commands: " + (allFormatted.length ? allFormatted.join(" ") : "none");
          }
        }
        function updateSuggestions() {
          suggestions.value = getSuggestions(terminalInput.value);
        }
        function parseCommand(inputText) {
          const tokens = splitTokens(inputText);
          if (tokens.length === 0) {
            return { success: false, error: "Empty command" };
          }
          let path = activeSet.value.length ? [...activeSet.value] : (commandSets.value.name ? [commandSets.value.name] : []);
          let currentSetLocal = getSetByPath(path) || commandSets.value;
          let i = 0;
          while (i < tokens.length && (tokens[i] === "." || tokens[i] === "..")) {
            if (tokens[i] === ".") {
              path = [commandSets.value.name];
              currentSetLocal = commandSets.value;
            } else if (tokens[i] === "..") {
              if (path.length > 1) {
                path.pop();
                currentSetLocal = getSetByPath(path);
              } else {
                return { success: false, error: "Already at root, cannot exit further." };
              }
            }
            i++;
          }
          let cmdName = null;
          for (; i < tokens.length; i++) {
            let token = tokens[i];
            if (currentSetLocal.child_sets && currentSetLocal.child_sets[token]) {
              path.push(token);
              currentSetLocal = currentSetLocal.child_sets[token];
            } else if (currentSetLocal.commands && currentSetLocal.commands[token]) {
              cmdName = token;
              i++;
              break;
            } else {
              return { success: false, error: "Token '" + token + "' not recognized in set " + path.join("/") };
            }
          }
          if (!cmdName) {
            activeSet.value = path;
            return { success: true, type: "change_set", active_set: path };
          }
          const cmdDef = currentSetLocal.commands[cmdName];
          let positional = [];
          let keyword = {};
          while (i < tokens.length) {
              let token = tokens[i];
              if (token.startsWith("--")) {
                  if (token.includes("=")) {
                      let eqIndex = token.indexOf("=");
                      let key = token.slice(2, eqIndex);
                      let value = token.slice(eqIndex+1);
                      keyword[key] = value;
                  } else {
                      let key = token.slice(2);
                      if (i+1 < tokens.length && !tokens[i+1].startsWith("-")) {
                          keyword[key] = tokens[i+1];
                          i++;
                      } else {
                          keyword[key] = true;
                      }
                  }
              } else if (token.startsWith("-") && !token.startsWith("--")) {
                  let short = token.slice(1);
                  let matchedLong = null;
                  if (cmdDef && cmdDef.arguments) {
                    for (let argName in cmdDef.arguments) {
                      let argDef = cmdDef.arguments[argName];
                      if (argDef.short_name === short) {
                        matchedLong = argName;
                        break;
                      }
                    }
                  }
                  if (matchedLong) {
                      if (i+1 < tokens.length && (!tokens[i+1].startsWith("-") || isNegativeNumber(tokens[i+1]))) {
                          keyword[matchedLong] = tokens[i+1];
                          i++;
                      } else {
                          keyword[matchedLong] = true;
                      }
                  } else {
                      positional.push(token);
                  }
              } else {
                  positional.push(token);
              }
              i++;
          }
          positional = positional.map(castValue);
          for (let key in keyword) {
              if (cmdDef && cmdDef.arguments && cmdDef.arguments[key] && cmdDef.arguments[key].type) {
                  let argType = cmdDef.arguments[key].type.toLowerCase();
                  if (argType === "int") {
                      keyword[key] = parseInt(keyword[key], 10);
                  } else if (argType === "float") {
                      keyword[key] = parseFloat(keyword[key]);
                  } else if (argType === "bool" || argType === "flag") {
                      keyword[key] = (keyword[key] === true || keyword[key].toString().toLowerCase() === "true");
                  } else {
                      keyword[key] = keyword[key];
                  }
              } else {
                  keyword[key] = castValue(keyword[key]);
              }
          }
          return { success: true, type: "command", command: { name: cmdName, path: path, arguments: { positional: positional, keyword: keyword } }, active_set: activeSet.value };
        }
        function handleTerminalSubmit() {
          const text = terminalInput.value.trim();
          if (!text) return;
          if (text.toLowerCase() === "clear") {
            terminalLogs.value = [];
            terminalInput.value = "";
            updateSuggestions();
            return;
          }
          addLog(">> " + text, "cyan");
          commandHistory.value.push(text);
          historyIndex.value = null;
          const result = parseCommand(text);
          if (!result.success) {
            addLog(result.error, "red");
          } else {
            if (result.type === "change_set") {
              activeSet.value = result.active_set;
              addLog("Changed command set to: " + activeSet.value.join(" / "), "yellow");
            }
            if (result.type === "command") {
              if (terminalWs && terminalWs.readyState === WebSocket.OPEN) {
                const msg = { type: 'command', data: result.command };
                terminalWs.send(JSON.stringify(msg));
              } else {
                addLog("Websocket not connected", "red");
              }
            }
          }
          terminalInput.value = "";
          updateSuggestions();
          redraw();
        }
        function addLog(text, color) {
          const now = new Date();
          const timestamp = now.toLocaleTimeString();
          terminalLogs.value.push({ text: "[" + timestamp + "] " + text, color: color });
          nextTick(() => {
            if (terminalLogContainer.value) {
              terminalLogContainer.value.scrollTop = terminalLogContainer.value.scrollHeight;
            }
          });
        }
        function handleKeydown(e) {
          if (e.key === "ArrowUp") {
            if (commandHistory.value.length > 0) {
              if (historyIndex.value === null) {
                historyIndex.value = commandHistory.value.length - 1;
              } else if (historyIndex.value > 0) {
                historyIndex.value--;
              }
              terminalInput.value = commandHistory.value[historyIndex.value];
              updateSuggestions();
            }
            e.preventDefault();
          } else if (e.key === "ArrowDown") {
            if (commandHistory.value.length > 0 && historyIndex.value !== null) {
              if (historyIndex.value < commandHistory.value.length - 1) {
                historyIndex.value++;
                terminalInput.value = commandHistory.value[historyIndex.value];
              } else {
                historyIndex.value = null;
                terminalInput.value = "";
              }
              updateSuggestions();
            }
            e.preventDefault();
          }
        }
        function worldToCanvas(x, y) {
          if (worldWidth.value <= 0 || worldHeight.value <= 0) return { x: 0, y: 0 };
          const offset = useManualOffset.value ? [manualOffsetX.value, manualOffsetY.value] : metaOffset.value;
          const canvasX = ((x + offset[0]) + worldWidth.value / 2) * scale.value;
          const canvasY = (worldHeight.value / 2 - (y + offset[1])) * scale.value;
          return { x: canvasX, y: canvasY };
        }
        function updateCanvasSize() {
          if (!mapContainer.value) return;
          if (mapEnlarged.value) return; // Do not update if map is enlarged
          canvasWidth.value = mapContainer.value.clientWidth;
          canvasHeight.value = mapContainer.value.clientHeight;
          localStorage.setItem('canvasWidth', canvasWidth.value);
          localStorage.setItem('canvasHeight', canvasHeight.value);
          if (!initialScale) {
            initialScale = canvasHeight.value / worldHeight.value;
          }
          worldWidth.value = canvasWidth.value / initialScale;
          worldHeight.value = canvasHeight.value / initialScale;
          scale.value = initialScale;
          canvas.value.width = canvasWidth.value;
          canvas.value.height = canvasHeight.value;
        }


        // New computed property for map container style based on enlargement state
        // const mapContainerStyle = computed(() => {
        //   if (mapEnlarged.value) {
        //     return { width: window.innerWidth + "px", height: window.innerHeight + "px" };
        //   } else {
        //     return { width: canvasWidth.value + "px", height: canvasHeight.value + "px" };
        //   }
        // });
        // New reactive variable for enlarged state and storage for original size
        const mapEnlarged = ref(false);
        const originalMapWidth = ref(null);
        const originalMapHeight = ref(null);
        const originalScale = ref(null);

       function toggleMapSize() {
  // Force manual offset mode
  useManualOffset.value = true;

  if (!mapEnlarged.value) {
    // Calculate the current canvas center in canvas coordinates
    const centerCanvas = { x: canvasWidth.value / 2, y: canvasHeight.value / 2 };
    // Compute the current world coordinate at the canvas center.
    // Inverse of:
    //   canvasX = ((x + offsetX) + worldWidth/2) * scale
    //   canvasY = (worldHeight/2 - (y + offsetY)) * scale
    const currentCenterWorld = {
      x: centerCanvas.x / scale.value - worldWidth.value / 2 - manualOffsetX.value,
      y: worldHeight.value / 2 - centerCanvas.y / scale.value - manualOffsetY.value
    };

    // Store original dimensions and scale
    originalMapWidth.value = canvasWidth.value;
    originalMapHeight.value = canvasHeight.value;
    originalScale.value = scale.value;

    // Enlarge the canvas dimensions to fill the window
    canvasWidth.value = window.innerWidth;
    canvasHeight.value = window.innerHeight * 0.8;
    canvas.value.width = canvasWidth.value;
    canvas.value.height = canvasHeight.value;

    // Recompute the scale so that the world width stays consistent.
    // currentWorldWidth is derived from the original canvas size and scale.
    const currentWorldWidth = originalMapWidth.value / originalScale.value;
    scale.value = canvasWidth.value / currentWorldWidth;

    // Now calculate the new offset so that the new canvas center maps to the same world coordinate.
    const newCenterCanvas = { x: canvasWidth.value / 2, y: canvasHeight.value / 2 };
    manualOffsetX.value =
      newCenterCanvas.x / scale.value - worldWidth.value / 2 - currentCenterWorld.x;
    manualOffsetY.value =
      worldHeight.value / 2 - newCenterCanvas.y / scale.value - currentCenterWorld.y;

    mapEnlarged.value = true;
    redraw();
  } else {
    // Revert to original dimensions, scale, and offsets.
    canvasWidth.value = originalMapWidth.value;
    canvasHeight.value = originalMapHeight.value;
    canvas.value.width = canvasWidth.value;
    canvas.value.height = canvasHeight.value;
    scale.value = originalScale.value;
    mapEnlarged.value = false;
    redraw();
  }
}


const mapContainerStyle = computed(() => {
          if (mapEnlarged.value) {
            return {
              width: window.innerWidth + "px",
              height: (window.innerHeight * 0.8) + "px" // 80% of window height
            };
          } else {
            return {
              width: canvasWidth.value + "px",
              height: canvasHeight.value + "px"
            };
          }
        });

        function findInGroup(objName, grp) {
          if (!grp) return null;
          if (grp.points && grp.points[objName] && grp.points[objName].visible !== false) {
            const pt = grp.points[objName];
            return { x: pt.x, y: pt.y };
          }
          if (grp.agents && grp.agents[objName] && grp.agents[objName].visible !== false) {
            const ag = grp.agents[objName];
            return { x: ag.position[0], y: ag.position[1] };
          }
          if (grp.visionagents && grp.visionagents[objName] && grp.visionagents[objName].visible !== false) {
            const vag = grp.visionagents[objName];
            return { x: vag.position[0], y: vag.position[1] };
          }
          if (grp.coordinate_systems && grp.coordinate_systems[objName] && grp.coordinate_systems[objName].visible !== false) {
            const cs = grp.coordinate_systems[objName];
            return { x: cs.origin[0], y: cs.origin[1] };
          }
          return null;
        }
        function findGroupByPath(grp, pathSegments) {
          if (!pathSegments.length) return grp;
          const next = pathSegments[0];
          if (!grp.groups || !grp.groups[next]) {
            return null;
          }
          return findGroupByPath(grp.groups[next], pathSegments.slice(1));
        }
        function findInAbsolutePath(pathString) {
          const parts = pathString.split('/');
          if (!parts.length) return null;
          const firstGroup = parts[0];
          const rest = parts.slice(1);
          if (!groups[firstGroup]) return null;
          let currentGroupObj = groups[firstGroup];
          while (rest.length > 1) {
            const subName = rest[0];
            if (!currentGroupObj.groups || !currentGroupObj.groups[subName]) {
              return null;
            }
            currentGroupObj = currentGroupObj.groups[subName];
            rest.shift();
          }
          const objName = rest[0];
          return findInGroup(objName, currentGroupObj);
        }
        function findInParentPath(pathString, currentGroup) {
          if (!currentGroup.parent) return null;
          return findInGroup(pathString, currentGroup.parent);
        }
        function resolvePosition(ref, currentGroup) {
          if (Array.isArray(ref)) {
            return { x: ref[0], y: ref[1] };
          }
          if (typeof ref !== 'string') return null;
          if (ref.startsWith('/')) {
            const pathString = ref.substring(1);
            return findInAbsolutePath(pathString);
          }
          if (ref.startsWith('../')) {
            const localName = ref.substring(3);
            return findInParentPath(localName, currentGroup);
          }
          return findInGroup(ref, currentGroup);
        }
        function drawCornerAxes(ctx) {
          const margin = 40;
          const canvasH = ctx.canvas.height;
          const start = { x: margin, y: canvasH - margin };
          const arrowLength = 80;
          const headLength = 8;
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(start.x + arrowLength, start.y);
          ctx.strokeStyle = "red";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(start.x + arrowLength, start.y);
          ctx.lineTo(start.x + arrowLength - headLength, start.y - headLength / 2);
          ctx.lineTo(start.x + arrowLength - headLength, start.y + headLength / 2);
          ctx.closePath();
          ctx.fillStyle = "red";
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(start.x, start.y - arrowLength);
          ctx.strokeStyle = "green";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(start.x, start.y - arrowLength);
          ctx.lineTo(start.x - headLength / 2, start.y - arrowLength + headLength);
          ctx.lineTo(start.x + headLength / 2, start.y - arrowLength + headLength);
          ctx.closePath();
          ctx.fillStyle = "green";
          ctx.fill();
        }
        function traverseGroupsWithVisibility(groupObj, parentVisible, callback) {
          const thisEffective = parentVisible && groupObj.visible !== false;
          groupObj.effectiveVisibility = thisEffective;
          callback(groupObj, thisEffective);
          if (groupObj.groups) {
            for (const gName in groupObj.groups) {
              traverseGroupsWithVisibility(groupObj.groups[gName], thisEffective, callback);
            }
          }
        }
        function updateEffectiveVisibilityAndTraverse(callback) {
          for (const rootName in groups) {
            traverseGroupsWithVisibility(groups[rootName], true, callback);
          }
        }
        const drawPoints = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showPoints.value) return;
            for (const label in group.points) {
              const pt = group.points[label];
              if (pt.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(pt);
              const pos = worldToCanvas(pt.x, pt.y);
              const size = (pt.size !== undefined ? pt.size : 1) * (globalPointSize.value * 5) * globalDefaultSize.value;
              const shape = pt.shape ? pt.shape.toLowerCase() : "circle";
              let colorStr = pt.color ? formatColor(pt.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "point" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              if (pt.showTrail && pt.trailHistory && pt.trailHistory.length > 0) {
                ctx.save();
                ctx.strokeStyle = colorStr;
                ctx.lineWidth = globalTrailSize.value * globalDefaultSize.value;
                let prev = null;
                pt.trailHistory.forEach(trailPos => {
                  const canvasPos = worldToCanvas(trailPos.x, trailPos.y);
                  ctx.beginPath();
                  ctx.arc(canvasPos.x, canvasPos.y, globalTrailSize.value * globalDefaultSize.value, 0, 2 * Math.PI);
                  ctx.fillStyle = colorStr;
                  ctx.fill();
                  if (prev) {
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(canvasPos.x, canvasPos.y);
                    ctx.stroke();
                  }
                  prev = canvasPos;
                });
                ctx.restore();
              }
              const lineWidth = Math.max(1, globalPointSize.value * 0.2 * globalDefaultSize.value);
              drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", lineWidth);
              const labelPieces = [];
              if (pt.showName) {
                if (addGroupNameToLabel.value) {
                  labelPieces.push("[" + group.fullPath + "] " + label);
                } else {
                  labelPieces.push(label);
                }
              }
              if (pt.showCoordinates) {
                labelPieces.push("[" + formatNumber(pt.x) + ", " + formatNumber(pt.y) + "]");
              }
              const labelText = labelPieces.join(" ");
              if (labelText) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = pt.color ? darkenColor(pt.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(labelText, pos.x, pos.y - (size + globalTextSize.value * 0.5));
              }
              if (pt.text) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = pt.color ? darkenColor(pt.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(pt.text, pos.x, pos.y + (size + globalTextSize.value));
              }
              if (isSel) {
                ctx.save();
                ctx.strokeStyle = "red";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size + 3, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
              }
              ctx.restore();
            }
          });
        };
        const drawAgents = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showAgents.value) return;
            for (const label in group.agents) {
              const agent = group.agents[label];
              if (agent.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(agent);
              const pos = worldToCanvas(agent.position[0], agent.position[1]);
              const size = (agent.size !== undefined ? agent.size : 1) * (globalAgentSize.value * 5) * globalDefaultSize.value;
              let colorStr = agent.color ? formatColor(agent.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "agent" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              if (agent.trailHistory && agent.showTrail && agent.trailHistory.length > 0) {
                ctx.save();
                ctx.strokeStyle = colorStr;
                ctx.lineWidth = globalTrailSize.value * globalDefaultSize.value;
                let prev = null;
                agent.trailHistory.forEach(trailPos => {
                  const canvasPos = worldToCanvas(trailPos.x, trailPos.y);
                  ctx.beginPath();
                  ctx.arc(canvasPos.x, canvasPos.y, globalTrailSize.value * globalDefaultSize.value, 0, 2 * Math.PI);
                  ctx.fillStyle = colorStr;
                  ctx.fill();
                  if (prev) {
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(canvasPos.x, canvasPos.y);
                    ctx.stroke();
                  }
                  prev = canvasPos;
                });
                ctx.restore();
              }
              const arrowLengthWorld = (size * 4) / scale.value;
              const arrowEndWorld = [
                agent.position[0] + Math.cos(agent.psi) * arrowLengthWorld,
                agent.position[1] + Math.sin(agent.psi) * arrowLengthWorld
              ];
              const arrowEnd = worldToCanvas(arrowEndWorld[0], arrowEndWorld[1]);
              const arrowThickness = Math.max(1, size / 5);
              drawArrow(ctx, pos, arrowEnd, colorStr, arrowThickness);
              const shape = agent.shape ? agent.shape.toLowerCase() : "circle";
              if (shape === "square" || shape === "triangle") {
                drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", arrowThickness, agent.psi);
              } else {
                drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", arrowThickness);
              }
              const labelPieces = [];
              if (agent.showName) {
                if (addGroupNameToLabel.value) {
                  labelPieces.push("[" + group.fullPath + "] " + label);
                } else {
                  labelPieces.push(label);
                }
              }
              if (agent.showCoordinates) {
                labelPieces.push("[" + formatNumber(agent.position[0]) + ", " + formatNumber(agent.position[1]) + "]");
              }
              const labelText = labelPieces.join(" ");
              if (labelText) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = agent.color ? darkenColor(agent.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(labelText, pos.x, pos.y - (size * 2 + globalTextSize.value * 0.125));
              }
              if (agent.text) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = agent.color ? darkenColor(agent.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(agent.text, pos.x, pos.y + (size + globalTextSize.value));
              }
              if (isSel) {
                ctx.save();
                ctx.strokeStyle = "red";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 1.5, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
              }
              ctx.restore();
            }
          });
        };
         const drawVisionAgents = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showAgents.value) return;
            for (const label in group.visionagents) {
              const vag = group.visionagents[label];
              if (vag.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(vag);
              const pos = worldToCanvas(vag.position[0], vag.position[1]);
              const size = (vag.size !== undefined ? vag.size : 1) * (globalAgentSize.value * 5) * globalDefaultSize.value;
              let colorStr = vag.color ? formatColor(vag.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "visionagent" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              if (vag.trailHistory && vag.showTrail && vag.trailHistory.length > 0) {
                ctx.save();
                ctx.strokeStyle = colorStr;
                ctx.lineWidth = globalTrailSize.value * globalDefaultSize.value;
                let prev = null;
                vag.trailHistory.forEach(trailPos => {
                  const canvasPos = worldToCanvas(trailPos.x, trailPos.y);
                  ctx.beginPath();
                  ctx.arc(canvasPos.x, canvasPos.y, globalTrailSize.value * globalDefaultSize.value, 0, 2 * Math.PI);
                  ctx.fillStyle = colorStr;
                  ctx.fill();
                  if (prev) {
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(canvasPos.x, canvasPos.y);
                    ctx.stroke();
                  }
                  prev = canvasPos;
                });
                ctx.restore();
              }
              const arrowLengthWorld = (size * 4) / scale.value;
              const arrowEndWorld = [
                vag.position[0] + Math.cos(vag.psi) * arrowLengthWorld,
                vag.position[1] + Math.sin(vag.psi) * arrowLengthWorld
              ];
              const arrowEnd = worldToCanvas(arrowEndWorld[0], arrowEndWorld[1]);
              const arrowThickness = Math.max(1, size / 5);
              drawArrow(ctx, pos, arrowEnd, colorStr, arrowThickness);
              const shape = vag.shape ? vag.shape.toLowerCase() : "circle";
              if (shape === "square" || shape === "triangle") {
                drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", arrowThickness, vag.psi);
              } else {
                drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", arrowThickness);
              }
              if (vag.vision_radius && vag.vision_radius > 0 && vag.vision_fov) {
                ctx.save();
                ctx.globalAlpha *= 0.25;
                const radiusPx = vag.vision_radius * scale.value;
                const arcStart = vag.psi - vag.vision_fov / 2;
                const arcEnd = vag.psi + vag.vision_fov / 2;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.arc(pos.x, pos.y, radiusPx, -arcStart, -arcEnd, true);
                ctx.closePath();
                ctx.fillStyle = colorStr;
                ctx.fill();
                ctx.strokeStyle = colorStr;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.restore();
              }
              const labelPieces = [];
              if (vag.showName) {
                if (addGroupNameToLabel.value) {
                  labelPieces.push("[" + group.fullPath + "] " + label);
                } else {
                  labelPieces.push(label);
                }
              }
              if (vag.showCoordinates) {
                labelPieces.push("[" + formatNumber(vag.position[0]) + ", " + formatNumber(vag.position[1]) + "]");
              }
              const labelText = labelPieces.join(" ");
              if (labelText) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = vag.color ? darkenColor(vag.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(labelText, pos.x, pos.y - (size * 2 + globalTextSize.value * 0.125));
              }
              if (vag.text) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = vag.color ? darkenColor(vag.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(vag.text, pos.x, pos.y + (size + globalTextSize.value));
              }
              if (isSel) {
                ctx.save();
                ctx.strokeStyle = "red";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 1.5, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
              }
              ctx.restore();
            }
          });
        };
        const drawVectors = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showVectors.value) return;
            for (const label in group.vectors) {
              const vecData = group.vectors[label];
              if (vecData.visible === false) continue;
              if (!vecData.vec || !vecData.origin) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(vecData);
              const start = worldToCanvas(vecData.origin[0], vecData.origin[1]);
              const end = worldToCanvas(
                vecData.origin[0] + vecData.vec[0],
                vecData.origin[1] + vecData.vec[1]
              );
              const thickness = (vecData.thickness !== undefined ? vecData.thickness : (globalVectorSize.value * 2)) * globalDefaultSize.value;
              let colorStr = vecData.color ? formatColor(vecData.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "vector" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              drawArrow(ctx, start, end, colorStr, thickness);
              if (vecData.showName === undefined || vecData.showName) {
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(angle);
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = colorStr;
                ctx.textAlign = "center";
                ctx.fillText(label, 0, -thickness - globalTextSize.value * 0.3);
                if (vecData.text) {
                  ctx.fillText(vecData.text, 0, thickness + globalTextSize.value + 2);
                }
                ctx.restore();
              }
              ctx.restore();
            }
          });
        };
        const drawCoordinateSystems = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showCoordinateSystems.value) return;
            for (const label in group.coordinate_systems) {
              const cs = group.coordinate_systems[label];
              if (cs.visible === false) continue;
              if (!cs.origin || !cs.ex || !cs.ey) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(cs);
              const thickness = (cs.thickness !== undefined ? cs.thickness : (globalVectorSize.value * 2)) * globalDefaultSize.value;
              const origin = worldToCanvas(cs.origin[0], cs.origin[1]);
              const exEnd = worldToCanvas(
                cs.origin[0] + cs.ex[0],
                cs.origin[1] + cs.ex[1]
              );
              const eyEnd = worldToCanvas(
                cs.origin[0] + cs.ey[0],
                cs.origin[1] + cs.ey[1]
              );
              const exColor = (cs.colors && cs.colors.ex) ? formatColor(cs.colors.ex) : "rgb(255,0,0)";
              const eyColor = (cs.colors && cs.colors.ey) ? formatColor(cs.colors.ey) : "rgb(0,255,0)";
              let textColor = "black";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "coordinate_system" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                textColor = "red";
              }
              ctx.beginPath();
              ctx.arc(origin.x, origin.y, 3, 0, 2 * Math.PI);
              ctx.fillStyle = "black";
              ctx.fill();
              drawArrow(ctx, origin, exEnd, exColor, thickness);
              drawArrow(ctx, origin, eyEnd, eyColor, thickness);
              if (cs.showName === undefined || cs.showName) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = textColor;
                ctx.textAlign = "center";
                ctx.fillText(label, origin.x, origin.y + thickness + globalTextSize.value);
                if (cs.text) {
                  ctx.fillText(cs.text, origin.x, origin.y + thickness + 2 * globalTextSize.value);
                }
              }
              ctx.restore();
            }
          });
        };
        const drawLines = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showLines.value) return;
            for (const label in group.lines) {
              const line = group.lines[label];
              if (line.visible === false) continue;
              if (!line.start || !line.end) continue;
              const startCoord = resolvePosition(line.start, group);
              const endCoord = resolvePosition(line.end, group);
              if (!startCoord || !endCoord) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(line);
              const start = worldToCanvas(startCoord.x, startCoord.y);
              const end = worldToCanvas(endCoord.x, endCoord.y);
              const thickness = (line.thickness !== undefined ? line.thickness : globalLineThickness.value) * globalDefaultSize.value;
              let colorStr = line.color ? formatColor(line.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "line" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              ctx.setLineDash([5, 5]);
              ctx.lineWidth = thickness;
              ctx.strokeStyle = colorStr;
              ctx.beginPath();
              ctx.moveTo(start.x, start.y);
              ctx.lineTo(end.x, end.y);
              ctx.stroke();
              ctx.setLineDash([]);
              ctx.save();
              const midX = (start.x + end.x) / 2;
              const midY = (start.y + end.y) / 2;
              const angle = Math.atan2(end.y - start.y, end.x - start.x);
              ctx.translate(midX, midY);
              ctx.rotate(angle);
              ctx.font = globalTextSize.value + "px Arial";
              ctx.fillStyle = colorStr;
              ctx.textAlign = "center";
              if (line.showName) {
                ctx.fillText(label, 0, -thickness - globalTextSize.value * 0.3);
              }
              if (line.text) {
                ctx.fillText(line.text, 0, thickness + globalTextSize.value + 2);
              }
              ctx.restore();
              ctx.restore();
            }
          });
        };
        const drawRectangles = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group) => {
            for (const label in group.rectangles) {
              const rect = group.rectangles[label];
              if (rect.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(rect);
              const mid = rect.mid;
              const widthWorld = rect.x;
              const heightWorld = rect.y || rect.x;
              const leftWorld = mid[0] - widthWorld / 2;
              const topWorld = mid[1] + heightWorld / 2;
              const topLeft = worldToCanvas(leftWorld, topWorld);
              const bottomRight = worldToCanvas(
                mid[0] + widthWorld / 2,
                mid[1] - heightWorld / 2
              );
              const rectX = topLeft.x;
              const rectY = topLeft.y;
              const rectWidth = Math.abs(bottomRight.x - topLeft.x);
              const rectHeight = Math.abs(bottomRight.y - topLeft.y);
              if (rect.fill) {
                ctx.fillStyle = formatColor(rect.fill);
                ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
              }
              ctx.lineWidth = globalVectorSize.value * 2 * globalDefaultSize.value;
              ctx.strokeStyle = rect.linecolor ? formatColor(rect.linecolor) : "rgb(0,0,0)";
              ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
              ctx.restore();
            }
          });
        };
        const drawCircles = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group) => {
            for (const label in group.circles) {
              const circle = group.circles[label];
              if (circle.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(circle);
              const midCanvas = worldToCanvas(circle.mid[0], circle.mid[1]);
              const diameter = circle.diameter !== undefined ? circle.diameter : (globalPointSize.value * 5);
              const effectiveDiameter = diameter * globalDefaultSize.value * scale.value;
              const radius = effectiveDiameter / 2;
              if (circle.fill) {
                ctx.fillStyle = formatColor(circle.fill);
                ctx.beginPath();
                ctx.arc(midCanvas.x, midCanvas.y, radius, 0, 2 * Math.PI);
                ctx.fill();
              }
              ctx.lineWidth = globalVectorSize.value * 2 * globalDefaultSize.value;
              ctx.strokeStyle = circle.linecolor ? formatColor(circle.linecolor) : "rgb(0,0,0)";
              ctx.beginPath();
              ctx.arc(midCanvas.x, midCanvas.y, radius, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.restore();
            }
          });
        };
        const drawGrid = (ctx) => {
          if (gridSize.value <= 0 || worldWidth.value <= 0 || worldHeight.value <= 0) return;
          const offset = useManualOffset.value ? [manualOffsetX.value, manualOffsetY.value] : metaOffset.value;
          const xMin = -worldWidth.value / 2 - offset[0];
          const xMax = worldWidth.value / 2 - offset[0];
          const yMin = -worldHeight.value / 2 - offset[1];
          const yMax = worldHeight.value / 2 - offset[1];
          ctx.strokeStyle = "#ccc";
          ctx.lineWidth = 1;
          ctx.font = "10px Arial";
          ctx.fillStyle = "#000";
          let startX = Math.floor(xMin / gridSize.value) * gridSize.value;
          for (let x = startX; x <= xMax; x += gridSize.value) {
            let start = worldToCanvas(x, yMax);
            let end = worldToCanvas(x, yMin);
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            let labelPos = worldToCanvas(x, yMin);
            ctx.textAlign = "center";
            ctx.fillText(x.toFixed(2), labelPos.x, canvasHeight.value - 2);
          }
          let startY = Math.floor(yMin / gridSize.value) * gridSize.value;
          for (let y = startY; y <= yMax; y += gridSize.value) {
            let start = worldToCanvas(xMin, y);
            let end = worldToCanvas(xMax, y);
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            let labelPos = worldToCanvas(xMin, y);
            ctx.textAlign = "right";
            ctx.fillText(y.toFixed(2), labelPos.x + 20, labelPos.y + 3);
          }
          let originPos = worldToCanvas(0, 0);
          ctx.beginPath();
          ctx.fillStyle = "black";
          ctx.arc(originPos.x, originPos.y, 3, 0, 2 * Math.PI);
          ctx.fill();
        };
        const redraw = () => {
          if (!canvas.value) return;
          const ctx = canvas.value.getContext("2d");
          ctx.fillStyle = "#f5f5f5";
          ctx.fillRect(0, 0, canvasWidth.value, canvasHeight.value);
          drawRectangles(ctx);
          drawCircles(ctx);
          drawGrid(ctx);
          if (showLines.value) drawLines(ctx);
          if (showCoordinateSystems.value) drawCoordinateSystems(ctx);
          if (showVectors.value) drawVectors(ctx);
          if (showPoints.value) drawPoints(ctx);
          if (showAgents.value) drawAgents(ctx);
          drawVisionAgents(ctx);
          drawCornerAxes(ctx);
        };
        watch([worldWidth, worldHeight, gridSize], redraw);
        watch([
          globalPointSize, globalAgentSize, globalVectorSize,
          globalTextSize, globalTrailSize, globalDefaultSize, globalLineThickness
        ], redraw);
        const deleteTrails = () => {
          updateEffectiveVisibilityAndTraverse((group) => {
            for (const key in group.points) {
              if (group.points[key].trailHistory) group.points[key].trailHistory = [];
            }
            for (const key in group.agents) {
              if (group.agents[key].trailHistory) group.agents[key].trailHistory = [];
            }
            for (const key in group.visionagents) {
              if (group.visionagents[key].trailHistory) group.visionagents[key].trailHistory = [];
            }
          });
          redraw();
        };
        function refreshVideo(key) {
          const vid = videos.value[key];
          if (!vid) return;
          vid.refreshKey = (vid.refreshKey || 0) + 1;
        }
        // --- Refresh Teleplot iframe ---
        function refreshTeleplot() {
          const baseUrl = teleplotUrl.value.split('?')[0];
          teleplotUrl.value = baseUrl + '?_t=' + new Date().getTime();
        }
        // --- Enlarging videos ---
        const enlargedVideoKey = ref(null);
        function enlargeVideo(key) {
          enlargedVideoKey.value = key;
        }
        function closeEnlargedVideo() {
          enlargedVideoKey.value = null;
        }
        // WebSocket connection status objects
        const mainWsStatus = reactive({ connected: false, frequency: 0, count: 0 });
        const terminalWsStatus = reactive({ connected: false, frequency: 0, count: 0 });
        // Update frequency counters every second
        setInterval(() => {
          mainWsStatus.frequency = mainWsStatus.count;
          mainWsStatus.count = 0;
          terminalWsStatus.frequency = terminalWsStatus.count;
          terminalWsStatus.count = 0;
        }, 1000);
        onMounted(() => {
          updateCanvasSize();
          if (manualOffsetX.value !== 0 || manualOffsetY.value !== 0) {
            useManualOffset.value = true;
          }
          redraw();
          const resizeObserver = new ResizeObserver(() => {
            updateCanvasSize();
            redraw();
          });
          resizeObserver.observe(mapContainer.value);
          // For teleplot container, update the CSS variable and persist width,
          // but do not force the inline style so that manual resizing is allowed.
          if (teleplotContainer.value) {
            // Set the initial width from stored value
            teleplotContainer.value.style.width = teleplotWidth.value + 'px';
            const teleplotObserver = new ResizeObserver(entries => {
              for (let entry of entries) {
                // Update the stored width based on the current contentRect width
                teleplotWidth.value = entry.contentRect.width;
                localStorage.setItem('teleplotWidth', teleplotWidth.value);
                // Adjust table font size responsively (min 8px, max 12px)
                const newFontSize = Math.max(8, Math.min(12, entry.contentRect.width / 80))*1.5;
                teleplotContainer.value.style.setProperty('--table-font-size', newFontSize + "px");
              }
            });
            teleplotObserver.observe(teleplotContainer.value);
          }
          let isDragging = false;
          let dragStart = { x: 0, y: 0 };
          let startOffset = { x: 0, y: 0 };
          canvas.value.addEventListener("mousedown", (e) => {
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
            startOffset = { x: manualOffsetX.value, y: manualOffsetY.value };
            canvas.value.style.cursor = "grabbing";
          });
          document.addEventListener("mousemove", (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - dragStart.x;
            const deltaY = e.clientY - dragStart.y;
            manualOffsetX.value = startOffset.x + deltaX / scale.value;
            manualOffsetY.value = startOffset.y - deltaY / scale.value;
            useManualOffset.value = true;
            redraw();
          });
          document.addEventListener("mouseup", () => {
            isDragging = false;
            canvas.value.style.cursor = "grab";
          });
          canvas.value.addEventListener("wheel", (e) => {
            e.preventDefault();
            const zoomFactor = 1 - e.deltaY * 0.001;
            initialScale = initialScale * zoomFactor;
            localStorage.setItem('initialScale', initialScale);
            updateCanvasSize();
            redraw();
          });
          canvas.value.addEventListener("click", (e) => {
            if (isDragging) return;
            const rect = canvas.value.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            let candidates = [];
            updateEffectiveVisibilityAndTraverse((group, effVisible) => {
              if (!effVisible) return;
              for (const id in group.points) {
                const pt = group.points[id];
                if (!pt.visible) continue;
                const pos = worldToCanvas(pt.x, pt.y);
                const size = (pt.size !== undefined ? pt.size : 1) * (globalPointSize.value * 5) * globalDefaultSize.value;
                const dx = clickX - pos.x;
                const dy = clickY - pos.y;
                if (Math.hypot(dx, dy) <= size + 5) {
                  candidates.push({
                    type: "point",
                    id: id,
                    group: group.fullPath,
                    distance: Math.hypot(dx, dy)
                  });
                }
              }
              for (const id in group.agents) {
                const ag = group.agents[id];
                if (!ag.visible) continue;
                const pos = worldToCanvas(ag.position[0], ag.position[1]);
                const size = (ag.size !== undefined ? ag.size : 1) * (globalAgentSize.value * 5) * globalDefaultSize.value;
                const dx = clickX - pos.x;
                const dy = clickY - pos.y;
                if (Math.hypot(dx, dy) <= size + 5) {
                  candidates.push({
                    type: "agent",
                    id: id,
                    group: group.fullPath,
                    distance: Math.hypot(dx, dy)
                  });
                }
              }
              for (const id in group.visionagents) {
                const vag = group.visionagents[id];
                if (!vag.visible) continue;
                const pos = worldToCanvas(vag.position[0], vag.position[1]);
                const size = (vag.size !== undefined ? vag.size : 1) * (globalAgentSize.value * 5) * globalDefaultSize.value;
                const dx = clickX - pos.x;
                const dy = clickY - pos.y;
                if (Math.hypot(dx, dy) <= size + 5) {
                  candidates.push({
                    type: "visionagent",
                    id: id,
                    group: group.fullPath,
                    distance: Math.hypot(dx, dy)
                  });
                }
              }
            });
            if (candidates.length > 0) {
              candidates.sort((a, b) => a.distance - b.distance);
              selectedElement.value = {
                type: candidates[0].type,
                id: candidates[0].id,
                group: candidates[0].group
              };
            } else {
              selectedElement.value = null;
            }
            redraw();
          });
          function processGroupData(parentGroup, groupName, incomingData) {
            let groupObj;
            if (!parentGroup) {
              if (!groups[groupName]) {
                groups[groupName] = createEmptyGroupObject();
              }
              groupObj = groups[groupName];
              groupObj.fullPath = groupName;
              groupObj.parent = null;
            } else {
              if (!parentGroup.groups[groupName]) {
                parentGroup.groups[groupName] = createEmptyGroupObject();
              }
              groupObj = parentGroup.groups[groupName];
              groupObj.fullPath = parentGroup.fullPath ? parentGroup.fullPath + "/" + groupName : groupName;
              groupObj.parent = parentGroup;
            }
            const knownTypes = [
              "points", "agents", "vectors", "coordinate_systems",
              "lines", "rectangles", "circles", "visionagents"
            ];
            for (const type of knownTypes) {
              if (incomingData[type]) {
                for (const key in groupObj[type]) {
                  if (!(key in incomingData[type])) {
                    delete groupObj[type][key];
                  }
                }
                for (const key in incomingData[type]) {
                  const newItem = incomingData[type][key];
                  if (!groupObj[type][key]) {
                    groupObj[type][key] = {
                      ...newItem,
                      visible: (newItem.visible === undefined ? true : newItem.visible),
                    };
                    if ((type === "points" || type === "agents" || type === "visionagents")) {
                      groupObj[type][key].showTrail = (newItem.showTrail === undefined ? false : newItem.showTrail);
                      groupObj[type][key].showName = (newItem.showName === undefined ? true : newItem.showName);
                      groupObj[type][key].showCoordinates = (newItem.showCoordinates === undefined ? false : newItem.showCoordinates);
                      groupObj[type][key].trailHistory = [];
                    }
                  } else {
                    const existing = groupObj[type][key];
                    if (type === "points") {
                      if ((existing.x !== newItem.x) || (existing.y !== newItem.y)) {
                        existing.trailHistory.push({ x: existing.x, y: existing.y });
                      }
                    } else if (type === "agents" || type === "visionagents") {
                      if (
                        (existing.position[0] !== newItem.position[0]) ||
                        (existing.position[1] !== newItem.position[1])
                      ) {
                        existing.trailHistory.push({ x: existing.position[0], y: existing.position[1] });
                      }
                    }
                    Object.assign(existing, newItem);
                  }
                }
              }
            }
            if (incomingData.groups) {
              for (const subG in groupObj.groups) {
                if (!(subG in incomingData.groups)) {
                  delete groupObj.groups[subG];
                }
              }
              for (const subName in incomingData.groups) {
                processGroupData(groupObj, subName, incomingData.groups[subName]);
              }
            }
          }
          function createEmptyGroupObject() {
            return {
              visible: true,
              collapsed: false,
              points: {},
              agents: {},
              visionagents: {},
              vectors: {},
              coordinate_systems: {},
              lines: {},
              rectangles: {},
              circles: {},
              groups: {},
              fullPath: "",
              parent: null
            };
          }
          function connectWebSocket() {
            const ws = new WebSocket("ws://localhost:8000");
            ws.onopen = () => {
              console.log("Connected to WebSocket server.");
              mainWsStatus.connected = true;
            };
            ws.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                if (data.command === "close_browser" || data.special === "close_browser") {
                  window.close();
                  return;
                }
                mainWsStatus.count++;
                if (data.meta) {
                  if (data.meta.title) metaTitle.value = data.meta.title;
                  if (data.meta.offset) metaOffset.value = data.meta.offset;
                  if (data.meta.defaultSize) globalDefaultSize.value = data.meta.defaultSize;
                }
                if (data.groups) {
                  for (const groupName in data.groups) {
                    processGroupData(null, groupName, data.groups[groupName]);
                  }
                } else {
                  console.warn("Incoming JSON does not contain 'groups' key; ignoring.");
                }
                if (data.videos) {
                  videos.value = data.videos;
                }
                redraw();
              } catch (e) {
                console.error("Error parsing JSON:", e);
              }
            };
            ws.onerror = (err) => console.error("WebSocket error:", err);
            ws.onclose = () => {
              console.log("WebSocket closed. Reconnecting in 3 seconds...");
              mainWsStatus.connected = false;
              setTimeout(connectWebSocket, 3000);
            };
          }
          connectWebSocket();
          function connectTerminalWebSocket() {
            terminalWs = new WebSocket("ws://localhost:8090");
            terminalWs.onopen = () => {
              addLog("Terminal Websocket connected", "green");
              terminalWsStatus.connected = true;
            };
            terminalWs.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                if (data.command === "close_browser" || data.special === "close_browser") {
                  window.close();
                  return;
                }
                terminalWsStatus.count++;
                if (data.type === 'log' && data.data && data.data.text) {
                  addLog(data.data.text, data.data.color || '#d3d3d3');
                }
                if (data.type === 'commands' && data.data) {
                  commandSets.value = data.data;
                  activeSet.value = data.data.name ? [data.data.name] : [];
                  updateSuggestions();
                }
              } catch (e) {
                console.error("Terminal WebSocket error:", e);
              }
            };
            terminalWs.onerror = (err) => console.error("Terminal WebSocket error:", err);
            terminalWs.onclose = () => {
              terminalWsStatus.connected = false;
              setTimeout(connectTerminalWebSocket, 3000);
            };
          }
          connectTerminalWebSocket();
          // Check if Teleplot server is running by sending a HEAD request
          fetch(teleplotUrl.value, { method: "HEAD" })
            .then(response => {
              teleplotRunning.value = true;
            })
            .catch(err => {
              teleplotRunning.value = true;
            });
        });
        // Reactive refs for Teleplot iframe (with fixed URL)
        const teleplotRunning = ref(false);
        const teleplotUrl = ref("http://127.0.0.1:8080");
        return {
          worldWidth,
          worldHeight,
          gridSize,
          canvas,
          mapContainer,
          canvasWidth,
          canvasHeight,
          showManual,
          groups,
          formatNumber,
          formatColor,
          darkenColor,
          showPoints,
          showVectors,
          showCoordinateSystems,
          showLines,
          showAgents,
          globalPointSize,
          globalAgentSize,
          globalVectorSize,
          globalTextSize,
          globalTrailSize,
          globalDefaultSize,
           globalLineThickness,
          manualOffsetX,
          manualOffsetY,
          manualOffsetXRounded,
          manualOffsetYRounded,
          useManualOffset,
          metaOffset,
          metaTitle,
          logGlobalPointSize,
          logGlobalAgentSize,
          logGlobalVectorSize,
          logGlobalTrailSize,
          selectedElement,
          selectElement,
          deleteTrails,
          addGroupNameToLabel,
          worldWidthFormatted,
          worldHeightFormatted,
          videos,
          hasVideos: computed(() => Object.keys(videos.value).length > 0),
          showSettings,
          terminalLogs,
          terminalInput,
          handleTerminalSubmit,
          updateSuggestions,
          terminalLogContainer,
          commandSets,
          activeSet,
          suggestions,
          currentPath,
          refreshVideo,
          refreshTeleplot,
          handleKeydown,
          mainWsStatus,
          terminalWsStatus,
          enlargedVideoKey,
          enlargeVideo,
          closeEnlargedVideo,
          // Teleplot-related refs and toggle
          teleplotRunning,
          teleplotUrl,
          teleplotContainer,
          teleplotWidth,
          showTeleplotIframe,
          toggleMapSize,
          mapContainerStyle,
          mapEnlarged
        };
      }
    }).mount('#app');
  </script>
</body>
</html>




