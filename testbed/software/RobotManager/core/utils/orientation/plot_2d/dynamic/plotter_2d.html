<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Reactive 2D Elements Plotter with Nested Groups</title>
  <!-- Include Vue 3 from CDN -->
  <script src="https://unpkg.com/vue@3"></script>
  <!-- Import Roboto font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <style>
    /* Global styling for a modern look */
    body {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #fafafa;
      color: #333;
    }
    h2 {
      text-align: center;
      margin: 20px 0;
      color: #444;
    }
    /* Main container layout: map on left, objects list on right */
    #main-container {
      display: flex;
      align-items: stretch;
      padding: 10px;
    }
    /* Resizable map container with panning cursor */
    #mapContainer {
      border: 1px solid #ccc;
      resize: both;
      overflow: auto;
      position: relative;
      min-width: 300px;
      min-height: 300px;
      cursor: grab;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    canvas {
      display: block;
    }
    /* Objects list on right: wider and horizontally resizable */
    #objectsList {
      margin-left: 10px;
      border: 1px solid #ccc;
      width: 700px;
      resize: horizontal;
      overflow: auto;
      font-size: 13px;
      background-color: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      border-radius: 4px;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 10px;
    }
    th, td {
      border: 1px solid #e0e0e0;
      padding: 4px 6px;
      text-align: center;
    }
    /* Highlight the selected table row */
    tr.selected {
      background-color: #def;
    }
    /* Styles for a group panel */
    .group-panel {
      border: 1px solid #ddd;
      margin-bottom: 10px;
      padding: 5px;
      border-radius: 4px;
      background-color: #fdfdfd;
    }
    .group-header {
      background: #f0f0f0;
      padding: 5px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      border-radius: 4px;
      margin-bottom: 4px;
    }
    .group-header input {
      margin-right: 5px;
    }
    .group-header span {
      flex-grow: 1;
    }
    .group-header .arrow {
      display: inline-block;
      width: 0;
      height: 0;
      border-top: 5px solid transparent;
      border-bottom: 5px solid transparent;
      border-left: 5px solid #333;
      margin-right: 5px;
      transition: transform 0.2s;
    }
    .group-header .arrow.expanded {
      transform: rotate(90deg);
    }
    /* New CSS for each table header inside a group */
    .table-header {
      background: #e8e8e8;
      padding: 4px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      border-radius: 4px;
      margin-bottom: 2px;
      font-weight: 500;
    }
    .table-header .arrow {
      display: inline-block;
      width: 0;
      height: 0;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      border-left: 4px solid #333;
      margin-right: 5px;
      transition: transform 0.2s;
    }
    .table-header .arrow.expanded {
      transform: rotate(90deg);
    }
    /* Map offset controls below the map */
    #map-offset-controls {
      margin: 10px;
      padding: 10px;
      border: 1px solid #ddd;
      width: fit-content;
      border-radius: 4px;
      background-color: #fff;
    }
    /* Global controls styling */
    #controls {
      margin: 10px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background-color: #fff;
      max-width: 1000px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    /* Global slider controls */
    #global-controls label {
      display: inline-block;
      margin-right: 15px;
      margin-bottom: 5px;
    }
    /* Delete Trails Button styling */
    #trail-controls {
      margin-top: 10px;
    }
    #trail-controls button {
      padding: 6px 12px;
      border: none;
      background-color: #4285f4;
      color: #fff;
      font-size: 14px;
      border-radius: 4px;
      cursor: pointer;
    }
    #trail-controls button:hover {
      background-color: #357ae8;
    }
    /* Checkbox for group name in label */
    #group-label-control {
      margin-top: 10px;
    }
    /* Manual section styling */
    #manual {
      margin: 20px;
      padding: 15px;
      border: 1px solid #ddd;
      background-color: #f9f9f9;
      border-radius: 4px;
    }
    #manual pre {
      background: #eee;
      padding: 10px;
      overflow-x: auto;
    }
  </style>
</head>
<body>
  <div id="app">
    <!-- Display meta title if provided -->
    <h2 v-if="metaTitle">{{ metaTitle }}</h2>
    <!-- Main container: Map and objects list -->
    <div id="main-container">
      <div id="mapContainer" ref="mapContainer" :style="{ width: canvasWidth + 'px', height: canvasHeight + 'px' }">
        <canvas ref="canvas"></canvas>
      </div>
      <div id="objectsList" :style="{ height: canvasHeight + 'px' }">
        <!-- Recursively display all top-level groups -->
        <group-panel
          v-for="(groupData, groupName) in groups"
          :key="groupData.fullPath || groupName"
          :group-name="groupName"
          :group-data="groupData"
          :format-color="formatColor"
          :format-number="formatNumber"
          :selected-element="selectedElement"
          @select-element="selectElement"
        ></group-panel>
      </div>
    </div>

    <!-- Map Offset Controls -->
    <div id="map-offset-controls">
      <label>
        Offset X:
        <input type="number" v-model.number="manualOffsetXRounded" step="0.01">
      </label>
      <label>
        Offset Y:
        <input type="number" v-model.number="manualOffsetYRounded" step="0.01">
      </label>
      <span v-if="!useManualOffset && (metaOffset[0] !== 0 || metaOffset[1] !== 0)">
        (Meta Offset in use: [{{ metaOffset[0] }}, {{ metaOffset[1] }}])
      </span>
    </div>

    <!-- Global Controls -->
    <div id="controls">
      <label>
        X (meters):
        <input type="number" v-model="worldWidthFormatted" step="0.01">
      </label>
      <label>
        Y (meters):
        <input type="number" v-model="worldHeightFormatted" step="0.01">
      </label>
      <label>
        Grid (meters):
        <input type="number" v-model.number="gridSize" step="0.1">
      </label>
      <div id="global-controls">
        <label>
          Point Size:
          <input type="range" min="0" max="1" step="0.01" v-model.number="logGlobalPointSize">
          <span>{{ globalPointSize.toFixed(2) }}</span>
        </label>
        <label>
          Agent Size:
          <input type="range" min="0" max="1" step="0.01" v-model.number="logGlobalAgentSize">
          <span>{{ globalAgentSize.toFixed(2) }}</span>
        </label>
        <label>
          Vector Size:
          <input type="range" min="0" max="1" step="0.01" v-model.number="logGlobalVectorSize">
          <span>{{ globalVectorSize.toFixed(2) }}</span>
        </label>
        <label>
          Trail Size:
          <input type="range" min="0" max="1" step="0.01" v-model.number="logGlobalTrailSize">
          <span>{{ globalTrailSize.toFixed(2) }}</span>
        </label>
        <label>
          Text Size:
          <input type="range" min="8" max="40" step="1" v-model.number="globalTextSize">
          <span>{{ globalTextSize }}</span>
        </label>
        <label>
          Line Thickness:
          <input type="range" min="0.5" max="10" step="0.1" v-model.number="globalLineThickness">
          <span>{{ globalLineThickness.toFixed(2) }}</span>
        </label>
      </div>
      <div id="trail-controls">
        <button @click="deleteTrails">Delete Trails</button>
      </div>
      <div id="group-label-control">
        <label>
          <input type="checkbox" v-model="addGroupNameToLabel"> Add Groupname to Label
        </label>
      </div>
    </div>

    <div id="manual">
      <pre>
Instructions:
- Use the sliders to adjust the sizes of points, agents, vectors, trails, text, and line thickness.
- The settings are saved automatically and will be restored the next time you open this tool.
- Drag on the map to pan; use the mouse wheel to zoom.
- Click on an element (or its corresponding row in the table) to select it.
- Click on a group name (the entire title bar) to collapse/expand the group.
- Click on a table header (e.g. "Agents") to collapse/expand that section.
- Click the "Delete Trails" button to clear all trails.
- Use "Add Groupname to Label" to show the full group path (e.g. [group1/group1_1]) next to element labels on the map.

Paths for line "start"/"end":
- "X1": look for 'X1' in the same group.
- "/group2/X2": absolute path from root (top-level group 'group2'), then item 'X2'.
- "../X3": go up one level to the parent group, look for 'X3' there.

"visionagents" is like "agents" but draws an additional sector with radius "vision_radius" and angle "vision_fov" (in radians), oriented around the agent's heading.
      </pre>
    </div>
  </div>

  <script>
    const { createApp, ref, reactive, computed, watch, defineComponent, onMounted } = Vue;

    // --- A recursive component for displaying one group (GroupPanel) ---
    const GroupPanel = defineComponent({
      name: "GroupPanel",
      props: {
        groupName: { type: String, required: true },
        groupData: { type: Object, required: true },
        formatColor: { type: Function, required: true },
        formatNumber: { type: Function, required: true },
        selectedElement: { type: Object, default: null }
      },
      emits: ["select-element"],
      data() {
        return {
          // Object to hold the collapse state for each table type
          tableCollapsed: {}
        };
      },
      methods: {
        toggleCollapse() {
          this.groupData.collapsed = !this.groupData.collapsed;
          const collapseKey = "groupCollapse_" + this.fullPath;
          localStorage.setItem(collapseKey, JSON.stringify(this.groupData.collapsed));
        },
        persistGroupVisibility() {
          const visibleKey = "groupVisible_" + this.fullPath;
          localStorage.setItem(visibleKey, JSON.stringify(this.groupData.visible));
        },
        isSelected(type, id) {
          return (
            this.selectedElement &&
            this.selectedElement.type === type &&
            this.selectedElement.id === id &&
            this.selectedElement.group === this.fullPath
          );
        },
        // Toggle a specific table section (agents, points, etc.)
        toggleTable(tableType) {
          this.tableCollapsed[tableType] = !this.tableCollapsed[tableType];
          const key = "tableToggle_" + this.fullPath + "_" + tableType;
          localStorage.setItem(key, JSON.stringify(this.tableCollapsed[tableType]));
        },
        // Persist the state of a checkbox for an element
        persistCheckboxState(type, id, prop, value) {
          const key = "elemState_" + this.fullPath + "_" + type + "_" + id + "_" + prop;
          localStorage.setItem(key, JSON.stringify(value));
        },
        // Forward the select-element event from sub-groups upward
        forwardSelect(...args) {
          this.$emit('select-element', ...args);
        }
      },
      computed: {
        fullPath() {
          return this.groupData.fullPath || this.groupName;
        }
      },
      mounted() {
        // Initialize table collapse state for each table type if data exists
        const tableTypes = ["agents", "visionagents", "points", "vectors", "coordinate_systems", "lines", "rectangles", "circles"];
        tableTypes.forEach(tt => {
          if (this.groupData[tt] && Object.keys(this.groupData[tt]).length > 0) {
            const key = "tableToggle_" + this.fullPath + "_" + tt;
            const stored = localStorage.getItem(key);
            this.tableCollapsed[tt] = stored !== null ? JSON.parse(stored) : false;
          }
        });
        // Restore persisted checkbox states for each element.
        const persistMapping = {
          agents: ['visible','showTrail','dim','showName','showCoordinates'],
          visionagents: ['visible','showTrail','dim','showName','showCoordinates'],
          points: ['visible','showTrail','dim','showName','showCoordinates'],
          vectors: ['visible','dim','showName'],
          coordinate_systems: ['visible','dim','showName'],
          lines: ['visible','dim','showName'],
          rectangles: ['visible','dim'],
          circles: ['visible','dim']
        };
        for (const type in persistMapping) {
          if (this.groupData[type]) {
            for (const id in this.groupData[type]) {
              persistMapping[type].forEach(prop => {
                const key = "elemState_" + this.fullPath + "_" + type + "_" + id + "_" + prop;
                const stored = localStorage.getItem(key);
                if (stored !== null) {
                  this.groupData[type][id][prop] = JSON.parse(stored);
                }
              });
            }
          }
        }
        // Restore group collapsed state
        const collapseKey = "groupCollapse_" + this.fullPath;
        const storedCollapse = localStorage.getItem(collapseKey);
        if (storedCollapse !== null) {
          this.groupData.collapsed = JSON.parse(storedCollapse);
        }
        // Restore group visible state
        const visibleKey = "groupVisible_" + this.fullPath;
        const storedVisible = localStorage.getItem(visibleKey);
        if (storedVisible !== null) {
          this.groupData.visible = JSON.parse(storedVisible);
        }
      },
      template:
        `<div class="group-panel">
          <div class="group-header" @click="toggleCollapse">
            <input type="checkbox" v-model="groupData.visible" @click.stop @change.stop="persistGroupVisibility">
            <div class="arrow" :class="{ expanded: !groupData.collapsed }"></div>
            <span>{{ groupName }}</span>
          </div>
          <div v-show="!groupData.collapsed" class="group-content">
            <!-- Agents -->
            <div v-if="Object.keys(groupData.agents).length > 0">
              <div class="table-header" @click="toggleTable('agents')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.agents }"></div>
                <span>Agents</span>
              </div>
              <div v-show="!tableCollapsed.agents">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>x</th>
                      <th>y</th>
                      <th>Psi</th>
                      <th>Visible</th>
                      <th>Trails</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Show Coordinates</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(agent, id) in groupData.agents" :key="id" :class="{ selected: isSelected('agent', id) }">
                      <td @click.stop="$emit('select-element', 'agent', id, fullPath)">
                        <span :style="{
                          background: agent.color ? formatColor(agent.color) : 'black',
                          display: 'inline-block',
                          width: '10px',
                          height: '10px',
                          borderRadius: '50%',
                          marginRight: '4px'
                        }"></span>
                        {{ id }}
                      </td>
                      <td>{{ formatNumber(agent.position[0]) }}</td>
                      <td>{{ formatNumber(agent.position[1]) }}</td>
                      <td>{{ formatNumber(agent.psi) }}</td>
                      <td><input type="checkbox" v-model="agent.visible" @change.stop="persistCheckboxState('agents', id, 'visible', agent.visible)"></td>
                      <td><input type="checkbox" v-model="agent.showTrail" @change.stop="persistCheckboxState('agents', id, 'showTrail', agent.showTrail)"></td>
                      <td><input type="checkbox" v-model="agent.dim" @change.stop="persistCheckboxState('agents', id, 'dim', agent.dim)"></td>
                      <td><input type="checkbox" v-model="agent.showName" @change.stop="persistCheckboxState('agents', id, 'showName', agent.showName)"></td>
                      <td><input type="checkbox" v-model="agent.showCoordinates" @change.stop="persistCheckboxState('agents', id, 'showCoordinates', agent.showCoordinates)"></td>
                      <td><span>{{ agent.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Vision Agents -->
            <div v-if="Object.keys(groupData.visionagents).length > 0">
              <div class="table-header" @click="toggleTable('visionagents')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.visionagents }"></div>
                <span>Vision Agents</span>
              </div>
              <div v-show="!tableCollapsed.visionagents">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>x</th>
                      <th>y</th>
                      <th>Psi</th>
                      <th>Radius</th>
                      <th>FOV (rad)</th>
                      <th>Visible</th>
                      <th>Trails</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Show Coordinates</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(agent, id) in groupData.visionagents" :key="id" :class="{ selected: isSelected('visionagent', id) }">
                      <td @click.stop="$emit('select-element', 'visionagent', id, fullPath)">
                        <span :style="{
                          background: agent.color ? formatColor(agent.color) : 'black',
                          display: 'inline-block',
                          width: '10px',
                          height: '10px',
                          borderRadius: '50%',
                          marginRight: '4px'
                        }"></span>
                        {{ id }}
                      </td>
                      <td>{{ formatNumber(agent.position[0]) }}</td>
                      <td>{{ formatNumber(agent.position[1]) }}</td>
                      <td>{{ formatNumber(agent.psi) }}</td>
                      <td>{{ formatNumber(agent.vision_radius) }}</td>
                      <td>{{ formatNumber(agent.vision_fov) }}</td>
                      <td><input type="checkbox" v-model="agent.visible" @change.stop="persistCheckboxState('visionagents', id, 'visible', agent.visible)"></td>
                      <td><input type="checkbox" v-model="agent.showTrail" @change.stop="persistCheckboxState('visionagents', id, 'showTrail', agent.showTrail)"></td>
                      <td><input type="checkbox" v-model="agent.dim" @change.stop="persistCheckboxState('visionagents', id, 'dim', agent.dim)"></td>
                      <td><input type="checkbox" v-model="agent.showName" @change.stop="persistCheckboxState('visionagents', id, 'showName', agent.showName)"></td>
                      <td><input type="checkbox" v-model="agent.showCoordinates" @change.stop="persistCheckboxState('visionagents', id, 'showCoordinates', agent.showCoordinates)"></td>
                      <td><span>{{ agent.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Points -->
            <div v-if="Object.keys(groupData.points).length > 0">
              <div class="table-header" @click="toggleTable('points')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.points }"></div>
                <span>Points</span>
              </div>
              <div v-show="!tableCollapsed.points">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>x</th>
                      <th>y</th>
                      <th>Visible</th>
                      <th>Trails</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Show Coordinates</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(pt, id) in groupData.points" :key="id" :class="{ selected: isSelected('point', id) }">
                      <td @click.stop="$emit('select-element', 'point', id, fullPath)">
                        <span :style="{
                          background: pt.color ? formatColor(pt.color) : 'black',
                          display: 'inline-block',
                          width: '10px',
                          height: '10px',
                          borderRadius: '50%',
                          marginRight: '4px'
                        }"></span>
                        {{ id }}
                      </td>
                      <td>{{ formatNumber(pt.x) }}</td>
                      <td>{{ formatNumber(pt.y) }}</td>
                      <td><input type="checkbox" v-model="pt.visible" @change.stop="persistCheckboxState('points', id, 'visible', pt.visible)"></td>
                      <td><input type="checkbox" v-model="pt.showTrail" @change.stop="persistCheckboxState('points', id, 'showTrail', pt.showTrail)"></td>
                      <td><input type="checkbox" v-model="pt.dim" @change.stop="persistCheckboxState('points', id, 'dim', pt.dim)"></td>
                      <td><input type="checkbox" v-model="pt.showName" @change.stop="persistCheckboxState('points', id, 'showName', pt.showName)"></td>
                      <td><input type="checkbox" v-model="pt.showCoordinates" @change.stop="persistCheckboxState('points', id, 'showCoordinates', pt.showCoordinates)"></td>
                      <td><span>{{ pt.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Vectors -->
            <div v-if="Object.keys(groupData.vectors).length > 0">
              <div class="table-header" @click="toggleTable('vectors')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.vectors }"></div>
                <span>Vectors</span>
              </div>
              <div v-show="!tableCollapsed.vectors">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Origin</th>
                      <th>Vec</th>
                      <th>Visible</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(vec, id) in groupData.vectors" :key="id" :class="{ selected: isSelected('vector', id) }">
                      <td @click.stop="$emit('select-element', 'vector', id, fullPath)">{{ id }}</td>
                      <td>[{{ formatNumber(vec.origin[0]) }}, {{ formatNumber(vec.origin[1]) }}]</td>
                      <td>[{{ formatNumber(vec.vec[0]) }}, {{ formatNumber(vec.vec[1]) }}]</td>
                      <td><input type="checkbox" v-model="vec.visible" @change.stop="persistCheckboxState('vectors', id, 'visible', vec.visible)"></td>
                      <td><input type="checkbox" v-model="vec.dim" @change.stop="persistCheckboxState('vectors', id, 'dim', vec.dim)"></td>
                      <td><input type="checkbox" v-model="vec.showName" @change.stop="persistCheckboxState('vectors', id, 'showName', vec.showName)"></td>
                      <td><span>{{ vec.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Coordinate Systems -->
            <div v-if="Object.keys(groupData.coordinate_systems).length > 0">
              <div class="table-header" @click="toggleTable('coordinate_systems')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.coordinate_systems }"></div>
                <span>Coordinate Systems</span>
              </div>
              <div v-show="!tableCollapsed.coordinate_systems">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Origin</th>
                      <th>ex</th>
                      <th>ey</th>
                      <th>Visible</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(cs, id) in groupData.coordinate_systems" :key="id" :class="{ selected: isSelected('coordinate_system', id) }">
                      <td @click.stop="$emit('select-element', 'coordinate_system', id, fullPath)">{{ id }}</td>
                      <td>[{{ formatNumber(cs.origin[0]) }}, {{ formatNumber(cs.origin[1]) }}]</td>
                      <td>[{{ formatNumber(cs.ex[0]) }}, {{ formatNumber(cs.ex[1]) }}]</td>
                      <td>[{{ formatNumber(cs.ey[0]) }}, {{ formatNumber(cs.ey[1]) }}]</td>
                      <td><input type="checkbox" v-model="cs.visible" @change.stop="persistCheckboxState('coordinate_systems', id, 'visible', cs.visible)"></td>
                      <td><input type="checkbox" v-model="cs.dim" @change.stop="persistCheckboxState('coordinate_systems', id, 'dim', cs.dim)"></td>
                      <td><input type="checkbox" v-model="cs.showName" @change.stop="persistCheckboxState('coordinate_systems', id, 'showName', cs.showName)"></td>
                      <td><span>{{ cs.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Lines -->
            <div v-if="Object.keys(groupData.lines).length > 0">
              <div class="table-header" @click="toggleTable('lines')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.lines }"></div>
                <span>Lines</span>
              </div>
              <div v-show="!tableCollapsed.lines">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Start</th>
                      <th>End</th>
                      <th>Visible</th>
                      <th>Dim</th>
                      <th>Show Name</th>
                      <th>Note</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(line, id) in groupData.lines" :key="id" :class="{ selected: isSelected('line', id) }">
                      <td @click.stop="$emit('select-element', 'line', id, fullPath)">{{ id }}</td>
                      <td>{{ line.start }}</td>
                      <td>{{ line.end }}</td>
                      <td><input type="checkbox" v-model="line.visible" @change.stop="persistCheckboxState('lines', id, 'visible', line.visible)"></td>
                      <td><input type="checkbox" v-model="line.dim" @change.stop="persistCheckboxState('lines', id, 'dim', line.dim)"></td>
                      <td><input type="checkbox" v-model="line.showName" @change.stop="persistCheckboxState('lines', id, 'showName', line.showName)"></td>
                      <td><span>{{ line.text }}</span></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Rectangles -->
            <div v-if="Object.keys(groupData.rectangles).length > 0">
              <div class="table-header" @click="toggleTable('rectangles')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.rectangles }"></div>
                <span>Rectangles</span>
              </div>
              <div v-show="!tableCollapsed.rectangles">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Mid</th>
                      <th>x</th>
                      <th>Visible</th>
                      <th>Dim</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(rect, id) in groupData.rectangles" :key="id" :class="{ selected: isSelected('rectangle', id) }">
                      <td @click.stop="$emit('select-element', 'rectangle', id, fullPath)">{{ id }}</td>
                      <td>[{{ formatNumber(rect.mid[0]) }}, {{ formatNumber(rect.mid[1]) }}]</td>
                      <td>{{ rect.x }}</td>
                      <td><input type="checkbox" v-model="rect.visible" @change.stop="persistCheckboxState('rectangles', id, 'visible', rect.visible)"></td>
                      <td><input type="checkbox" v-model="rect.dim" @change.stop="persistCheckboxState('rectangles', id, 'dim', rect.dim)"></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Circles -->
            <div v-if="Object.keys(groupData.circles).length > 0">
              <div class="table-header" @click="toggleTable('circles')">
                <div class="arrow" :class="{ expanded: !tableCollapsed.circles }"></div>
                <span>Circles</span>
              </div>
              <div v-show="!tableCollapsed.circles">
                <table>
                  <thead>
                    <tr>
                      <th>ID</th>
                      <th>Mid</th>
                      <th>Diameter</th>
                      <th>Visible</th>
                      <th>Dim</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="(circle, id) in groupData.circles" :key="id" :class="{ selected: isSelected('circle', id) }">
                      <td @click.stop="$emit('select-element', 'circle', id, fullPath)">{{ id }}</td>
                      <td>[{{ formatNumber(circle.mid[0]) }}, {{ formatNumber(circle.mid[1]) }}]</td>
                      <td>{{ circle.diameter }}</td>
                      <td><input type="checkbox" v-model="circle.visible" @change.stop="persistCheckboxState('circles', id, 'visible', circle.visible)"></td>
                      <td><input type="checkbox" v-model="circle.dim" @change.stop="persistCheckboxState('circles', id, 'dim', circle.dim)"></td>
                    </tr>
                  </tbody>
                </table>
              </div>
            </div>
            <!-- Sub-groups -->
            <div v-if="groupData.groups && Object.keys(groupData.groups).length > 0">
              <group-panel
                v-for="(subGroupData, subGroupName) in groupData.groups"
                :key="subGroupData.fullPath || subGroupName"
                :group-name="subGroupName"
                :group-data="subGroupData"
                :format-color="formatColor"
                :format-number="formatNumber"
                :selected-element="selectedElement"
                @select-element="forwardSelect"
              ></group-panel>
            </div>
          </div>
        </div>`
    });

    // --- Main Vue app ---
    createApp({
      components: { GroupPanel },
      setup() {
        function formatNumber(num) {
          return (num >= 0 ? " " : "") + Number(num).toFixed(2);
        }
        function formatColor(colorArray) {
          const r = Math.round(colorArray[0] * 255);
          const g = Math.round(colorArray[1] * 255);
          const b = Math.round(colorArray[2] * 255);
          return `rgb(${r},${g},${b})`;
        }
        function darkenColor(colorArray, factor = 0.7) {
          const r = Math.round(Math.max(0, colorArray[0] * 255 * factor));
          const g = Math.round(Math.max(0, colorArray[1] * 255 * factor));
          const b = Math.round(Math.max(0, colorArray[2] * 255 * factor));
          return `rgb(${r},${g},${b})`;
        }
        const effectiveAlpha = (elem) => {
          let a = elem.alpha !== undefined ? elem.alpha : 1;
          if (elem.dim) a *= 0.5;
          return a;
        };
        function drawArrow(ctx, from, to, color, lineWidth) {
          const headLength = lineWidth * 5;
          const dx = to.x - from.x;
          const dy = to.y - from.y;
          const angle = Math.atan2(dy, dx);
          const arrowTip = {
            x: to.x - (headLength * 0.6) * Math.cos(angle),
            y: to.y - (headLength * 0.6) * Math.sin(angle)
          };
          ctx.beginPath();
          ctx.moveTo(from.x, from.y);
          ctx.lineTo(arrowTip.x, arrowTip.y);
          ctx.strokeStyle = color;
          ctx.lineWidth = lineWidth;
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(to.x, to.y);
          ctx.lineTo(
            to.x - headLength * Math.cos(angle - Math.PI / 6),
            to.y - headLength * Math.sin(angle - Math.PI / 6)
          );
          ctx.lineTo(
            to.x - headLength * Math.cos(angle + Math.PI / 6),
            to.y - headLength * Math.sin(angle + Math.PI / 6)
          );
          ctx.closePath();
          ctx.fillStyle = color;
          ctx.fill();
        }
        // Helper function to draw a shape (circle, square or triangle)
        // The function now accepts an optional rotation parameter (in radians)
        // For "square", an additional offset of π/4 is added so that at psi=0 a corner points right.
        // For "triangle", the starting angle is 0 (so its first vertex is along the positive x-axis).
        function drawShapeAt(ctx, pos, size, shape, fillColor, strokeColor, lineWidth, rotation = 0) {
          if (!shape || shape === 'circle') {
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, size, 0, 2 * Math.PI);
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
          } else if (shape === 'square') {
            ctx.save();
            ctx.translate(pos.x, pos.y);
            // Add π/4 offset so that when rotation is 0 a corner points to positive x-axis.
            // ctx.rotate(rotation + Math.PI / 4);
            ctx.rotate(-rotation + Math.PI / 4);
            ctx.beginPath();
            ctx.rect(-size, -size, 2 * size, 2 * size);

            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
            ctx.restore();
          } else if (shape === 'triangle') {
            ctx.save();
            ctx.translate(pos.x, pos.y);
            // Use rotation directly; at rotation=0, the first vertex is at (size,0)
            ctx.rotate(-rotation);
            const vertices = [];
            for (let i = 0; i < 3; i++) {
              const a = i * 2 * Math.PI / 3;
              vertices.push({ x: size * Math.cos(a), y: size * Math.sin(a) });
            }
            ctx.beginPath();
            ctx.moveTo(vertices[0].x, vertices[0].y);
            ctx.lineTo(vertices[1].x, vertices[1].y);
            ctx.lineTo(vertices[2].x, vertices[2].y);
            ctx.closePath();
            ctx.fillStyle = fillColor;
            ctx.fill();
            ctx.lineWidth = lineWidth;
            ctx.strokeStyle = strokeColor;
            ctx.stroke();
            ctx.restore();
          }
        }
        const worldWidth = ref(10);
        const worldHeight = ref(10);
        // --- gridSize is now stored and recalled from localStorage ---
        const gridSize = ref(0.5);
        if (localStorage.getItem('gridSize')) {
          gridSize.value = parseFloat(localStorage.getItem('gridSize'));
        }
        watch(gridSize, (newVal) => localStorage.setItem('gridSize', newVal));
        const globalPointSize = ref(1);
        const globalAgentSize = ref(1);
        const globalVectorSize = ref(1);
        const globalTrailSize = ref(1);
        const globalTextSize = ref(12);
        const globalDefaultSize = ref(1);
        if (localStorage.getItem('globalPointSize')) {
          globalPointSize.value = parseFloat(localStorage.getItem('globalPointSize'));
        }
        if (localStorage.getItem('globalAgentSize')) {
          globalAgentSize.value = parseFloat(localStorage.getItem('globalAgentSize'));
        }
        if (localStorage.getItem('globalVectorSize')) {
          globalVectorSize.value = parseFloat(localStorage.getItem('globalVectorSize'));
        }
        if (localStorage.getItem('globalTrailSize')) {
          globalTrailSize.value = parseFloat(localStorage.getItem('globalTrailSize'));
        }
        if (localStorage.getItem('globalTextSize')) {
          globalTextSize.value = parseFloat(localStorage.getItem('globalTextSize'));
        }
        const globalLineThickness = ref(2);
        if (localStorage.getItem('globalLineThickness')) {
          globalLineThickness.value = parseFloat(localStorage.getItem('globalLineThickness'));
        }
        watch(globalPointSize, (nv) => localStorage.setItem('globalPointSize', nv));
        watch(globalAgentSize, (nv) => localStorage.setItem('globalAgentSize', nv));
        watch(globalVectorSize, (nv) => localStorage.setItem('globalVectorSize', nv));
        watch(globalTrailSize, (nv) => localStorage.setItem('globalTrailSize', nv));
        watch(globalTextSize, (nv) => localStorage.setItem('globalTextSize', nv));
        watch(globalLineThickness, (nv) => localStorage.setItem('globalLineThickness', nv));
        const logGlobalPointSize = computed({
          get() { return Math.log(globalPointSize.value / 0.1) / Math.log(100); },
          set(val) { globalPointSize.value = 0.1 * Math.pow(100, val); }
        });
        const logGlobalAgentSize = computed({
          get() { return Math.log(globalAgentSize.value / 0.1) / Math.log(100); },
          set(val) { globalAgentSize.value = 0.1 * Math.pow(100, val); }
        });
        const logGlobalVectorSize = computed({
          get() { return Math.log(globalVectorSize.value / 0.1) / Math.log(100); },
          set(val) { globalVectorSize.value = 0.1 * Math.pow(100, val); }
        });
        const logGlobalTrailSize = computed({
          get() { return Math.log(globalTrailSize.value / 0.1) / Math.log(100); },
          set(val) { globalTrailSize.value = 0.1 * Math.pow(100, val); }
        });
        const worldWidthFormatted = computed({
          get() { return worldWidth.value.toFixed(2); },
          set(val) { worldWidth.value = parseFloat(val); }
        });
        const worldHeightFormatted = computed({
          get() { return worldHeight.value.toFixed(2); },
          set(val) { worldHeight.value = parseFloat(val); }
        });
        // --- canvasWidth and canvasHeight are now initialized from localStorage if available ---
        const canvasHeight = ref(localStorage.getItem('canvasHeight') ? parseInt(localStorage.getItem('canvasHeight')) : 600);
        const canvasWidth = ref(localStorage.getItem('canvasWidth') ? parseInt(localStorage.getItem('canvasWidth')) : 600);
        const scale = ref(60);
        // --- initialScale is now loaded from localStorage if available ---
        let initialScale = localStorage.getItem('initialScale') ? parseFloat(localStorage.getItem('initialScale')) : null;
        const canvas = ref(null);
        const mapContainer = ref(null);
        const groups = reactive({});
        const showPoints = ref(true);
        const showVectors = ref(true);
        const showCoordinateSystems = ref(true);
        const showLines = ref(true);
        const showAgents = ref(true);
        const showManual = ref(false);
        // --- manualOffsetX and manualOffsetY are now stored in localStorage ---
        const manualOffsetX = ref(0);
        if (localStorage.getItem('manualOffsetX')) {
          manualOffsetX.value = parseFloat(localStorage.getItem('manualOffsetX'));
        }
        const manualOffsetY = ref(0);
        if (localStorage.getItem('manualOffsetY')) {
          manualOffsetY.value = parseFloat(localStorage.getItem('manualOffsetY'));
        }
        watch(manualOffsetX, (newVal) => localStorage.setItem('manualOffsetX', newVal));
        watch(manualOffsetY, (newVal) => localStorage.setItem('manualOffsetY', newVal));
        const useManualOffset = ref(false);
        const metaOffset = ref([0, 0]);
        const metaTitle = ref("");
        const manualOffsetXRounded = computed({
          get() { return Number(manualOffsetX.value.toFixed(2)); },
          set(val) { manualOffsetX.value = Number(val); }
        });
        const manualOffsetYRounded = computed({
          get() { return Number(manualOffsetY.value.toFixed(2)); },
          set(val) { manualOffsetY.value = Number(val); }
        });
        const selectedElement = ref(null);
        const selectElement = (type, id, groupPath) => {
          selectedElement.value = { type, id, group: groupPath };
          redraw();
        };
        const addGroupNameToLabel = ref(false);
        function worldToCanvas(x, y) {
          if (worldWidth.value <= 0 || worldHeight.value <= 0) return { x: 0, y: 0 };
          const offset = useManualOffset.value ? [manualOffsetX.value, manualOffsetY.value] : metaOffset.value;
          const canvasX = ((x + offset[0]) + worldWidth.value / 2) * scale.value;
          const canvasY = (worldHeight.value / 2 - (y + offset[1])) * scale.value;
          return { x: canvasX, y: canvasY };
        }
        function updateCanvasSize() {
          if (!mapContainer.value) return;
          // Get the current size of the map container
          canvasWidth.value = mapContainer.value.clientWidth;
          canvasHeight.value = mapContainer.value.clientHeight;
          // Save the current size so it can be restored on reload
          localStorage.setItem('canvasWidth', canvasWidth.value);
          localStorage.setItem('canvasHeight', canvasHeight.value);
          if (!initialScale) {
            initialScale = canvasHeight.value / worldHeight.value;
          }
          worldWidth.value = canvasWidth.value / initialScale;
          worldHeight.value = canvasHeight.value / initialScale;
          scale.value = initialScale;
          canvas.value.width = canvasWidth.value;
          canvas.value.height = canvasHeight.value;
        }
        function findInGroup(objName, grp) {
          if (!grp) return null;
          if (grp.points && grp.points[objName] && grp.points[objName].visible !== false) {
            const pt = grp.points[objName];
            return { x: pt.x, y: pt.y };
          }
          if (grp.agents && grp.agents[objName] && grp.agents[objName].visible !== false) {
            const ag = grp.agents[objName];
            return { x: ag.position[0], y: ag.position[1] };
          }
          if (grp.visionagents && grp.visionagents[objName] && grp.visionagents[objName].visible !== false) {
            const vag = grp.visionagents[objName];
            return { x: vag.position[0], y: vag.position[1] };
          }
          if (grp.coordinate_systems && grp.coordinate_systems[objName] && grp.coordinate_systems[objName].visible !== false) {
            const cs = grp.coordinate_systems[objName];
            return { x: cs.origin[0], y: cs.origin[1] };
          }
          return null;
        }
        function findGroupByPath(grp, pathSegments) {
          if (!pathSegments.length) return grp;
          const next = pathSegments[0];
          if (!grp.groups || !grp.groups[next]) {
            return null;
          }
          return findGroupByPath(grp.groups[next], pathSegments.slice(1));
        }
        function findInAbsolutePath(pathString) {
          const parts = pathString.split('/');
          if (!parts.length) return null;
          const firstGroup = parts[0];
          const rest = parts.slice(1);
          if (!groups[firstGroup]) return null;
          let currentGroupObj = groups[firstGroup];
          while (rest.length > 1) {
            const subName = rest[0];
            if (!currentGroupObj.groups || !currentGroupObj.groups[subName]) {
              return null;
            }
            currentGroupObj = currentGroupObj.groups[subName];
            rest.shift();
          }
          const objName = rest[0];
          return findInGroup(objName, currentGroupObj);
        }
        function findInParentPath(pathString, currentGroup) {
          if (!currentGroup.parent) return null;
          return findInGroup(pathString, currentGroup.parent);
        }
        function resolvePosition(ref, currentGroup) {
          if (Array.isArray(ref)) {
            return { x: ref[0], y: ref[1] };
          }
          if (typeof ref !== 'string') return null;
          if (ref.startsWith('/')) {
            const pathString = ref.substring(1);
            return findInAbsolutePath(pathString);
          }
          if (ref.startsWith('../')) {
            const localName = ref.substring(3);
            return findInParentPath(localName, currentGroup);
          }
          return findInGroup(ref, currentGroup);
        }
        function drawCornerAxes(ctx) {
          const margin = 40;
          const canvasH = ctx.canvas.height;
          const start = { x: margin, y: canvasH - margin };
          const arrowLength = 80;
          const headLength = 8;
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(start.x + arrowLength, start.y);
          ctx.strokeStyle = "red";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(start.x + arrowLength, start.y);
          ctx.lineTo(start.x + arrowLength - headLength, start.y - headLength / 2);
          ctx.lineTo(start.x + arrowLength - headLength, start.y + headLength / 2);
          ctx.closePath();
          ctx.fillStyle = "red";
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(start.x, start.y);
          ctx.lineTo(start.x, start.y - arrowLength);
          ctx.strokeStyle = "green";
          ctx.lineWidth = 2;
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(start.x, start.y - arrowLength);
          ctx.lineTo(start.x - headLength / 2, start.y - arrowLength + headLength);
          ctx.lineTo(start.x + headLength / 2, start.y - arrowLength + headLength);
          ctx.closePath();
          ctx.fillStyle = "green";
          ctx.fill();
        }
        function traverseGroupsWithVisibility(groupObj, parentVisible, callback) {
          const thisEffective = parentVisible && groupObj.visible !== false;
          groupObj.effectiveVisibility = thisEffective;
          callback(groupObj, thisEffective);
          if (groupObj.groups) {
            for (const gName in groupObj.groups) {
              traverseGroupsWithVisibility(groupObj.groups[gName], thisEffective, callback);
            }
          }
        }
        function updateEffectiveVisibilityAndTraverse(callback) {
          for (const rootName in groups) {
            traverseGroupsWithVisibility(groups[rootName], true, callback);
          }
        }
        const drawPoints = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showPoints.value) return;
            for (const label in group.points) {
              const pt = group.points[label];
              if (pt.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(pt);
              const pos = worldToCanvas(pt.x, pt.y);
              const size = (pt.size !== undefined ? pt.size : 1) * (globalPointSize.value * 5) * globalDefaultSize.value;
              const shape = pt.shape ? pt.shape.toLowerCase() : "circle";
              let colorStr = pt.color ? formatColor(pt.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "point" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              if (pt.showTrail && pt.trailHistory && pt.trailHistory.length > 0) {
                ctx.save();
                ctx.strokeStyle = colorStr;
                ctx.lineWidth = globalTrailSize.value * globalDefaultSize.value;
                let prev = null;
                pt.trailHistory.forEach(trailPos => {
                  const canvasPos = worldToCanvas(trailPos.x, trailPos.y);
                  ctx.beginPath();
                  ctx.arc(canvasPos.x, canvasPos.y, globalTrailSize.value * globalDefaultSize.value, 0, 2 * Math.PI);
                  ctx.fillStyle = colorStr;
                  ctx.fill();
                  if (prev) {
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(canvasPos.x, canvasPos.y);
                    ctx.stroke();
                  }
                  prev = canvasPos;
                });
                ctx.restore();
              }
              const lineWidth = Math.max(1, globalPointSize.value * 0.2 * globalDefaultSize.value);
              drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", lineWidth);
              const labelPieces = [];
              if (pt.showName) {
                if (addGroupNameToLabel.value) {
                  labelPieces.push(`[${group.fullPath}] ${label}`);
                } else {
                  labelPieces.push(label);
                }
              }
              if (pt.showCoordinates) {
                labelPieces.push(`[${formatNumber(pt.x)}, ${formatNumber(pt.y)}]`);
              }
              const labelText = labelPieces.join(" ");
              if (labelText) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = pt.color ? darkenColor(pt.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(labelText, pos.x, pos.y - (size + globalTextSize.value * 0.5));
              }
              if (pt.text) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = pt.color ? darkenColor(pt.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(pt.text, pos.x, pos.y + (size + globalTextSize.value));
              }
              if (isSel) {
                ctx.save();
                ctx.strokeStyle = "red";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size + 3, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
              }
              ctx.restore();
            }
          });
        };
        const drawAgents = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showAgents.value) return;
            for (const label in group.agents) {
              const agent = group.agents[label];
              if (agent.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(agent);
              const pos = worldToCanvas(agent.position[0], agent.position[1]);
              const size = (agent.size !== undefined ? agent.size : 1) * (globalAgentSize.value * 5) * globalDefaultSize.value;
              let colorStr = agent.color ? formatColor(agent.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "agent" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              if (agent.trailHistory && agent.showTrail && agent.trailHistory.length > 0) {
                ctx.save();
                ctx.strokeStyle = colorStr;
                ctx.lineWidth = globalTrailSize.value * globalDefaultSize.value;
                let prev = null;
                agent.trailHistory.forEach(trailPos => {
                  const canvasPos = worldToCanvas(trailPos.x, trailPos.y);
                  ctx.beginPath();
                  ctx.arc(canvasPos.x, canvasPos.y, globalTrailSize.value * globalDefaultSize.value, 0, 2 * Math.PI);
                  ctx.fillStyle = colorStr;
                  ctx.fill();
                  if (prev) {
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(canvasPos.x, canvasPos.y);
                    ctx.stroke();
                  }
                  prev = canvasPos;
                });
                ctx.restore();
              }
              // Compute arrow length using the computed size (which already includes agent.size)
              const arrowLengthWorld = (size * 4) / scale.value;
              const arrowEndWorld = [
                agent.position[0] + Math.cos(agent.psi) * arrowLengthWorld,
                agent.position[1] + Math.sin(agent.psi) * arrowLengthWorld
              ];
              const arrowEnd = worldToCanvas(arrowEndWorld[0], arrowEndWorld[1]);
              // Arrow thickness now uses agent.size (size/5 equals (agent.size * globalAgentSize*globalDefaultSize))
              const arrowThickness = Math.max(1, size / 5);
              drawArrow(ctx, pos, arrowEnd, colorStr, arrowThickness);
              const shape = agent.shape ? agent.shape.toLowerCase() : "circle";
              // For square and triangle, pass the agent's psi to rotate the shape.
              if (shape === "square" || shape === "triangle") {
                drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", arrowThickness, agent.psi);
              } else {
                drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", arrowThickness);
              }
              const labelPieces = [];
              if (agent.showName) {
                if (addGroupNameToLabel.value) {
                  labelPieces.push(`[${group.fullPath}] ${label}`);
                } else {
                  labelPieces.push(label);
                }
              }
              if (agent.showCoordinates) {
                labelPieces.push(`[${formatNumber(agent.position[0])}, ${formatNumber(agent.position[1])}]`);
              }
              const labelText = labelPieces.join(" ");
              if (labelText) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = agent.color ? darkenColor(agent.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(labelText, pos.x, pos.y - (size * 2 + globalTextSize.value * 0.125));
              }
              if (agent.text) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = agent.color ? darkenColor(agent.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(agent.text, pos.x, pos.y + (size + globalTextSize.value));
              }
              if (isSel) {
                ctx.save();
                ctx.strokeStyle = "red";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 1.5, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
              }
              ctx.restore();
            }
          });
        };
        const drawVisionAgents = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showAgents.value) return;
            for (const label in group.visionagents) {
              const vag = group.visionagents[label];
              if (vag.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(vag);
              const pos = worldToCanvas(vag.position[0], vag.position[1]);
              const size = (vag.size !== undefined ? vag.size : 1) * (globalAgentSize.value * 5) * globalDefaultSize.value;
              let colorStr = vag.color ? formatColor(vag.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "visionagent" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              if (vag.trailHistory && vag.showTrail && vag.trailHistory.length > 0) {
                ctx.save();
                ctx.strokeStyle = colorStr;
                ctx.lineWidth = globalTrailSize.value * globalDefaultSize.value;
                let prev = null;
                vag.trailHistory.forEach(trailPos => {
                  const canvasPos = worldToCanvas(trailPos.x, trailPos.y);
                  ctx.beginPath();
                  ctx.arc(canvasPos.x, canvasPos.y, globalTrailSize.value * globalDefaultSize.value, 0, 2 * Math.PI);
                  ctx.fillStyle = colorStr;
                  ctx.fill();
                  if (prev) {
                    ctx.beginPath();
                    ctx.moveTo(prev.x, prev.y);
                    ctx.lineTo(canvasPos.x, canvasPos.y);
                    ctx.stroke();
                  }
                  prev = canvasPos;
                });
                ctx.restore();
              }
              const arrowLengthWorld = (size * 4) / scale.value;
              const arrowEndWorld = [
                vag.position[0] + Math.cos(vag.psi) * arrowLengthWorld,
                vag.position[1] + Math.sin(vag.psi) * arrowLengthWorld
              ];
              const arrowEnd = worldToCanvas(arrowEndWorld[0], arrowEndWorld[1]);
              const arrowThickness = Math.max(1, size / 5);
              drawArrow(ctx, pos, arrowEnd, colorStr, arrowThickness);
              const shape = vag.shape ? vag.shape.toLowerCase() : "circle";
              if (shape === "square" || shape === "triangle") {
                drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", arrowThickness, vag.psi);
              } else {
                drawShapeAt(ctx, pos, size, shape, colorStr, "rgb(0,0,0)", arrowThickness);
              }
              if (vag.vision_radius && vag.vision_radius > 0 && vag.vision_fov) {
                ctx.save();
                ctx.globalAlpha *= 0.25;
                const radiusPx = vag.vision_radius * scale.value;
                const arcStart = vag.psi - vag.vision_fov / 2;
                const arcEnd = vag.psi + vag.vision_fov / 2;
                ctx.beginPath();
                ctx.moveTo(pos.x, pos.y);
                ctx.arc(pos.x, pos.y, radiusPx, -arcStart, -arcEnd, true);
                ctx.closePath();
                ctx.fillStyle = colorStr;
                ctx.fill();
                ctx.strokeStyle = colorStr;
                ctx.lineWidth = 1.5;
                ctx.stroke();
                ctx.restore();
              }
              const labelPieces = [];
              if (vag.showName) {
                if (addGroupNameToLabel.value) {
                  labelPieces.push(`[${group.fullPath}] ${label}`);
                } else {
                  labelPieces.push(label);
                }
              }
              if (vag.showCoordinates) {
                labelPieces.push(`[${formatNumber(vag.position[0])}, ${formatNumber(vag.position[1])}]`);
              }
              const labelText = labelPieces.join(" ");
              if (labelText) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = vag.color ? darkenColor(vag.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(labelText, pos.x, pos.y - (size * 2 + globalTextSize.value * 0.125));
              }
              if (vag.text) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = vag.color ? darkenColor(vag.color) : 'rgb(0,0,0)';
                ctx.textAlign = "center";
                ctx.fillText(vag.text, pos.x, pos.y + (size + globalTextSize.value));
              }
              if (isSel) {
                ctx.save();
                ctx.strokeStyle = "red";
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, size * 1.5, 0, 2 * Math.PI);
                ctx.stroke();
                ctx.restore();
              }
              ctx.restore();
            }
          });
        };
        const drawVectors = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showVectors.value) return;
            for (const label in group.vectors) {
              const vecData = group.vectors[label];
              if (vecData.visible === false) continue;
              if (!vecData.vec || !vecData.origin) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(vecData);
              const start = worldToCanvas(vecData.origin[0], vecData.origin[1]);
              const end = worldToCanvas(
                vecData.origin[0] + vecData.vec[0],
                vecData.origin[1] + vecData.vec[1]
              );
              const thickness = (vecData.thickness !== undefined ? vecData.thickness : (globalVectorSize.value * 2)) * globalDefaultSize.value;
              let colorStr = vecData.color ? formatColor(vecData.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "vector" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              drawArrow(ctx, start, end, colorStr, thickness);
              if (vecData.showName === undefined || vecData.showName) {
                const midX = (start.x + end.x) / 2;
                const midY = (start.y + end.y) / 2;
                const angle = Math.atan2(end.y - start.y, end.x - start.x);
                ctx.save();
                ctx.translate(midX, midY);
                ctx.rotate(angle);
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = colorStr;
                ctx.textAlign = "center";
                ctx.fillText(label, 0, -thickness - globalTextSize.value * 0.3);
                if (vecData.text) {
                  ctx.fillText(vecData.text, 0, thickness + globalTextSize.value + 2);
                }
                ctx.restore();
              }
              ctx.restore();
            }
          });
        };
        const drawCoordinateSystems = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showCoordinateSystems.value) return;
            for (const label in group.coordinate_systems) {
              const cs = group.coordinate_systems[label];
              if (cs.visible === false) continue;
              if (!cs.origin || !cs.ex || !cs.ey) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(cs);
              const thickness = (cs.thickness !== undefined ? cs.thickness : (globalVectorSize.value * 2)) * globalDefaultSize.value;
              const origin = worldToCanvas(cs.origin[0], cs.origin[1]);
              const exEnd = worldToCanvas(
                cs.origin[0] + cs.ex[0],
                cs.origin[1] + cs.ex[1]
              );
              const eyEnd = worldToCanvas(
                cs.origin[0] + cs.ey[0],
                cs.origin[1] + cs.ey[1]
              );
              const exColor = (cs.colors && cs.colors.ex) ? formatColor(cs.colors.ex) : "rgb(255,0,0)";
              const eyColor = (cs.colors && cs.colors.ey) ? formatColor(cs.colors.ey) : "rgb(0,255,0)";
              let textColor = "black";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "coordinate_system" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                textColor = "red";
              }
              ctx.beginPath();
              ctx.arc(origin.x, origin.y, 3, 0, 2 * Math.PI);
              ctx.fillStyle = "black";
              ctx.fill();
              drawArrow(ctx, origin, exEnd, exColor, thickness);
              drawArrow(ctx, origin, eyEnd, eyColor, thickness);
              if (cs.showName === undefined || cs.showName) {
                ctx.font = globalTextSize.value + "px Arial";
                ctx.fillStyle = textColor;
                ctx.textAlign = "center";
                ctx.fillText(label, origin.x, origin.y + thickness + globalTextSize.value);
                if (cs.text) {
                  ctx.fillText(cs.text, origin.x, origin.y + thickness + 2 * globalTextSize.value);
                }
              }
              ctx.restore();
            }
          });
        };
        const drawLines = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible || !showLines.value) return;
            for (const label in group.lines) {
              const line = group.lines[label];
              if (line.visible === false) continue;
              if (!line.start || !line.end) continue;
              const startCoord = resolvePosition(line.start, group);
              const endCoord = resolvePosition(line.end, group);
              if (!startCoord || !endCoord) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(line);
              const start = worldToCanvas(startCoord.x, startCoord.y);
              const end = worldToCanvas(endCoord.x, endCoord.y);
              const thickness = (line.thickness !== undefined ? line.thickness : globalLineThickness.value) * globalDefaultSize.value;
              let colorStr = line.color ? formatColor(line.color) : "rgb(0,0,0)";
              const isSel = (selectedElement.value &&
                selectedElement.value.type === "line" &&
                selectedElement.value.id === label &&
                selectedElement.value.group === group.fullPath);
              if (isSel) {
                colorStr = "red";
              }
              ctx.setLineDash([5, 5]);
              ctx.lineWidth = thickness;
              ctx.strokeStyle = colorStr;
              ctx.beginPath();
              ctx.moveTo(start.x, start.y);
              ctx.lineTo(end.x, end.y);
              ctx.stroke();
              ctx.setLineDash([]);
              ctx.save();
              const midX = (start.x + end.x) / 2;
              const midY = (start.y + end.y) / 2;
              const angle = Math.atan2(end.y - start.y, end.x - start.x);
              ctx.translate(midX, midY);
              ctx.rotate(angle);
              ctx.font = globalTextSize.value + "px Arial";
              ctx.fillStyle = colorStr;
              ctx.textAlign = "center";
              if (line.showName) {
                ctx.fillText(label, 0, -thickness - globalTextSize.value * 0.3);
              }
              if (line.text) {
                ctx.fillText(line.text, 0, thickness + globalTextSize.value + 2);
              }
              ctx.restore();
              ctx.restore();
            }
          });
        };
        const drawRectangles = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible) return;
            for (const label in group.rectangles) {
              const rect = group.rectangles[label];
              if (rect.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(rect);
              const mid = rect.mid;
              const widthWorld = rect.x;
              const heightWorld = rect.y || rect.x;
              const leftWorld = mid[0] - widthWorld / 2;
              const topWorld = mid[1] + heightWorld / 2;
              const topLeft = worldToCanvas(leftWorld, topWorld);
              const bottomRight = worldToCanvas(
                mid[0] + widthWorld / 2,
                mid[1] - heightWorld / 2
              );
              const rectX = topLeft.x;
              const rectY = topLeft.y;
              const rectWidth = Math.abs(bottomRight.x - topLeft.x);
              const rectHeight = Math.abs(bottomRight.y - topLeft.y);
              if (rect.fill) {
                ctx.fillStyle = formatColor(rect.fill);
                ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
              }
              ctx.lineWidth = globalVectorSize.value * 2 * globalDefaultSize.value;
              ctx.strokeStyle = rect.linecolor ? formatColor(rect.linecolor) : "rgb(0,0,0)";
              ctx.strokeRect(rectX, rectY, rectWidth, rectHeight);
              ctx.restore();
            }
          });
        };
        const drawCircles = (ctx) => {
          updateEffectiveVisibilityAndTraverse((group, effVisible) => {
            if (!effVisible) return;
            for (const label in group.circles) {
              const circle = group.circles[label];
              if (circle.visible === false) continue;
              ctx.save();
              ctx.globalAlpha = effectiveAlpha(circle);
              const midCanvas = worldToCanvas(circle.mid[0], circle.mid[1]);
              const diameter = circle.diameter !== undefined ? circle.diameter : (globalPointSize.value * 5);
              const effectiveDiameter = diameter * globalDefaultSize.value * scale.value;
              const radius = effectiveDiameter / 2;
              if (circle.fill) {
                ctx.fillStyle = formatColor(circle.fill);
                ctx.beginPath();
                ctx.arc(midCanvas.x, midCanvas.y, radius, 0, 2 * Math.PI);
                ctx.fill();
              }
              ctx.lineWidth = globalVectorSize.value * 2 * globalDefaultSize.value;
              ctx.strokeStyle = circle.linecolor ? formatColor(circle.linecolor) : "rgb(0,0,0)";
              ctx.beginPath();
              ctx.arc(midCanvas.x, midCanvas.y, radius, 0, 2 * Math.PI);
              ctx.stroke();
              ctx.restore();
            }
          });
        };
        const drawGrid = (ctx) => {
          if (gridSize.value <= 0 || worldWidth.value <= 0 || worldHeight.value <= 0) return;
          const offset = useManualOffset.value ? [manualOffsetX.value, manualOffsetY.value] : metaOffset.value;
          const xMin = -worldWidth.value / 2 - offset[0];
          const xMax = worldWidth.value / 2 - offset[0];
          const yMin = -worldHeight.value / 2 - offset[1];
          const yMax = worldHeight.value / 2 - offset[1];
          ctx.strokeStyle = "#ccc";
          ctx.lineWidth = 1;
          ctx.font = "10px Arial";
          ctx.fillStyle = "#000";
          let startX = Math.floor(xMin / gridSize.value) * gridSize.value;
          for (let x = startX; x <= xMax; x += gridSize.value) {
            let start = worldToCanvas(x, yMax);
            let end = worldToCanvas(x, yMin);
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            let labelPos = worldToCanvas(x, yMin);
            ctx.textAlign = "center";
            ctx.fillText(x.toFixed(2), labelPos.x, canvasHeight.value - 2);
          }
          let startY = Math.floor(yMin / gridSize.value) * gridSize.value;
          for (let y = startY; y <= yMax; y += gridSize.value) {
            let start = worldToCanvas(xMin, y);
            let end = worldToCanvas(xMax, y);
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
            let labelPos = worldToCanvas(xMin, y);
            ctx.textAlign = "right";
            ctx.fillText(y.toFixed(2), labelPos.x + 20, labelPos.y + 3);
          }
          let originPos = worldToCanvas(0, 0);
          ctx.beginPath();
          ctx.fillStyle = "black";
          ctx.arc(originPos.x, originPos.y, 3, 0, 2 * Math.PI);
          ctx.fill();
        };
        const redraw = () => {
          if (!canvas.value) return;
          const ctx = canvas.value.getContext("2d");
          ctx.fillStyle = "#f5f5f5";
          ctx.fillRect(0, 0, canvasWidth.value, canvasHeight.value);
          drawRectangles(ctx);
          drawCircles(ctx);
          drawGrid(ctx);
          if (showLines.value) drawLines(ctx);
          if (showCoordinateSystems.value) drawCoordinateSystems(ctx);
          if (showVectors.value) drawVectors(ctx);
          if (showPoints.value) drawPoints(ctx);
          if (showAgents.value) drawAgents(ctx);
          drawVisionAgents(ctx);
          drawCornerAxes(ctx);
        };
        watch([worldWidth, worldHeight, gridSize], redraw);
        watch([
          globalPointSize, globalAgentSize, globalVectorSize,
          globalTextSize, globalTrailSize, globalDefaultSize, globalLineThickness
        ], redraw);
        const deleteTrails = () => {
          updateEffectiveVisibilityAndTraverse((group) => {
            for (const key in group.points) {
              if (group.points[key].trailHistory) group.points[key].trailHistory = [];
            }
            for (const key in group.agents) {
              if (group.agents[key].trailHistory) group.agents[key].trailHistory = [];
            }
            for (const key in group.visionagents) {
              if (group.visionagents[key].trailHistory) group.visionagents[key].trailHistory = [];
            }
          });
          redraw();
        };
        onMounted(() => {
          updateCanvasSize();
          // If a manual offset was loaded, immediately use it.
          if (manualOffsetX.value !== 0 || manualOffsetY.value !== 0) {
            useManualOffset.value = true;
          }
          redraw();
          const resizeObserver = new ResizeObserver(() => {
            updateCanvasSize();
            redraw();
          });
          resizeObserver.observe(mapContainer.value);
          let isDragging = false;
          let dragStart = { x: 0, y: 0 };
          let startOffset = { x: 0, y: 0 };
          canvas.value.addEventListener("mousedown", (e) => {
            isDragging = true;
            dragStart = { x: e.clientX, y: e.clientY };
            startOffset = { x: manualOffsetX.value, y: manualOffsetY.value };
            canvas.value.style.cursor = "grabbing";
          });
          document.addEventListener("mousemove", (e) => {
            if (!isDragging) return;
            const deltaX = e.clientX - dragStart.x;
            const deltaY = e.clientY - dragStart.y;
            manualOffsetX.value = startOffset.x + deltaX / scale.value;
            manualOffsetY.value = startOffset.y - deltaY / scale.value;
            useManualOffset.value = true;
            redraw();
          });
          document.addEventListener("mouseup", () => {
            isDragging = false;
            canvas.value.style.cursor = "grab";
          });
          canvas.value.addEventListener("wheel", (e) => {
            e.preventDefault();
            const zoomFactor = 1 - e.deltaY * 0.001;
            initialScale = initialScale * zoomFactor;
            // --- Save the updated scale to localStorage ---
            localStorage.setItem('initialScale', initialScale);
            updateCanvasSize();
            redraw();
          });
          canvas.value.addEventListener("click", (e) => {
            if (isDragging) return;
            const rect = canvas.value.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            let candidates = [];
            updateEffectiveVisibilityAndTraverse((group, effVisible) => {
              if (!effVisible) return;
              for (const id in group.points) {
                const pt = group.points[id];
                if (!pt.visible) continue;
                const pos = worldToCanvas(pt.x, pt.y);
                const size = (pt.size !== undefined ? pt.size : 1) * (globalPointSize.value * 5) * globalDefaultSize.value;
                const dx = clickX - pos.x;
                const dy = clickY - pos.y;
                if (Math.hypot(dx, dy) <= size + 5) {
                  candidates.push({
                    type: "point",
                    id,
                    group: group.fullPath,
                    distance: Math.hypot(dx, dy)
                  });
                }
              }
              for (const id in group.agents) {
                const ag = group.agents[id];
                if (!ag.visible) continue;
                const pos = worldToCanvas(ag.position[0], ag.position[1]);
                const size = (ag.size !== undefined ? ag.size : 1) * (globalAgentSize.value * 5) * globalDefaultSize.value;
                const dx = clickX - pos.x;
                const dy = clickY - pos.y;
                if (Math.hypot(dx, dy) <= size + 5) {
                  candidates.push({
                    type: "agent",
                    id,
                    group: group.fullPath,
                    distance: Math.hypot(dx, dy)
                  });
                }
              }
              for (const id in group.visionagents) {
                const vag = group.visionagents[id];
                if (!vag.visible) continue;
                const pos = worldToCanvas(vag.position[0], vag.position[1]);
                const size = (vag.size !== undefined ? vag.size : 1) * (globalAgentSize.value * 5) * globalDefaultSize.value;
                const dx = clickX - pos.x;
                const dy = clickY - pos.y;
                if (Math.hypot(dx, dy) <= size + 5) {
                  candidates.push({
                    type: "visionagent",
                    id,
                    group: group.fullPath,
                    distance: Math.hypot(dx, dy)
                  });
                }
              }
            });
            if (candidates.length > 0) {
              candidates.sort((a, b) => a.distance - b.distance);
              selectedElement.value = {
                type: candidates[0].type,
                id: candidates[0].id,
                group: candidates[0].group
              };
            } else {
              selectedElement.value = null;
            }
            redraw();
          });
          function processGroupData(parentGroup, groupName, incomingData) {
            let groupObj;
            if (!parentGroup) {
              if (!groups[groupName]) {
                groups[groupName] = createEmptyGroupObject();
              }
              groupObj = groups[groupName];
              groupObj.fullPath = groupName;
              groupObj.parent = null;
            } else {
              if (!parentGroup.groups[groupName]) {
                parentGroup.groups[groupName] = createEmptyGroupObject();
              }
              groupObj = parentGroup.groups[groupName];
              groupObj.fullPath = parentGroup.fullPath ? parentGroup.fullPath + "/" + groupName : groupName;
              groupObj.parent = parentGroup;
            }
            const knownTypes = [
              "points", "agents", "vectors", "coordinate_systems",
              "lines", "rectangles", "circles", "visionagents"
            ];
            for (const type of knownTypes) {
              if (incomingData[type]) {
                for (const key in groupObj[type]) {
                  if (!(key in incomingData[type])) {
                    delete groupObj[type][key];
                  }
                }
                for (const key in incomingData[type]) {
                  const newItem = incomingData[type][key];
                  if (!groupObj[type][key]) {
                    groupObj[type][key] = {
                      ...newItem,
                      visible: (newItem.visible === undefined ? true : newItem.visible),
                    };
                    if ((type === "points" || type === "agents" || type === "visionagents")) {
                      groupObj[type][key].showTrail = (newItem.showTrail === undefined ? false : newItem.showTrail);
                      groupObj[type][key].showName = (newItem.showName === undefined ? true : newItem.showName);
                      groupObj[type][key].showCoordinates = (newItem.showCoordinates === undefined ? false : newItem.showCoordinates);
                      groupObj[type][key].trailHistory = [];
                    }
                  } else {
                    const existing = groupObj[type][key];
                    if (type === "points") {
                      if ((existing.x !== newItem.x) || (existing.y !== newItem.y)) {
                        existing.trailHistory.push({ x: existing.x, y: existing.y });
                      }
                    } else if (type === "agents" || type === "visionagents") {
                      if (
                        (existing.position[0] !== newItem.position[0]) ||
                        (existing.position[1] !== newItem.position[1])
                      ) {
                        existing.trailHistory.push({ x: existing.position[0], y: existing.position[1] });
                      }
                    }
                    Object.assign(existing, newItem);
                  }
                }
              }
            }
            if (incomingData.groups) {
              for (const subG in groupObj.groups) {
                if (!(subG in incomingData.groups)) {
                  delete groupObj.groups[subG];
                }
              }
              for (const subName in incomingData.groups) {
                processGroupData(groupObj, subName, incomingData.groups[subName]);
              }
            }
          }
          function createEmptyGroupObject() {
            return {
              visible: true,
              collapsed: false,
              points: {},
              agents: {},
              visionagents: {},
              vectors: {},
              coordinate_systems: {},
              lines: {},
              rectangles: {},
              circles: {},
              groups: {},
              fullPath: "",
              parent: null
            };
          }
          function connectWebSocket() {
            const ws = new WebSocket("ws://localhost:8000");
            ws.onopen = () => console.log("Connected to WebSocket server.");
            ws.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                if (data.meta) {
                  if (data.meta.title) metaTitle.value = data.meta.title;
                  if (data.meta.offset) metaOffset.value = data.meta.offset;
                  if (data.meta.defaultSize) globalDefaultSize.value = data.meta.defaultSize;
                }
                if (data.groups) {
                  for (const groupName in data.groups) {
                    processGroupData(null, groupName, data.groups[groupName]);
                  }
                } else {
                  console.warn("Incoming JSON does not contain 'groups' key; ignoring.");
                }
                redraw();
              } catch (e) {
                console.error("Error parsing JSON:", e);
              }
            };
            ws.onerror = (err) => console.error("WebSocket error:", err);
            ws.onclose = () => {
              console.log("WebSocket closed. Reconnecting in 3 seconds...");
              setTimeout(connectWebSocket, 3000);
            };
          }
          connectWebSocket();
        });
        return {
          worldWidth,
          worldHeight,
          gridSize,
          canvas,
          mapContainer,
          canvasWidth,
          canvasHeight,
          showManual,
          groups,
          formatNumber,
          formatColor,
          darkenColor,
          showPoints,
          showVectors,
          showCoordinateSystems,
          showLines,
          showAgents,
          globalPointSize,
          globalAgentSize,
          globalVectorSize,
          globalTextSize,
          globalTrailSize,
          globalDefaultSize,
          globalLineThickness,
          manualOffsetX,
          manualOffsetY,
          manualOffsetXRounded,
          manualOffsetYRounded,
          useManualOffset,
          metaOffset,
          metaTitle,
          logGlobalPointSize,
          logGlobalAgentSize,
          logGlobalVectorSize,
          logGlobalTrailSize,
          selectedElement,
          selectElement,
          deleteTrails,
          addGroupNameToLabel,
          worldWidthFormatted,
          worldHeightFormatted
        };
      }
    }).mount('#app');
  </script>
</body>
</html>
