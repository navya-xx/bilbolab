<!DOCTYPE html>
<html>
<head>
   <meta charset="UTF-8">
  <!-- The viewport tag disables pinch zooming when combined with user-scalable=no -->
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
  <title>Dynamic Button App – Dark Mode with Folders</title>

  <!-- PWA manifest -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#000000">

  <!-- iOS-specific PWA meta -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="LandscapeApp">
  <link rel="apple-touch-icon" href="/icon-192.png">

    <style>
    /* CSS variable for app height to fix landscape issues on iOS */
    :root {
      --app-height: 100vh;
    }
    /* Splash Screen Styles */
    #splashScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #121212;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      opacity: 1;
      transition: opacity 0.5s ease;
    }
    #splashScreen img {
      max-width: 80%;
      max-height: 80%;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #121212;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      height: var(--app-height);
      overflow: hidden; /* Disable page scrolling */
      position: fixed;
      min-width: 100%;
    }
    /* Top Bar: Fixed to 10% of total height (with a minimum height) */
    #topBar {
      background-color: #1f1f1f;
      padding: 2px;
      padding-left: 50px; /* Added to make room for the logo */
      text-align: center;
      font-weight: bold;
      position: relative;
      flex-shrink: 0;
      height: 8%;
    }
    /* Logo in top bar – made larger and spanning across topBar and statusBar */
    #logo {
      position: absolute;
      left: 40px;
      top: 0;
      height: 27px;
    }
    /* Path Bar: Fixed to 5% of total height (with a minimum height) */
    #pathBar {
      background-color: #2a2a2a;
      padding: 2px;
      text-align: center;
      font-size: 12px;
      flex-shrink: 0;
      height: 4%;
    }
    /* Status Bar: Fixed to 10% of total height (with a minimum height) */
    #statusBar {
      background-color: #333333;
      padding: 2px;
      text-align: center;
      flex-shrink: 0;
      height: 5%;
    }
    /* Grid wrapper now uses flex layout for better alignment and responsiveness */
    #gridWrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      margin: 0 20px;
      padding: 2px 20px;
      gap: 10px;
    }
    /* Updated grid container: fixed 6 columns and 2 rows per page */
    #buttonGrid {
      flex: 1;
      display: grid;
      grid-template-columns: repeat(6, 1fr);
      grid-auto-rows: 1fr;
      gap: 5px;
      width: 100%;
      min-width: 100%;
    }
    .buttonItem {
      position: relative;
      border: none;
      border-radius: 5px;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      aspect-ratio: 1;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .folderButton {
      border: 2px dashed #888;
    }
    .folderLabel {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 12px;
      color: #ccc;
    }
    .placeholder {
      border: 1px dashed #555;
      background-color: #121212;
    }
    /* Lock icon for lockable widgets */
    .widgetLock {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 14px;
      pointer-events: none;
      z-index: 2;
    }
    /* New widget lock state styles */
    .locked {
       filter: brightness(0.4); /* Widget appears less colorful */
    }
    .locked .widgetLock {
       opacity: 1;
    }
    .unlocked .widgetLock {
       opacity: 0.5;
    }
    /* Log window: Fixed to 15% of total height (with a minimum height) */
    #logWindow {
      flex: 0 0 15%;
      height: 15%;
      overflow-y: auto;
      border-top: 1px solid #444;
      padding: 5px;
      padding-bottom: env(safe-area-inset-bottom);
      background-color: #1a1a1a;
      font-size: 14px;
      transition: height 0.2s ease, top 0.2s ease;
    }
    #logWindow p {
      margin: 2px 0;
    }
    /* Rotate warning */
    #rotateWarning {
      display: none;
      position: fixed;
      z-index: 999;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      color: white;
      font-size: 24px;
      text-align: center;
      padding-top: 40vh;
    }
    /* When in portrait, show the rotate warning and hide the main UI */
    @media screen and (orientation: portrait) {
      #rotateWarning {
        display: block;
      }
      #topBar,
      #pathBar,
      #statusBar,
      #gridWrapper,
      #logWindow {
        display: none;
      }
    }
    /* Fix for landscape mode: remove extra padding-bottom in logWindow */
    @media screen and (orientation: landscape) {
      #logWindow {
        padding-bottom: 0;
      }
    }
    /* Root shortcut button in the upper right */
    #rootButton {
      position: absolute;
      top: 10px;
      bottom: 10px;
      right: 10px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #555;
      cursor: pointer;
    }
    /* Activity indicator in the top left */
    #activityIndicator {
      position: absolute;
      top: 5px;
      left: 10px;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: red;
    }
    /* Multi-Select Widget Styles */
    .multiSelectWidget {
      position: relative;
      border: 1px solid #444;
      border-radius: 5px;
      width: 100%;
      height: 99%;
      aspect-ratio: 1;
      min-width: 48px;
      background-color: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
      font-size: 16px;
    }
    .multiSelectWidget select {
      width: 100%;
      height: 100%;
      font-size: 16px;
      background: transparent;
      color: #fff;
      border: none;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      text-align: center;
      text-align-last: center;
      padding: 0;
      margin: 0;
      line-height: 1;
      -webkit-text-size-adjust: 100%;
    }
    .msSelectDropdown {
      position: absolute;
      right: 5px;
      bottom: 2px;
      font-size: 12px;
      color: #ccc;
    }
    .msSelectTitle {
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #ccc;
      z-index: 1;
    }
    /* Multi-State Button Widget Styles */
    .multiStateButtonMain {
      width: 100%;
      height: 100%;
      aspect-ratio: 1;
      border: none;
      border-radius: 5px;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .msbTitle {
      position: absolute;
      top: 5px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 12px;
      font-weight: bold;
    }
    .msbState {
      display: block;
      text-align: center;
      font-size: 16px;
      margin-bottom: 2px;
    }
    .msbIndicators {
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 2px;
    }
    .msbIndicator {
      width: 8px;
      height: 8px;
      border: 1px solid #ccc;
      border-radius: 50%;
    }
    .msbIndicator.active {
      background-color: #ccc;
    }
    /* Slider Widget Styles */
    .sliderWidget {
      position: relative;
      border: none;
      border-radius: 5px;
      background-color: #444;
      color: inherit;
      font-size: 16px;
      cursor: pointer;
      overflow: hidden;
    }
    .sliderWidget .sliderTitle {
      position: relative;
      z-index: 3;
      display: block;
      text-align: center;
      font-size: 12px;
      font-weight: bold;
      margin-top: 2px;
    }
    .sliderWidget .sliderValue {
      position: relative;
      z-index: 3;
      display: block;
      text-align: center;
      font-size: 17px;
      margin-bottom: 2px;
    }
    .sliderWidget .sliderBar {
      position: absolute;
      top: 0px;
      left: 0;
      height: 100%;
      width: 100%;
      opacity: 0.3;
      background-color: currentColor;
      z-index: 1;
    }
    .sliderWidget .sliderFill {
      position: absolute;
      height: 100%;
      width: 50%;
      background-color: currentColor;
      opacity: 0.5;
      z-index: 2;
      top: 0;
    }
    /* Text Widget Styles */
    .textWidget {
      position: relative;
      border: none;
      border-radius: 5px;
      background-color: inherit;
      color: inherit;
      font-size: 16px;
      overflow: hidden;
      padding: 5px;
      text-align: center;
    }
    .textWidget .textTitle {
      position: absolute;
      top: 5px;
      left: 0;
      right: 0;
      font-size: 12px;
      font-weight: bold;
      text-align: center;
    }
    .textWidget .textContent {
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      transform: translateY(-50%);
      font-size: 14px;
      margin: 0;
    }
    /* Digital Number Widget Styles */
    .digitalNumberWidget {
      position: relative;
      border: none;
      border-radius: 5px;
      padding: 5px;
      background-color: inherit;
      color: inherit;
      font-family: inherit;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .digitalNumberWidget .digitalNumberTitle {
      position: absolute;
      top: 5px;
      left: 0;
      right: 0;
      text-align: center;
      display: block;
      font-size: 12px;
      font-weight: bold;
    }
    .digitalNumberWidget .digitalNumberValue {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      line-height: 1;
      text-align: center;
      font-family: monospace;
      font-variant-numeric: tabular-nums;
      min-width: 8ch;
    }
    /* SplitButton Widget Styles */
    .splitButtonContainer {
      border: none;
      border-radius: 5px;
      overflow: hidden;
      padding: 2px;
      display: grid;
    }
    .splitButtonPart {
      border: none;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Pressed (active) state for interactive elements:
       - For normal widgets, only apply to those that are not split button containers.
       - For split button parts, always apply. */
    .buttonItem:not(.splitButtonContainer):active,
    .splitButtonPart:active {
      filter: brightness(0.8);
      transition: filter 0.1s ease;
    }
    /* Page Indicators Styles */
    #pageIndicators {
      position: absolute;
      right: 5px;           /* Moved closer to the right edge */
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 1000;        /* Higher z-index to ensure visibility */
      pointer-events: auto;
    }
    .pageIndicator {
      width: 8px;
      height: 8px;
      border: 1px solid #ccc;
      border-radius: 50%;
      cursor: pointer;
    }
    .pageIndicator.active {
      background-color: #ccc;
    }
    /* Joystick Widget Styles */
    .joystickWidget {
      position: relative;
      width: 100%;
      height: 100%;
      background-color: #333;
      border-radius: 10px;
      touch-action: none;
    }
    .joystickBase {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 80%;
      background-color: #555;
      border-radius: 50%;
    }
    .joystickKnob {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40%;
      height: 40%;
      background-color: #aaa;
      border-radius: 50%;
      touch-action: none;
    }
    .joystickTitle {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      font-size: 12px;
      font-weight: bold;
      color: inherit;
    }
    /* Popup overlay and content styles */
    #popupOverlay {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2500;
      background-color: rgba(0,0,0,0.5);
    }
    #popupContent {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #1f1f1f;
      border: 1px solid #555;
      border-radius: 5px;
      padding: 20px;
      text-align: center;
      min-width: 300px;
    }
    #popupText {
      margin-bottom: 20px;
      white-space: pre-line;
    }
    #popupButtons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    /* Make popup buttons uniform in size, overriding the .buttonItem defaults */
    #popupButtons button {
      flex: 1 1 0;
      aspect-ratio: auto;
      /* Optional: set a min-width if needed */
      min-width: 80px;
      min-height: 50px;
      max-width: 100px;

    }
    /* Media query for larger screens (PC) */
    @media (min-width: 768px) {
      body {
        font-size: 18px;
      }
      .buttonItem {
        font-size: 18px;
      }
      #topBar {
        padding: 4px;
      }
      #pathBar, #statusBar {
        font-size: 14px;
      }
      #logWindow {
        font-size: 16px;
      }
    }
    /* =================== New Styles for GraphWidget =================== */
    .graphWidget {
      position: relative; display: flex;
      flex-direction: column; padding: 5px; box-sizing: border-box;
    }
    .graphWidget canvas {
      flex: 1; border: 1px solid #888;
    }
    .graphWidget .graphTitle {
      font-size: 14px; text-align: center; margin-bottom: 2px;
    }
    .graphWidget .graphCurrentValue {
      font-size: 12px; text-align: center; margin-top: 2px;
    }


  .popupImage {
      max-width: 90vw;
      max-height: 40vh;
      /*max-height: 40px;*/
      width: auto;
      height: auto;
    }

    /* Adjust for larger screens (desktop) */
@media (min-width: 768px) {
  .popupImage {
    /*max-width: 120vw;*/
    max-height: 200vh;
    min-height: 300px;
    width: auto;
    height: auto;
    /*min-height: 400px;*/
  }
}
  </style>


</head>
<body>

  <!-- Splash Screen -->
  <div id="splashScreen">
    <img src="bilbo_logo.png" alt="Logo">
  </div>

  <!-- Removed login/connection page so the app shows immediately in landscape mode -->
  <div id="rotateWarning">Please rotate your device to landscape mode.</div>

  <div id="topBar">
    <img id="logo" src="bilbo_logo.png" alt="Logo">
    <div id="topBarText"></div>
    <div id="activityIndicator"></div>
  </div>
  <div id="statusBar">Status: Connecting...</div>

  <!-- Grid wrapper -->
  <div id="gridWrapper">
    <div id="buttonGrid"></div>
    <div id="pageIndicators"></div>
  </div>
  <div id="pathBar"></div>

  <div id="logWindow"></div>

  <!-- Popup overlay (hidden by default) -->
  <div id="popupOverlay">
    <div id="popupContent">
      <div id="popupText"></div>
      <div id="popupButtons"></div>
    </div>
  </div>

  <script>
    // Global graph data cache to persist GraphWidget data by widget ID
    var graphDataStore = {};

    // Global variables for swipe detection
    let isSwiping = false;
    let touchStartY = 0;
    const swipeThreshold = 50;

    // Disable pinch zoom (for iOS Safari)
    document.addEventListener('gesturestart', function(e) { e.preventDefault(); });

    // Fix for iOS landscape height
    function setAppHeight() { document.documentElement.style.setProperty('--app-height', window.innerHeight + 'px'); }
    window.addEventListener('resize', setAppHeight); setAppHeight();

    // Automatically use current hostname for WebSocket connection
    var wsHost = window.location.hostname; let ws;

    window.addEventListener('load', function() {
      setTimeout(function() {
        var splash = document.getElementById('splashScreen');
        if (splash) { splash.style.opacity = '0'; setTimeout(function(){ splash.style.display = 'none'; }, 500); }
      }, 2000);
      connectWebSocket();
    });

    function connectWebSocket() {
      let port = window.location.port || "80";
      ws = new WebSocket("ws://" + wsHost + ":" + port + "/ws");
      ws.onopen = function() { updateTop("Connected"); updateStatus("Connected"); setActivityIndicator(true); };
      ws.onmessage = function(event) {
        const data = JSON.parse(event.data);
        if (data.type === "switch_set") {
          createButtons(data.grid_items, data.show_back);
          updatePathBar(data.path);
          if (data.pages !== undefined && data.current_page !== undefined) { updatePageIndicators(data.current_page, data.pages); }
        }
        else if (data.type === "update_button") { updateButton(data.id, data.text, data.color, data.textcolor); }
        else if (data.type === "update_multi_state") { updateMultiStateButton(data.id, data.current_state, data.states, data.text, data.state, data.color, data.textcolor); }
        else if (data.type === "update_multi_select") { updateMultiSelectButton(data.id, data.value); }
        else if (data.type === "update_slider") { updateSlider(data.id, data.value); }
        else if (data.type === "update_text") { updateText(data.id, data.text); }
        else if (data.type === "update_digitalnumber") { updateDigitalNumber(data.id, data.value); }
        else if (data.type === "update_joystick") { updateJoystick(data.id, data.x, data.y); }
        else if (data.type === "status") { updateStatus(data.status); }
        else if (data.type === "log") { addLog(data.message); }
        else if (data.type === "path_lookup") { console.log("Path lookup result:", data.result); }
        // Long press events
        else if (data.type === "slider_long_click") { console.log("Slider long press detected: " + data.id); }
        else if (data.type === "joystick_long_click") { console.log("Joystick long press detected: " + data.id); }
        else if (data.type === "multi_select_long_click") { console.log("Multi-select long press detected: " + data.id); }
        // Popup handling (including image popups)
        else if (data.type === "popup") { showPopup(data); }
        else if (data.type === "hide_popup") { hidePopup(); }
        // --- Updated push_value handler for GraphWidget ---
        else if (data.type === "push_value") {
          // Ensure a global data store exists for this widget.
          if (!graphDataStore[data.id]) { graphDataStore[data.id] = []; }
          // Use provided timestamp if available; if not, check for a 'time' field and convert from seconds to ms.
          let ts;
          if ("timestamp" in data) {
              ts = data.timestamp;
          } else if ("time" in data) {
              ts = data.time * 1000;
          } else {
              ts = Date.now();
          }
          graphDataStore[data.id].push({ timestamp: ts, value: data.value });
          // Try to update the widget if it is visible.
          let graphElem = document.getElementById(data.id);
          if (graphElem && graphElem.classList.contains("graphWidget")) {
            // Ensure the widget uses the global store.
            graphElem.graphData = graphDataStore[data.id];
            // Remove old points beyond the window duration.
            let windowTimeMs = parseFloat(graphElem.dataset.windowTime) * 1000;
            let now = Date.now();
            graphDataStore[data.id] = graphDataStore[data.id].filter(pt => (now - pt.timestamp) <= windowTimeMs);
            // Redraw the graph.
            drawGraph(graphElem);
            // Update current value display.
            let currentValueDiv = graphElem.querySelector(".graphCurrentValue");
            if (currentValueDiv) { currentValueDiv.textContent = "Current: " + data.value.toFixed(2); }
          }
        }
      };
      ws.onclose = function() { updateStatus("Disconnected"); updateTop("Disconnected"); setActivityIndicator(false); setTimeout(connectWebSocket, 2000); };
      ws.onerror = function(err) { console.error("WebSocket error:", err); };
    }

    function updateTop(text) { document.getElementById("topBar").childNodes[2].textContent = text; }
    function updatePathBar(path) { document.getElementById("pathBar").textContent = "Path: " + path; }
    function updateStatus(status) { document.getElementById("statusBar").textContent = status; }
    function setActivityIndicator(active) { document.getElementById("activityIndicator").style.backgroundColor = active ? "green" : "red"; }

    function createButtons(grid_items, showBack) {
      const grid = document.getElementById("buttonGrid"); grid.innerHTML = "";
      grid_items.forEach(function(item) {
        let element;
        if (item.widget_type === "placeholder") {
          element = document.createElement("div"); element.className = "buttonItem placeholder";
        }
        // --- GraphWidget branch ---
        else if (item.widget_type === "graph") {
          element = document.createElement("div");
          element.className = "buttonItem graphWidget";
          element.id = item.id;
          element.innerHTML = '<div class="graphTitle">' + (item.title || '') + '</div><canvas></canvas><div class="graphCurrentValue"></div>';
          element.style.backgroundColor = item.color;
          element.style.color = item.textcolor;
          element.dataset.yMin = item.y_min;
          element.dataset.yMax = item.y_max;
          element.dataset.windowTime = item.window_time;
          element.dataset.lineColor = item.line_color;
          // Use persisted data from the global store if available.
          if (graphDataStore[item.id]) { element.graphData = graphDataStore[item.id]; }
          else { element.graphData = []; graphDataStore[item.id] = element.graphData; }
          initGraphWidget(element);
        }
        else if (item.widget_type === "multi_select") {
          element = document.createElement("div");
          element.className = "buttonItem multiSelectWidget";
          element.id = item.id;
          if (item.title) { element.innerHTML = `<span class="msSelectTitle">${item.title}</span><select></select><span class="msSelectDropdown">&#x25BC;</span>`; }
          else { element.innerHTML = '<select></select><span class="msSelectDropdown">&#x25BC;</span>'; }
          const select = element.querySelector("select");
          select.style.color = item.textcolor;
          if (item.options && item.options.length > 0) {
            item.options.forEach(function(option) {
              const opt = document.createElement("option"); opt.value = option.value; opt.textContent = option.label;
              if (option.value === item.value) { opt.selected = true; }
              select.appendChild(opt);
            });
          }
          select.addEventListener("contextmenu", function(e) { if (element.dataset.lockable === "true") { e.preventDefault(); } });
          if (item.locked) { select.disabled = true; }
          select.onchange = function() { if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "multi_select_change", id: item.id, value: select.value })); } };
          let msLongPressTimer;
          element.addEventListener("mousedown", function(e) { msLongPressTimer = setTimeout(function() { if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "multi_select_long_click", id: item.id })); } }, 500); });
          element.addEventListener("mouseup", function(e) { clearTimeout(msLongPressTimer); });
          element.addEventListener("touchstart", function(e) { msLongPressTimer = setTimeout(function() { if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "multi_select_long_click", id: item.id })); } }, 500); }, {passive: true});
          element.addEventListener("touchend", function(e) { clearTimeout(msLongPressTimer); });
        } else if (item.widget_type === "multi_state_button") {
          element = document.createElement("button");
          element.className = "buttonItem multiStateButtonMain";
          element.id = item.id; element.dataset.name = item.name;
          element.style.backgroundColor = item.color; element.style.color = item.textcolor;
          let indicatorsHTML = '<div class="msbIndicators">';
          for (let i = 0; i < item.states.length; i++) {
            indicatorsHTML += (i === item.current_state) ? '<span class="msbIndicator active"></span>' : '<span class="msbIndicator"></span>';
          }
          indicatorsHTML += '</div>';
          element.innerHTML = `<span class="msbTitle">${item.text || ""}</span>
                               <span class="msbState">${item.state}</span>` + indicatorsHTML;
          attachCustomListeners(element, item.id, "multi_state_button");
        } else if (item.widget_type === "slider") {
          element = document.createElement("div");
          element.className = "buttonItem sliderWidget";
          element.id = item.id;
          element.dataset.min = item.min;
          element.dataset.max = item.max;
          element.dataset.currentValue = item.value;
          element.dataset.direction = item.direction || "horizontal";
          if (item.automatic_reset !== undefined && item.automatic_reset !== null) { element.dataset.automaticReset = item.automatic_reset; }
          let percentage;
          if (item.direction === "vertical") {
            percentage = ((item.value - item.min) / (item.max - item.min)) * 100;
            element.innerHTML = `<span class="sliderTitle">${item.title}</span>
                                <div class="sliderBar"></div>
                                <div class="sliderFill" style="height:${percentage}%; width:100%; bottom:0; top:auto;"></div>
                                <span class="sliderValue">${item.value}</span>`;
          } else {
            percentage = ((item.value - item.min) / (item.max - item.min)) * 100;
            element.innerHTML = `<span class="sliderTitle">${item.title}</span>
                                <div class="sliderBar"></div>
                                <div class="sliderFill" style="width:${percentage}%;"></div>
                                <span class="sliderValue">${item.value}</span>`;
          }
          element.style.backgroundColor = item.color; element.style.color = item.textcolor;
          attachSliderListeners(element, item);
        } else if (item.widget_type === "text") {
          element = document.createElement("div");
          element.className = "buttonItem textWidget";
          element.id = item.id;
          element.innerHTML = `<span class="textTitle">${item.title}</span>
                                <span class="textContent">${item.text}</span>`;
          element.style.backgroundColor = item.color; element.style.color = item.textcolor;
        } else if (item.widget_type === "digitalnumber") {
          element = document.createElement("div");
          element.className = "buttonItem digitalNumberWidget";
          element.id = item.id;
          element.style.backgroundColor = item.color; element.style.color = item.textcolor;
          var computedFontSize = 12;
          if (item.max_length) { computedFontSize = Math.max(12, 30 - 2 * item.max_length); }
          element.innerHTML = `<span class="digitalNumberTitle">${item.title}</span>
                               <span class="digitalNumberValue" style="font-size: ${computedFontSize}px;">${item.value}</span>`;
        } else if (item.widget_type === "split_button") {
          element = document.createElement("div");
          element.className = "buttonItem splitButtonContainer";
          element.id = item.id;
          let rows = item.split[0], cols = item.split[1];
          element.style.gridTemplateRows = "repeat(" + rows + ", 1fr)";
          element.style.gridTemplateColumns = "repeat(" + cols + ", 1fr)";
          element.style.gap = "2px";
          if (item.parts && item.parts.length > 0) {
            item.parts.forEach((part, index) => {
              let partElem = document.createElement("div");
              partElem.className = "splitButtonPart"; partElem.textContent = part.text;
              partElem.style.backgroundColor = part.color; partElem.style.color = part.textcolor;
              attachSplitButtonListeners(partElem, item.id, index);
              element.appendChild(partElem);
            });
          }
        }
        else if (item.widget_type === "joystick") {
          element = document.createElement("div");
          element.className = "buttonItem joystickWidget";
          element.id = item.id;
          element.dataset.x = item.x; element.dataset.y = item.y;
          if (item.fixed_axis) { element.dataset.fixed_axis = item.fixed_axis; }
          element.innerHTML = `<span class="joystickTitle">${item.title || ""}</span>
                     <div class="joystickBase"><div class="joystickKnob"></div></div>`;
          attachJoystickListeners(element, item);
        } else {
          element = document.createElement("button");
          element.className = "buttonItem";
          if (item.is_folder) {
            element.classList.add("folderButton");
            element.innerHTML = `<span>${item.text || item.name}</span><span class="folderLabel">folder</span>`;
          } else { element.textContent = item.text || item.name; }
          element.id = item.id;
          element.style.backgroundColor = item.color;
          element.style.color = item.textcolor;
          attachCustomListeners(element, item.id, "button");
        }
        if (item.hasOwnProperty("lockable") && item.lockable) {
          element.dataset.lockable = "true";
          element.dataset.locked = item.locked ? "true" : "false";
          if (item.locked) {
            element.classList.add("locked");
            let lockIcon = document.createElement("div"); lockIcon.className = "widgetLock";
            lockIcon.textContent = "🔒"; element.appendChild(lockIcon);
          } else {
            element.classList.add("unlocked");
            let lockIcon = document.createElement("div"); lockIcon.className = "widgetLock";
            lockIcon.textContent = "🔓"; lockIcon.style.opacity = "0.5"; element.appendChild(lockIcon);
          }
        } else {
          element.dataset.lockable = "false";
        }
        if (item.position && item.grid_size) {
          element.style.gridColumnStart = item.position[0] + 1;
          element.style.gridColumnEnd = "span " + item.grid_size[0];
          element.style.gridRowStart = item.position[1] + 1;
          element.style.gridRowEnd = "span " + item.grid_size[1];
          if (!(item.grid_size[0] === 1 && item.grid_size[1] === 1)) { element.style.aspectRatio = "auto"; }
        }
        grid.appendChild(element);
      });
    }

    function updateButton(id, text, color, textcolor) {
      const button = document.getElementById(id);
      if (button) { if (text) button.textContent = text; if (color) button.style.backgroundColor = color; if (textcolor) button.style.color = textcolor; }
    }

    function updateMultiStateButton(id, current_state, states, text, state, color, textcolor) {
      const button = document.getElementById(id);
      if (button) {
        const name = button.dataset.name || button.textContent;
        let indicatorsHTML = '<div class="msbIndicators">';
        for (let i = 0; i < states.length; i++) {
          indicatorsHTML += (i === current_state) ? '<span class="msbIndicator active"></span>' : '<span class="msbIndicator"></span>';
        }
        indicatorsHTML += '</div>';
        button.style.backgroundColor = color; button.style.color = textcolor;
        button.innerHTML = `<span class="msbTitle">${text || ""}</span>
                            <span class="msbState">${state}</span>` + indicatorsHTML;
      }
    }

    function updateMultiSelectButton(id, value) {
      const container = document.getElementById(id);
      if (container) {
        const select = container.querySelector("select");
        if (select) { select.value = value; }
      }
    }

    function updateSlider(id, value) {
      const slider = document.getElementById(id);
      if (slider) {
        slider.dataset.currentValue = value;
        const sliderValueSpan = slider.querySelector(".sliderValue");
        if (sliderValueSpan) { sliderValueSpan.textContent = value; }
        let min = parseFloat(slider.dataset.min);
        let max = parseFloat(slider.dataset.max);
        let percentage;
        if (slider.dataset.direction === "vertical") {
          percentage = ((value - min) / (max - min));
          slider.querySelector(".sliderFill").style.height = (percentage * 100) + "%";
        } else {
          percentage = ((value - min) / (max - min));
          slider.querySelector(".sliderFill").style.width = (percentage * 100) + "%";
        }
      }
    }

    function updateText(id, text) {
      const widget = document.getElementById(id);
      if (widget) {
        const textContent = widget.querySelector(".textContent");
        if (textContent) { textContent.textContent = text; }
      }
    }

    function updateDigitalNumber(id, value) {
      const widget = document.getElementById(id);
      if (widget) {
        const valueSpan = widget.querySelector(".digitalNumberValue");
        if (valueSpan) { valueSpan.textContent = value; }
      }
    }

    function updateJoystick(id, x, y) {
      const widget = document.getElementById(id);
      if (widget) {
        const knob = widget.querySelector(".joystickKnob");
        const base = widget.querySelector(".joystickBase");
        const rect = base.getBoundingClientRect();
        const maxDistance = rect.width / 2;
        let dx = x * maxDistance;
        let dy = -y * maxDistance;
        const fixedAxis = widget.dataset.fixed_axis;
        if (fixedAxis === "horizontal") { dy = 0; }
        else if (fixedAxis === "vertical") { dx = 0; }
        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
      }
    }

    function addLog(message) {
      const logWindow = document.getElementById("logWindow");
      const p = document.createElement("p");
      p.textContent = message; logWindow.appendChild(p);
      logWindow.scrollTop = logWindow.scrollHeight;
    }

    function sendBack() { if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "back" })); } }

    // Global swipe detection on gridWrapper
    const gridWrapper = document.getElementById("gridWrapper");
    gridWrapper.addEventListener("touchstart", function(e) {
      if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
      touchStartY = e.changedTouches[0].screenY;
    }, {passive: true});
    gridWrapper.addEventListener("touchmove", function(e) {
      if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
      let currentY = e.changedTouches[0].screenY;
      if (Math.abs(touchStartY - currentY) > 10) { isSwiping = true; }
    }, {passive: true});
    gridWrapper.addEventListener("touchend", function(e) {
      if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
      let currentY = e.changedTouches[0].screenY;
      let deltaY = touchStartY - currentY;
      if (Math.abs(deltaY) > swipeThreshold) {
        let direction = deltaY > 0 ? "down" : "up";
        if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "page_change", direction: direction })); }
      }
      setTimeout(() => { isSwiping = false; }, 100);
    }, {passive: true});

    function attachCustomListeners(element, id, baseType) {
      let clickTimer; let lastClickTime = 0; let longPressTimer;
      const longPressThreshold = 500, clickDelay = 250;
      let touchHandled = false;
      function handleClick() {
        const now = Date.now();
        if (now - lastClickTime < clickDelay) {
          clearTimeout(clickTimer);
          if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: baseType + "_double_click", id: id })); }
          lastClickTime = 0;
        } else {
          lastClickTime = now;
          clickTimer = setTimeout(function() {
            if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: baseType + "_click", id: id })); }
          }, clickDelay);
        }
      }
      element.addEventListener("mousedown", function(e) {
        longPressTimer = setTimeout(function() {
          if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: baseType + "_long_click", id: id })); }
          element.dataset.longPressed = "true";
        }, longPressThreshold);
      });
      element.addEventListener("mouseup", function(e) { clearTimeout(longPressTimer); });
      element.addEventListener("touchstart", function(e) {
        touchHandled = true;
        longPressTimer = setTimeout(function() {
          if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: baseType + "_long_click", id: id })); }
          element.dataset.longPressed = "true";
        }, longPressThreshold);
      }, {passive: true});
      element.addEventListener("touchend", function(e) {
        clearTimeout(longPressTimer);
        if (isSwiping) { element.dataset.longPressed = ""; return; }
        if (element.dataset.longPressed === "true") { element.dataset.longPressed = ""; return; }
        handleClick();
      });
      element.addEventListener("touchcancel", function(e) { clearTimeout(longPressTimer); });
      element.addEventListener("click", function(e) {
        if (touchHandled) { touchHandled = false; return; }
        if (element.dataset.longPressed === "true") { element.dataset.longPressed = ""; return; }
        handleClick();
      });
    }

    function attachSplitButtonListeners(element, id, partIndex) {
      let clickTimer; let lastClickTime = 0; let longPressTimer;
      const longPressThreshold = 500, clickDelay = 250;
      let touchHandled = false;
      function handleClick() {
        const now = Date.now();
        if (now - lastClickTime < clickDelay) {
          clearTimeout(clickTimer);
          if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "split_button_double_click", id: id, part: partIndex })); }
          lastClickTime = 0;
        } else {
          lastClickTime = now;
          clickTimer = setTimeout(function() {
            if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "split_button_click", id: id, part: partIndex })); }
          }, clickDelay);
        }
      }
      element.addEventListener("mousedown", function(e) {
        longPressTimer = setTimeout(function() {
          if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "split_button_long_click", id: id, part: partIndex })); }
          element.dataset.longPressed = "true";
        }, longPressThreshold);
      });
      element.addEventListener("mouseup", function(e) { clearTimeout(longPressTimer); });
      element.addEventListener("touchstart", function(e) {
        touchHandled = true;
        longPressTimer = setTimeout(function() {
          if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "split_button_long_click", id: id, part: partIndex })); }
          element.dataset.longPressed = "true";
        }, longPressThreshold);
      }, {passive: true});
      element.addEventListener("touchend", function(e) {
        clearTimeout(longPressTimer);
        if (isSwiping) { element.dataset.longPressed = ""; return; }
        if (element.dataset.longPressed === "true") { element.dataset.longPressed = ""; return; }
        handleClick();
      });
      element.addEventListener("touchcancel", function(e) { clearTimeout(longPressTimer); });
      element.addEventListener("click", function(e) {
        if (touchHandled) { touchHandled = false; return; }
        if (element.dataset.longPressed === "true") { element.dataset.longPressed = ""; return; }
        handleClick();
      });
    }

    function attachSliderListeners(slider, btn) {
      let sliderLongPressTimer;
      slider.addEventListener("pointerdown", function(e) {
        if (slider.dataset.locked === "true") {
          sliderLongPressTimer = setTimeout(function(){
              if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "slider_long_click", id: slider.id })); }
          }, 500);
          return;
        }
        sliderLongPressTimer = setTimeout(function(){
            if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "slider_long_click", id: slider.id })); }
        }, 500);
        e.preventDefault();
        slider.dragging = true;
        slider.setPointerCapture(e.pointerId);
        updateSliderValue(e);
      });
      slider.addEventListener("pointermove", function(e) {
        if (slider.dataset.locked === "true") return;
        if (slider.dragging) { e.preventDefault(); updateSliderValue(e); }
      });
      slider.addEventListener("pointerup", function(e) {
        clearTimeout(sliderLongPressTimer);
        if (slider.dataset.locked === "true") return;
        slider.dragging = false;
        slider.releasePointerCapture(e.pointerId);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "slider_change", id: slider.id, value: slider.dataset.currentValue }));
        }
        if (slider.dataset.automaticReset !== undefined && slider.dataset.automaticReset !== "") {
          let resetValue = parseFloat(slider.dataset.automaticReset);
          slider.dataset.currentValue = resetValue;
          let min = parseFloat(slider.dataset.min);
          let max = parseFloat(slider.dataset.max);
          let percentage;
          if (slider.dataset.direction === "vertical") {
              percentage = ((resetValue - min) / (max - min));
              slider.querySelector(".sliderFill").style.height = (percentage * 100) + "%";
          } else {
              percentage = ((resetValue - min) / (max - min));
              slider.querySelector(".sliderFill").style.width = (percentage * 100) + "%";
          }
          slider.querySelector(".sliderValue").textContent = resetValue;
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "slider_change", id: slider.id, value: resetValue }));
          }
        }
      });
      slider.addEventListener("pointercancel", function(e) {
        clearTimeout(sliderLongPressTimer);
        if (slider.dataset.locked === "true") return;
        slider.dragging = false;
        slider.releasePointerCapture(e.pointerId);
      });
      function updateSliderValue(e) {
        e.preventDefault();
        const rect = slider.getBoundingClientRect();
        let min = parseFloat(slider.dataset.min);
        let max = parseFloat(slider.dataset.max);
        let value, percentage;
        if (slider.dataset.direction === "vertical") {
            let y = e.clientY - rect.top;
            percentage = 1 - Math.max(0, Math.min(1, y / rect.height));
            value = Math.round(min + percentage * (max - min));
            slider.querySelector(".sliderFill").style.height = (percentage * 100) + "%";
        } else {
            let x = e.clientX - rect.left;
            percentage = Math.max(0, Math.min(1, x / rect.width));
            value = Math.round(min + percentage * (max - min));
            slider.querySelector(".sliderFill").style.width = (percentage * 100) + "%";
        }
        slider.dataset.currentValue = value;
        slider.querySelector(".sliderValue").textContent = value;
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "slider_change", id: slider.id, value: value }));
        }
      }
    }

    function attachJoystickListeners(element, item) {
      let jsLongPressTimer;
      const base = element.querySelector(".joystickBase");
      const knob = element.querySelector(".joystickKnob");
      let dragging = false, centerX, centerY, maxDistance;
      function updateDimensions() {
          const rect = base.getBoundingClientRect();
          centerX = rect.left + rect.width / 2;
          centerY = rect.top + rect.height / 2;
          maxDistance = rect.width / 2;
      }
      knob.style.transform = "translate(-50%, -50%)";
      base.addEventListener("pointerdown", function(e) {
          if (element.dataset.locked === "true") {
              jsLongPressTimer = setTimeout(function(){
                  if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "joystick_long_click", id: element.id })); }
              }, 500);
              return;
          }
          jsLongPressTimer = setTimeout(function(){
              if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "joystick_long_click", id: element.id })); }
          }, 500);
          e.preventDefault(); e.stopPropagation();
          dragging = true; updateDimensions(); base.setPointerCapture(e.pointerId);
      });
      base.addEventListener("pointermove", function(e) {
          if (element.dataset.locked === "true") return;
          e.stopPropagation();
          if (!dragging) return;
          let dx = e.clientX - centerX, dy = e.clientY - centerY;
          let distance = Math.sqrt(dx * dx + dy * dy);
          if (distance > maxDistance) { let angle = Math.atan2(dy, dx); dx = maxDistance * Math.cos(angle); dy = maxDistance * Math.sin(angle); }
          const fixedAxis = element.dataset.fixed_axis;
          if (fixedAxis === "horizontal") { dy = 0; } else if (fixedAxis === "vertical") { dx = 0; }
          knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
          const normX = dx / maxDistance, normY = -dy / maxDistance;
          element.dataset.x = normX.toFixed(2); element.dataset.y = normY.toFixed(2);
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "joystick_change", id: element.id, x: normX, y: normY }));
          }
      });
      base.addEventListener("pointerup", function(e) {
          clearTimeout(jsLongPressTimer);
          if (element.dataset.locked === "true") return;
          e.stopPropagation(); if (!dragging) return;
          dragging = false; base.releasePointerCapture(e.pointerId);
          knob.style.transition = "transform 0.2s ease";
          knob.style.transform = "translate(-50%, -50%)";
          element.dataset.x = 0; element.dataset.y = 0;
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "joystick_change", id: element.id, x: 0, y: 0 }));
          }
          setTimeout(() => { knob.style.transition = ""; }, 200);
      });
      base.addEventListener("pointercancel", function(e) {
          clearTimeout(jsLongPressTimer);
          if (element.dataset.locked === "true") return;
          e.stopPropagation(); if (!dragging) return;
          dragging = false; base.releasePointerCapture(e.pointerId);
          knob.style.transition = "transform 0.2s ease"; knob.style.transform = "translate(-50%, -50%)";
          element.dataset.x = 0; element.dataset.y = 0;
          if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "joystick_change", id: element.id, x: 0, y: 0 }));
          }
          setTimeout(() => { knob.style.transition = ""; }, 200);
      });
    }

    /* ===================== GraphWidget Functions ===================== */
    function initGraphWidget(el) {
      const canvas = el.querySelector("canvas");
      // Set canvas dimensions (container height minus approx. 40px for title/current value)
      let containerHeight = el.clientHeight || 100;
      let canvasHeight = containerHeight - 40, canvasWidth = el.clientWidth || 200;
      canvas.width = canvasWidth; canvas.height = canvasHeight;
      drawGraph(el);
    }

    // drawGraph uses the widget's graphData for drawing.
    function drawGraph(el) {
      const canvas = el.querySelector("canvas"); if (!canvas) return;
      const ctx = canvas.getContext("2d"), width = canvas.width, height = canvas.height;
      ctx.clearRect(0, 0, width, height);
      // Draw axes
      ctx.strokeStyle = "#888"; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, height - 1); ctx.lineTo(width, height - 1); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(1, 0); ctx.lineTo(1, height); ctx.stroke();
      // Draw a dashed midline
      const yMin = parseFloat(el.dataset.yMin), yMax = parseFloat(el.dataset.yMax);
      const yMid = (yMin + yMax) / 2;
      ctx.strokeStyle = "#555"; ctx.setLineDash([5, 5]);
      let midY = height - ((yMid - yMin) / (yMax - yMin)) * height;
      ctx.beginPath(); ctx.moveTo(0, midY); ctx.lineTo(width, midY); ctx.stroke();
      ctx.setLineDash([]);
      // Draw graph line using timestamp-based x positioning
      if (el.graphData.length > 0) {
        ctx.strokeStyle = el.dataset.lineColor || "#F00"; ctx.lineWidth = 2;
        ctx.beginPath();
        let now = Date.now(), windowTimeSec = parseFloat(el.dataset.windowTime);
        el.graphData.forEach((pt, index) => {
          let tSec = (now - pt.timestamp) / 1000;
          let x = width - (tSec / windowTimeSec) * width;
          let y = height - ((pt.value - yMin) / (yMax - yMin)) * height;
          if (index === 0) { ctx.moveTo(x, y); } else { ctx.lineTo(x, y); }
        });
        ctx.stroke();
      }
    }

    function updatePageIndicators(current_page, total_pages) {
      const container = document.getElementById("pageIndicators"); container.innerHTML = "";
      for (let i = 0; i < total_pages; i++) {
        const indicator = document.createElement("div"); indicator.className = "pageIndicator";
        if (i === current_page) { indicator.classList.add("active"); }
        indicator.addEventListener("click", function(e) { if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: "page_change", page: i })); } });
        container.appendChild(indicator);
      }
    }

    (function() {
      const logWindow = document.getElementById("logWindow");
      let isExpanded = false;
      logWindow.addEventListener("dblclick", function() {
        if (!isExpanded) {
          logWindow.dataset.originalHeight = logWindow.style.height || "15%";
          const statusBar = document.getElementById("statusBar");
          const statusRect = statusBar.getBoundingClientRect();
          logWindow.style.position = "absolute";
          logWindow.style.top = statusRect.bottom + "px";
          logWindow.style.left = "0"; logWindow.style.width = "100%";
          logWindow.style.height = "82%"; logWindow.style.zIndex = "3000";
          isExpanded = true; logWindow.scrollTop = logWindow.scrollHeight;
        } else {
          logWindow.style.position = ""; logWindow.style.top = "";
          logWindow.style.left = ""; logWindow.style.width = "";
          logWindow.style.height = logWindow.dataset.originalHeight;
          logWindow.style.zIndex = ""; isExpanded = false;
        }
        setTimeout(() => { logWindow.scrollTop = logWindow.scrollHeight; }, 200);
      });
    })();

    var lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
      var now = new Date().getTime();
      if (now - lastTouchEnd <= 300) { event.preventDefault(); }
      lastTouchEnd = now;
    }, false);

    // =================== Popup functions (UPDATED for image support) ===================
    function showPopup(data) {
      var overlay = document.getElementById("popupOverlay");
      var popupContent = document.getElementById("popupContent");
      var popupText = document.getElementById("popupText");
      var popupButtonsDiv = document.getElementById("popupButtons");

      // Remove any previous popup image if exists.
      var existingImg = popupContent.querySelector("img.popupImage");
      if(existingImg) {
        existingImg.remove();
      }
      // If an image is provided in the payload, create and insert an image element.
      if (data.image) {
        var imgElem = document.createElement("img");
        imgElem.className = "popupImage";
        imgElem.src = "data:image/png;base64," + data.image;
        // imgElem.style.maxWidth = "400px";  // Set desired max width
        // imgElem.style.maxHeight = "150px"; // Set desired max height
        // Insert the image above the text
        popupContent.insertBefore(imgElem, popupText);
      }
      popupText.textContent = data.text;
      popupButtonsDiv.innerHTML = "";
      if (data.buttons && data.buttons.length > 0) {
          data.buttons.forEach(function(btn) {
              var button = document.createElement("button");
              button.className = "buttonItem"; button.textContent = btn.label;
              button.style.backgroundColor = btn.color;
              button.onclick = function() { if (ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({type: "popup_response", button: btn.id})); } hidePopup(); };
              popupButtonsDiv.appendChild(button);
          });
      }
      overlay.style.display = "block";
    }
    function hidePopup() { document.getElementById("popupOverlay").style.display = "none"; }
  </script>
</body>
</html>
