<!DOCTYPE html>
<html>
<head>
   <meta charset="UTF-8">
  <!-- The viewport tag disables pinch zooming when combined with user-scalable=no -->
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
  <title>Dynamic Button App â€“ Dark Mode with Folders</title>

  <!-- PWA manifest -->
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#000000">

  <!-- iOS-specific PWA meta -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="LandscapeApp">
  <link rel="apple-touch-icon" href="/icon-192.png">

    <style>
    /* CSS variable for app height to fix landscape issues on iOS */
    :root {
      --app-height: 100vh;
    }
    /* Splash Screen Styles */
    #splashScreen {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: #121212;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      opacity: 1;
      transition: opacity 0.5s ease;
    }
    #splashScreen img {
      max-width: 80%;
      max-height: 80%;
    }
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #121212;
      color: #e0e0e0;
      display: flex;
      flex-direction: column;
      height: var(--app-height);
      overflow: hidden; /* Disable page scrolling */
      position: fixed;
      min-width: 100%;
    }
    /* Top Bar: Fixed to 10% of total height (with a minimum height) */
    #topBar {
      background-color: #1f1f1f;
      padding: 2px;
      padding-left: 50px; /* Added to make room for the logo */
      text-align: center;
      font-weight: bold;
      position: relative;
      flex-shrink: 0;
      height: 8%;
    }
    /* Logo in top bar â€“ made larger and spanning across topBar and statusBar */
    #logo {
      position: absolute;
      left: 40px;
      top: 0;
      height: 27px;
    }
    /* Path Bar: Fixed to 5% of total height (with a minimum height) */
    #pathBar {
      background-color: #2a2a2a;
      padding: 2px;
      text-align: center;
      font-size: 12px;
      flex-shrink: 0;
      height: 4%;
    }
    /* Status Bar: Fixed to 10% of total height (with a minimum height) */
    #statusBar {
      background-color: #333333;
      padding: 2px;
      text-align: center;
      flex-shrink: 0;
      height: 5%;
    }
     /*Grid wrapper now uses flex layout for better alignment and responsiveness */
    #gridWrapper {
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      margin: 0 20px;
      padding: 2px 20px;
      gap: 10px;
      height: 100%;
      max-height: 100%;
      min-height: 0;
      overflow: hidden;
      /*aspect-ratio: 3 / 1; !* 6 columns : 2 rows => 3:1 ratio *!*/
    }

    /* Updated grid container: fixed 6 columns and 2 rows per page */
  #buttonGrid {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    /*grid-auto-rows: 1fr;*/
    grid-template-rows: repeat(2, 1fr);  /* exactly 2 rows */
    width: 100%;
    gap: 5px;
  }

    .buttonItem {
      position: relative;
      border: none;
      border-radius: 5px;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      aspect-ratio: 1;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .folderButton {
      border: 2px dashed #888;
    }
    .folderLabel {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 12px;
      color: #ccc;
    }
    .placeholder {
      border: 1px dashed #555;
      background-color: #121212;
    }
    /* Lock icon for lockable widgets */
    .widgetLock {
      position: absolute;
      top: 2px;
      left: 2px;
      font-size: 14px;
      pointer-events: none;
      z-index: 2;
    }
    /* New widget lock state styles */
    .locked {
       filter: brightness(0.4); /* Widget appears less colorful */
    }
    .locked .widgetLock {
       opacity: 1;
    }
    .unlocked .widgetLock {
       opacity: 0.5;
    }
    /* Log window: Fixed to 15% of total height (with a minimum height) */
    #logWindow {
      flex: 0 0 15%;
      height: 15%;
      overflow-y: auto;
      border-top: 1px solid #444;
      padding: 5px;
      padding-bottom: env(safe-area-inset-bottom);
      background-color: #1a1a1a;
      font-size: 14px;
      transition: height 0.2s ease, top 0.2s ease;
    }
    #logWindow p {
      margin: 2px 0;
    }
    /* Rotate warning */
    #rotateWarning {
      display: none;
      position: fixed;
      z-index: 999;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: black;
      color: white;
      font-size: 24px;
      text-align: center;
      padding-top: 40vh;
    }
    /* When in portrait, show the rotate warning and hide the main UI */
    @media screen and (orientation: portrait) {
      #rotateWarning {
        display: block;
      }
      #topBar,
      #pathBar,
      #statusBar,
      #gridWrapper,
      #logWindow {
        display: none;
      }
    }
    /* Fix for landscape mode: remove extra padding-bottom in logWindow */
    @media screen and (orientation: landscape) {
      #logWindow {
        padding-bottom: 0;
      }
    }
    /* Root shortcut button in the upper right */
    #rootButton {
      position: absolute;
      top: 10px;
      bottom: 10px;
      right: 10px;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #555;
      cursor: pointer;
    }
    /* Activity indicator in the top left */
    #activityIndicator {
      position: absolute;
      top: 5px;
      left: 10px;
      width: 15px;
      height: 15px;
      border-radius: 50%;
      background-color: red;
    }
    /* Multi-Select Widget Styles */
    .multiSelectWidget {
      position: relative;
      border: 1px solid #444;
      border-radius: 5px;
      width: 100%;
      height: 99%;
      aspect-ratio: 1;
      min-width: 48px;
      background-color: #333;
      display: flex;
      align-items: center;
      justify-content: center;
      touch-action: none;
      font-size: 16px;
    }
    .multiSelectWidget select {
      width: 100%;
      height: 100%;
      font-size: 16px;
      background: transparent;
      color: #fff;
      border: none;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
      text-align: center;
      text-align-last: center;
      padding: 0;
      margin: 0;
      line-height: 1;
      -webkit-text-size-adjust: 100%;
    }
    .msSelectDropdown {
      position: absolute;
      right: 5px;
      bottom: 2px;
      font-size: 12px;
      color: #ccc;
    }
    .msSelectTitle {
      position: absolute;
      top: 2px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: #ccc;
      z-index: 1;
    }
    /* Multi-State Button Widget Styles */
    .multiStateButtonMain {
      width: 100%;
      height: 100%;
      aspect-ratio: 1;
      border: none;
      border-radius: 5px;
      color: #fff;
      font-size: 16px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    .msbTitle {
      position: absolute;
      top: 5px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 12px;
      font-weight: bold;
    }
    .msbState {
      display: block;
      text-align: center;
      font-size: 16px;
      margin-bottom: 2px;
    }
    .msbIndicators {
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 2px;
    }
    .msbIndicator {
      width: 8px;
      height: 8px;
      border: 1px solid #ccc;
      border-radius: 50%;
    }
    .msbIndicator.active {
      background-color: #ccc;
    }
    /* Slider Widget Styles */
    .sliderWidget {
      position: relative;
      border: none;
      border-radius: 5px;
      background-color: #444;
      color: inherit;
      font-size: 16px;
      cursor: pointer;
      overflow: hidden;
    }
    .sliderWidget .sliderTitle {
      position: relative;
      z-index: 3;
      display: block;
      text-align: center;
      font-size: 12px;
      font-weight: bold;
      margin-top: 2px;
    }
    .sliderWidget .sliderValue {
      position: relative;
      z-index: 3;
      display: block;
      text-align: center;
      font-size: 17px;
      margin-bottom: 2px;
    }
    .sliderWidget .sliderBar {
      position: absolute;
      top: 0px;
      left: 0;
      height: 100%;
      width: 100%;
      opacity: 0.3;
      background-color: currentColor;
      z-index: 1;
    }
    .sliderWidget .sliderFill {
      position: absolute;
      height: 100%;
      width: 50%;
      background-color: currentColor;
      opacity: 0.5;
      z-index: 2;
      top: 0;
    }
    /* Text Widget Styles */
    .textWidget {
      position: relative;
      border: none;
      border-radius: 5px;
      background-color: inherit;
      color: inherit;
      font-size: 16px;
      overflow: hidden;
      padding: 5px;
      text-align: center;
    }
    .textWidget .textTitle {
      position: absolute;
      top: 5px;
      left: 0;
      right: 0;
      font-size: 12px;
      font-weight: bold;
      text-align: center;
    }
    .textWidget .textContent {
      position: absolute;
      top: 50%;
      left: 0;
      right: 0;
      transform: translateY(-50%);
      font-size: 14px;
      margin: 0;
    }
    /* Digital Number Widget Styles */
    .digitalNumberWidget {
      position: relative;
      border: none;
      border-radius: 5px;
      padding: 5px;
      background-color: inherit;
      color: inherit;
      font-family: inherit;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .digitalNumberWidget .digitalNumberTitle {
      position: absolute;
      top: 5px;
      left: 0;
      right: 0;
      text-align: center;
      display: block;
      font-size: 12px;
      font-weight: bold;
    }
    .digitalNumberWidget .digitalNumberValue {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: 20px;
      line-height: 1;
      text-align: center;
      font-family: monospace;
      font-variant-numeric: tabular-nums;
      min-width: 8ch;
    }
    /* SplitButton Widget Styles */
    .splitButtonContainer {
      border: none;
      border-radius: 5px;
      overflow: hidden;
      padding: 2px;
      display: grid;
    }
    .splitButtonPart {
      border: none;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Pressed (active) state for interactive elements:
       - For normal widgets, only apply to those that are not split button containers.
       - For split button parts, always apply. */
    .buttonItem:not(.splitButtonContainer):active,
    .splitButtonPart:active {
      filter: brightness(0.8);
      transition: filter 0.1s ease;
    }
    /* Page Indicators Styles */
    #pageIndicators {
      position: absolute;
      right: 5px;           /* Moved closer to the right edge */
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 5px;
      z-index: 1000;        /* Higher z-index to ensure visibility */
      pointer-events: auto;
    }
    .pageIndicator {
      width: 8px;
      height: 8px;
      border: 1px solid #ccc;
      border-radius: 50%;
      cursor: pointer;
    }
    .pageIndicator.active {
      background-color: #ccc;
    }
    /* Joystick Widget Styles */
    .joystickWidget {
      position: relative;
      width: 100%;
      height: 100%;
      background-color: #333;
      border-radius: 10px;
      touch-action: none;
    }
    .joystickBase {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 80%;
      height: 80%;
      background-color: #555;
      border-radius: 50%;
    }
    .joystickKnob {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40%;
      height: 40%;
      background-color: #aaa;
      border-radius: 50%;
      touch-action: none;
    }
    .joystickTitle {
      position: absolute;
      top: 5px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 2;
      font-size: 12px;
      font-weight: bold;
      color: inherit;
    }
    /* Popup overlay and content styles */
    #popupOverlay {
      display: none;
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2500;
      background-color: rgba(0,0,0,0.5);
    }
    #popupContent {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #1f1f1f;
      border: 1px solid #555;
      border-radius: 5px;
      padding: 20px;
      text-align: center;
      min-width: 300px;
    }
    #popupText {
      margin-bottom: 20px;
      white-space: pre-line;
    }
    #popupButtons {
      display: flex;
      justify-content: center;
      gap: 10px;
    }
    /* Make popup buttons uniform in size, overriding the .buttonItem defaults */
    #popupButtons button {
      flex: 1 1 0;
      aspect-ratio: auto;
      /* Optional: set a min-width if needed */
      min-width: 80px;
      min-height: 80px;
      max-width: 100px;
    }
    /* Media query for larger screens (PC) */
    @media (min-width: 768px) {
      body {
        font-size: 18px;
      }
      .buttonItem {
        font-size: 18px;
      }
      #topBar {
        padding: 4px;
      }
      #pathBar, #statusBar {
        font-size: 14px;
      }
      #logWindow {
        font-size: 16px;
      }
    }
    /* =================== New Styles for GraphWidget =================== */
    .graphWidget {
      position: relative; display: flex;
      flex-direction: column; padding: 5px; box-sizing: border-box;
      -webkit-text-size-adjust: 100%;
      height: 100%;
      max-height: 100%;
    }
    .graphWidget canvas {
      flex: 1; border: 1px solid #888; -webkit-text-size-adjust: 100%;
    }
.graphTitleOverlay {
  position: absolute;
  top: 0;
  left: 0;
  z-index: 10; /* Above the canvas */
  background-color: inherit; /* Semi-transparent background for readability */
  color: #fff;
  opacity: 0.8;
  font-size: 12px;
  padding: 2px 4px;
  margin: 5px;
  min-width: 50%;
}

.graphValueOverlay {
  position: absolute;
  bottom: 0;
  left: 0;
  z-index: 10; /* Above the canvas */
  /*background-color: rgba(0, 0, 0, 0.6);*/
  background-color: inherit;
  color: #fff;
  opacity: 0.8;
  font-size: 12px;
  padding: 2px 4px;
  margin: 5px;
  min-width: 50%;
  white-space: pre;
font-family: monospace;
}

    .popupImage {
      max-width: 90vw;
      max-height: 40vh;
      width: auto;
      height: auto;
    }

    /* Adjust for larger screens (desktop) */
    @media (min-width: 768px) {
      .popupImage {
        max-height: 200vh;
        min-height: 300px;
        width: auto;
        height: auto;
      }
    }
  </style>
</head>
<body>

  <!-- Splash Screen -->
  <div id="splashScreen">
    <img src="bilbo_logo.png" alt="Logo">
  </div>

  <!-- Removed login/connection page so the app shows immediately in landscape mode -->
  <div id="rotateWarning">Please rotate your device to landscape mode.</div>

  <div id="topBar">
    <img id="logo" src="bilbo_logo.png" alt="Logo">
    <div id="topBarText"></div>
    <div id="activityIndicator"></div>
  </div>
  <div id="statusBar">Status: Connecting...</div>

  <!-- Grid wrapper -->
  <div id="gridWrapper">
    <div id="buttonGrid"></div>
    <div id="pageIndicators"></div>
  </div>
  <div id="pathBar"></div>

  <div id="logWindow"></div>

  <!-- Popup overlay (hidden by default) -->
  <div id="popupOverlay">
    <div id="popupContent">
      <div id="popupText"></div>
      <div id="popupButtons"></div>
    </div>
  </div>

  <script>

function formatGraphValue(num, totalLength, decimalPlaces) {
        const sign = num < 0 ? '-' : ' ';
        const absFixed = Math.abs(num).toFixed(decimalPlaces);
        const [intPart, fracPart] = absFixed.split('.');

        // totalLength includes everything: sign + intPart + '.' + fracPart
        // figure out how wide the intPart should be
        const intWidth = totalLength - 1 - 1 - decimalPlaces; // minus sign, dot, and fraction

        const paddedInt = intPart.padStart(intWidth, ' ');
        return sign + paddedInt + '.' + fracPart;
      }

function speak(text) {
  const utterance = new SpeechSynthesisUtterance(text);

  // Ensure voices are loaded
  const setVoiceAndSpeak = () => {
    const voices = window.speechSynthesis.getVoices();

    if (voices.length > 0) {
      // Try Samantha first (common on iOS/macOS)
      let selectedVoice = voices.find(v => v.name.includes("Samantha"));

      // If Samantha not found, try common Android voices
      if (!selectedVoice) {
        selectedVoice = voices.find(v =>
          v.name.includes("Google") || v.name.includes("Android")
        );
      }

      // Fallback to first available voice
      if (!selectedVoice) {
        selectedVoice = voices[0];
      }

      utterance.voice = selectedVoice;
      window.speechSynthesis.speak(utterance);
    }
  };

  // Sometimes getVoices returns empty array on first call; wait for voices to be loaded
  if (window.speechSynthesis.getVoices().length === 0) {
    window.speechSynthesis.onvoiceschanged = setVoiceAndSpeak;
  } else {
    setVoiceAndSpeak();
  }
}

    // Global graph data cache to persist GraphWidget data by widget ID
    var graphDataStore = {};

    // Global variables for swipe detection
    let isSwiping = false;
    let touchStartY = 0;
    const swipeThreshold = 50;

    // Disable pinch zoom (for iOS Safari)
    document.addEventListener('gesturestart', function(e) { e.preventDefault(); });

    // Fix for iOS landscape height
    function setAppHeight() { document.documentElement.style.setProperty('--app-height', window.innerHeight + 'px'); }
    window.addEventListener('resize', setAppHeight); setAppHeight();

    // Automatically use current hostname for WebSocket connection
    var wsHost = window.location.hostname; let ws;

    window.addEventListener('load', function() {
      setTimeout(function() {
        var splash = document.getElementById('splashScreen');
        if (splash) {
          splash.style.opacity = '0';
          setTimeout(function(){ splash.style.display = 'none'; }, 500);
        }
      }, 2000);
      connectWebSocket();
    });

    function connectWebSocket() {
      let port = window.location.port || "80";
      ws = new WebSocket("ws://" + wsHost + ":" + port + "/ws");
      ws.onopen = function() {
        updateTop("Connected");
        updateStatus("Connected");
        setActivityIndicator(true);
      };
      ws.onmessage = function(event) {
        const data = JSON.parse(event.data);
        if (data.type === "switch_set") {
          createButtons(data.grid_items, data.show_back);
          updatePathBar(data.path);
          if (data.pages !== undefined && data.current_page !== undefined) {
            updatePageIndicators(data.current_page, data.pages);
          }
        }
        else if (data.type === "update_button") {
          updateButton(data.id, data.text, data.color, data.textcolor);
        }
        else if (data.type === "update_multi_state") {
          updateMultiStateButton(data.id, data.current_state, data.states, data.text, data.state, data.color, data.textcolor);
        }
        else if (data.type === "update_multi_select") {
          updateMultiSelectButton(data.id, data.value);
        }
        else if (data.type === "update_slider") {
          updateSlider(data.id, data.value);
        }
        else if (data.type === "update_text") {
          updateText(data.id, data.text);
        }
        else if (data.type === "update_digitalnumber") {
          updateDigitalNumber(data.id, data.value);
        }
        else if (data.type === "update_joystick") {
          updateJoystick(data.id, data.x, data.y);
        }
        else if (data.type === "status") {
          updateStatus(data.status);
        }
        else if (data.type === "log") {
          addLog(data.message);
        }
        else if (data.type === "path_lookup") {
          console.log("Path lookup result:", data.result);
        }
        // Long press events
        else if (data.type === "slider_long_click") {
          console.log("Slider long press detected: " + data.id);
        }
        else if (data.type === "joystick_long_click") {
          console.log("Joystick long press detected: " + data.id);
        }
        else if (data.type === "multi_select_long_click") {
          console.log("Multi-select long press detected: " + data.id);
        }
        // Popup handling (including image popups)
        else if (data.type === "popup") {
          showPopup(data);
        }
        else if (data.type === "hide_popup") {
          hidePopup();
        }
        // --- Updated push_value handler for GraphWidget ---
        else if (data.type === "push_value") {
          // Ensure a global data store exists for this widget.
          if (!graphDataStore[data.id]) {
            graphDataStore[data.id] = [];
          }
          // Use provided timestamp if available; if not, check for 'time' field.
          let ts;
          if ("timestamp" in data) {
            ts = data.timestamp;
          } else if ("time" in data) {
            ts = data.time * 1000;
          } else {
            ts = Date.now();
          }
          graphDataStore[data.id].push({ timestamp: ts, value: data.value });
          // Try to update the widget if it is visible.
          let graphElem = document.getElementById(data.id);
          if (graphElem && graphElem.classList.contains("graphWidget")) {
            // Ensure the widget uses the global store.
            graphElem.graphData = graphDataStore[data.id];
            // Remove old points beyond the window duration.
            let windowTimeMs = parseFloat(graphElem.dataset.windowTime) * 1000;
            let now = Date.now();
            graphDataStore[data.id] = graphDataStore[data.id].filter(pt => (now - pt.timestamp) <= windowTimeMs);
            // Redraw the graph.
            drawGraph(graphElem);
            // Update current value display.
            let currentValueDiv = graphElem.querySelector(".graphValueOverlay");
            if (currentValueDiv) {
              // currentValueDiv.textContent = "Current: " + data.value.toFixed(2);
              currentValueDiv.textContent = "Value: " + formatGraphValue(data.value, 6, 1);
            }
          }
        }
      };
      ws.onclose = function() {
        updateStatus("Disconnected");
        updateTop("Disconnected");
        setActivityIndicator(false);
        setTimeout(connectWebSocket, 2000);
      };
      ws.onerror = function(err) {
        console.error("WebSocket error:", err);
      };
    }

    function updateTop(text) {
      document.getElementById("topBar").childNodes[2].textContent = text;
    }
    function updatePathBar(path) {
      document.getElementById("pathBar").textContent = "Path: " + path;
    }
    function updateStatus(status) {
      document.getElementById("statusBar").textContent = status;
    }
    function setActivityIndicator(active) {
      document.getElementById("activityIndicator").style.backgroundColor = active ? "green" : "red";
    }

    function createButtons(grid_items, showBack) {
      const grid = document.getElementById("buttonGrid");
      grid.innerHTML = "";
      grid_items.forEach(function(item) {
        let element;
        if (item.widget_type === "placeholder") {
          element = document.createElement("div");
          element.className = "buttonItem placeholder";
        }
        // --- GraphWidget branch ---
        else if (item.widget_type === "graph") {
          element = document.createElement("div");
          element.className = "buttonItem graphWidget";
          element.id = item.id;
          // element.innerHTML = '<div class="graphTitle">' + (item.title || '') + '</div><canvas></canvas><div class="graphCurrentValue"></div>';
          // element.innerHTML = '<canvas></canvas>';
          element.innerHTML =
            '<canvas></canvas>' +
            '<div class="graphTitleOverlay">' + (item.title || '') + '</div>' +
            '<div class="graphValueOverlay"></div>';
          element.style.backgroundColor = item.color;
          element.style.color = item.textcolor;
          element.dataset.yMin = item.y_min;
          element.dataset.yMax = item.y_max;
          element.dataset.windowTime = item.window_time;
          element.dataset.lineColor = item.line_color;

          // NEW: store optional y_ticks and x_ticks_spacing if provided
          if (item.y_ticks !== undefined) {
            element.dataset.yTicks = JSON.stringify(item.y_ticks);
          }
          if (item.x_ticks_spacing !== undefined) {
            element.dataset.xTicksSpacing = item.x_ticks_spacing;
          }

          // Use persisted data from the global store if available.
          if (graphDataStore[item.id]) {
            element.graphData = graphDataStore[item.id];
          } else {
            element.graphData = [];
            graphDataStore[item.id] = element.graphData;
          }
          initGraphWidget(element);
        }
        else if (item.widget_type === "multi_select") {
          element = document.createElement("div");
          element.className = "buttonItem multiSelectWidget";
          element.id = item.id;
          if (item.title) {
            element.innerHTML = '<span class="msSelectTitle">' + item.title + '</span><select></select><span class="msSelectDropdown">&#x25BC;</span>';
          } else {
            element.innerHTML = '<select></select><span class="msSelectDropdown">&#x25BC;</span>';
          }
          const select = element.querySelector("select");
          select.style.color = item.textcolor;
          if (item.options && item.options.length > 0) {
            item.options.forEach(function(option) {
              const opt = document.createElement("option");
              opt.value = option.value;
              opt.textContent = option.label;
              if (option.value === item.value) {
                opt.selected = true;
              }
              select.appendChild(opt);
            });
          }
          select.addEventListener("contextmenu", function(e) {
            if (element.dataset.lockable === "true") { e.preventDefault(); }
          });
          if (item.locked) {
            select.disabled = true;
          }
          select.onchange = function() {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "multi_select_change", id: item.id, value: select.value }));
            }
          };
          let msLongPressTimer;
          element.addEventListener("mousedown", function(e) {
            msLongPressTimer = setTimeout(function() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: "multi_select_long_click", id: item.id }));
              }
            }, 500);
          });
          element.addEventListener("mouseup", function(e) {
            clearTimeout(msLongPressTimer);
          });
          element.addEventListener("touchstart", function(e) {
            msLongPressTimer = setTimeout(function() {
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: "multi_select_long_click", id: item.id }));
              }
            }, 500);
          }, {passive: true});
          element.addEventListener("touchend", function(e) {
            clearTimeout(msLongPressTimer);
          });
        }
        else if (item.widget_type === "multi_state_button") {
          element = document.createElement("button");
          element.className = "buttonItem multiStateButtonMain";
          element.id = item.id;
          element.dataset.name = item.name;
          element.style.backgroundColor = item.color;
          element.style.color = item.textcolor;
          let indicatorsHTML = '<div class="msbIndicators">';
          for (let i = 0; i < item.states.length; i++) {
            indicatorsHTML += (i === item.current_state) ? '<span class="msbIndicator active"></span>' : '<span class="msbIndicator"></span>';
          }
          indicatorsHTML += '</div>';
          element.innerHTML =
            '<span class="msbTitle">' + (item.text || "") + '</span>' +
            '<span class="msbState">' + item.state + '</span>' +
            indicatorsHTML;
          attachCustomListeners(element, item.id, "multi_state_button");
        }
        else if (item.widget_type === "slider") {
          element = document.createElement("div");
          element.className = "buttonItem sliderWidget";
          element.id = item.id;
          element.dataset.min = item.min;
          element.dataset.max = item.max;
          element.dataset.currentValue = item.value;
          element.dataset.direction = item.direction || "horizontal";
          if (item.automatic_reset !== undefined && item.automatic_reset !== null) {
            element.dataset.automaticReset = item.automatic_reset;
          }
          let percentage;
          if (item.direction === "vertical") {
            percentage = ((item.value - item.min) / (item.max - item.min)) * 100;
            element.innerHTML =
              '<span class="sliderTitle">' + item.title + '</span>' +
              '<div class="sliderBar"></div>' +
              '<div class="sliderFill" style="height:' + percentage + '%; width:100%; bottom:0; top:auto;"></div>' +
              '<span class="sliderValue">' + item.value + '</span>';
          } else {
            percentage = ((item.value - item.min) / (item.max - item.min)) * 100;
            element.innerHTML =
              '<span class="sliderTitle">' + item.title + '</span>' +
              '<div class="sliderBar"></div>' +
              '<div class="sliderFill" style="width:' + percentage + '%;"></div>' +
              '<span class="sliderValue">' + item.value + '</span>';
          }
          element.style.backgroundColor = item.color;
          element.style.color = item.textcolor;
          attachSliderListeners(element, item);
        }
        else if (item.widget_type === "text") {
          element = document.createElement("div");
          element.className = "buttonItem textWidget";
          element.id = item.id;
          element.innerHTML =
            '<span class="textTitle">' + (item.title || "") + '</span>' +
            '<span class="textContent">' + (item.text || "") + '</span>';
          element.style.backgroundColor = item.color;
          element.style.color = item.textcolor;
        }
        else if (item.widget_type === "digitalnumber") {
          element = document.createElement("div");
          element.className = "buttonItem digitalNumberWidget";
          element.id = item.id;
          element.style.backgroundColor = item.color;
          element.style.color = item.textcolor;
          var computedFontSize = 12;
          if (item.max_length) {
            computedFontSize = Math.max(12, 30 - 2 * item.max_length);
          }
          element.innerHTML =
            '<span class="digitalNumberTitle">' + (item.title || "") + '</span>' +
            '<span class="digitalNumberValue" style="font-size: ' + computedFontSize + 'px;">' + item.value + '</span>';
        }
        else if (item.widget_type === "split_button") {
          element = document.createElement("div");
          element.className = "buttonItem splitButtonContainer";
          element.id = item.id;
          let rows = item.split[0], cols = item.split[1];
          element.style.gridTemplateRows = "repeat(" + rows + ", 1fr)";
          element.style.gridTemplateColumns = "repeat(" + cols + ", 1fr)";
          element.style.gap = "2px";
          if (item.parts && item.parts.length > 0) {
            item.parts.forEach((part, index) => {
              let partElem = document.createElement("div");
              partElem.className = "splitButtonPart";
              partElem.textContent = part.text;
              partElem.style.backgroundColor = part.color;
              partElem.style.color = part.textcolor;
              attachSplitButtonListeners(partElem, item.id, index);
              element.appendChild(partElem);
            });
          }
        }
        else if (item.widget_type === "joystick") {
          element = document.createElement("div");
          element.className = "buttonItem joystickWidget";
          element.id = item.id;
          element.dataset.x = item.x;
          element.dataset.y = item.y;
          if (item.fixed_axis) {
            element.dataset.fixed_axis = item.fixed_axis;
          }
          element.innerHTML =
            '<span class="joystickTitle">' + (item.title || "") + '</span>' +
            '<div class="joystickBase"><div class="joystickKnob"></div></div>';
          attachJoystickListeners(element, item);
        }
        else {
          element = document.createElement("button");
          element.className = "buttonItem";
          if (item.is_folder) {
            element.classList.add("folderButton");
            element.innerHTML = '<span>' + (item.text || item.name) + '</span><span class="folderLabel">folder</span>';
          } else {
            element.textContent = item.text || item.name;
          }
          element.id = item.id;
          element.style.backgroundColor = item.color;
          element.style.color = item.textcolor;
          attachCustomListeners(element, item.id, "button");
        }

        if (item.hasOwnProperty("lockable") && item.lockable) {
          element.dataset.lockable = "true";
          element.dataset.locked = item.locked ? "true" : "false";
          if (item.locked) {
            element.classList.add("locked");
            let lockIcon = document.createElement("div");
            lockIcon.className = "widgetLock";
            lockIcon.textContent = "ðŸ”’";
            element.appendChild(lockIcon);
          } else {
            element.classList.add("unlocked");
            let lockIcon = document.createElement("div");
            lockIcon.className = "widgetLock";
            lockIcon.textContent = "ðŸ”“";
            lockIcon.style.opacity = "0.5";
            element.appendChild(lockIcon);
          }
        } else {
          element.dataset.lockable = "false";
        }

        if (item.position && item.grid_size) {
          element.style.gridColumnStart = item.position[0] + 1;
          element.style.gridColumnEnd = "span " + item.grid_size[0];
          element.style.gridRowStart = item.position[1] + 1;
          element.style.gridRowEnd = "span " + item.grid_size[1];
          if (!(item.grid_size[0] === 1 && item.grid_size[1] === 1)) {
            element.style.aspectRatio = "auto";
          }
        }
        grid.appendChild(element);
      });
    }

    function updateButton(id, text, color, textcolor) {
      const button = document.getElementById(id);
      if (button) {
        if (text) button.textContent = text;
        if (color) button.style.backgroundColor = color;
        if (textcolor) button.style.color = textcolor;
      }
    }

    function updateMultiStateButton(id, current_state, states, text, state, color, textcolor) {
      const button = document.getElementById(id);
      if (button) {
        let indicatorsHTML = '<div class="msbIndicators">';
        for (let i = 0; i < states.length; i++) {
          indicatorsHTML += (i === current_state) ? '<span class="msbIndicator active"></span>' : '<span class="msbIndicator"></span>';
        }
        indicatorsHTML += '</div>';
        button.style.backgroundColor = color;
        button.style.color = textcolor;
        button.innerHTML =
          '<span class="msbTitle">' + (text || "") + '</span>' +
          '<span class="msbState">' + state + '</span>' +
          indicatorsHTML;
      }
    }

    function updateMultiSelectButton(id, value) {
      const container = document.getElementById(id);
      if (container) {
        const select = container.querySelector("select");
        if (select) {
          select.value = value;
        }
      }
    }

    function updateSlider(id, value) {
      const slider = document.getElementById(id);
      if (slider) {
        slider.dataset.currentValue = value;
        const sliderValueSpan = slider.querySelector(".sliderValue");
        if (sliderValueSpan) {
          sliderValueSpan.textContent = value;
        }
        let min = parseFloat(slider.dataset.min);
        let max = parseFloat(slider.dataset.max);
        let percentage;
        if (slider.dataset.direction === "vertical") {
          percentage = ((value - min) / (max - min));
          slider.querySelector(".sliderFill").style.height = (percentage * 100) + "%";
        } else {
          percentage = ((value - min) / (max - min));
          slider.querySelector(".sliderFill").style.width = (percentage * 100) + "%";
        }
      }
    }

    function updateText(id, text) {
      const widget = document.getElementById(id);
      if (widget) {
        const textContent = widget.querySelector(".textContent");
        if (textContent) {
          textContent.textContent = text;
        }
      }
    }

    function updateDigitalNumber(id, value) {
      const widget = document.getElementById(id);
      if (widget) {
        const valueSpan = widget.querySelector(".digitalNumberValue");
        if (valueSpan) {
          valueSpan.textContent = value;
        }
      }
    }

    function updateJoystick(id, x, y) {
      const widget = document.getElementById(id);
      if (widget) {
        const knob = widget.querySelector(".joystickKnob");
        const base = widget.querySelector(".joystickBase");
        const rect = base.getBoundingClientRect();
        const maxDistance = rect.width / 2;
        let dx = x * maxDistance;
        let dy = -y * maxDistance;
        const fixedAxis = widget.dataset.fixed_axis;
        if (fixedAxis === "horizontal") {
          dy = 0;
        } else if (fixedAxis === "vertical") {
          dx = 0;
        }
        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
      }
    }

    function addLog(message) {
      const logWindow = document.getElementById("logWindow");
      const p = document.createElement("p");
      p.textContent = message;
      logWindow.appendChild(p);
      logWindow.scrollTop = logWindow.scrollHeight;
    }

    function sendBack() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "back" }));
      }
    }

    // Global swipe detection on gridWrapper
    const gridWrapper = document.getElementById("gridWrapper");
    gridWrapper.addEventListener("touchstart", function(e) {
      if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
      touchStartY = e.changedTouches[0].screenY;
    }, {passive: true});
    gridWrapper.addEventListener("touchmove", function(e) {
      if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
      let currentY = e.changedTouches[0].screenY;
      if (Math.abs(touchStartY - currentY) > 10) {
        isSwiping = true;
      }
    }, {passive: true});
    gridWrapper.addEventListener("touchend", function(e) {
      if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
      let currentY = e.changedTouches[0].screenY;
      let deltaY = touchStartY - currentY;
      if (Math.abs(deltaY) > swipeThreshold) {
        let direction = deltaY > 0 ? "down" : "up";
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "page_change", direction: direction }));
        }
      }
      setTimeout(() => { isSwiping = false; }, 100);
    }, {passive: true});

    function attachCustomListeners(element, id, baseType) {
      let clickTimer; let lastClickTime = 0; let longPressTimer;
      const longPressThreshold = 500, clickDelay = 250;
      let touchHandled = false;

      function handleClick() {
        const now = Date.now();
        if (now - lastClickTime < clickDelay) {
          clearTimeout(clickTimer);
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: baseType + "_double_click", id: id }));
          }
          lastClickTime = 0;
        } else {
          lastClickTime = now;
          clickTimer = setTimeout(function() {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: baseType + "_click", id: id }));
            }
          }, clickDelay);
        }
      }
      element.addEventListener("mousedown", function(e) {
        longPressTimer = setTimeout(function() {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: baseType + "_long_click", id: id }));
          }
          element.dataset.longPressed = "true";
        }, longPressThreshold);
      });
      element.addEventListener("mouseup", function(e) {
        clearTimeout(longPressTimer);
      });
      element.addEventListener("touchstart", function(e) {
        touchHandled = true;
        longPressTimer = setTimeout(function() {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: baseType + "_long_click", id: id }));
          }
          element.dataset.longPressed = "true";
        }, longPressThreshold);
      }, {passive: true});
      element.addEventListener("touchend", function(e) {
        clearTimeout(longPressTimer);
        if (isSwiping) {
          element.dataset.longPressed = "";
          return;
        }
        if (element.dataset.longPressed === "true") {
          element.dataset.longPressed = "";
          return;
        }
        handleClick();
      });
      element.addEventListener("touchcancel", function(e) {
        clearTimeout(longPressTimer);
      });
      element.addEventListener("click", function(e) {
        if (touchHandled) {
          touchHandled = false;
          return;
        }
        if (element.dataset.longPressed === "true") {
          element.dataset.longPressed = "";
          return;
        }
        handleClick();
      });
    }

    function attachSplitButtonListeners(element, id, partIndex) {
      let clickTimer; let lastClickTime = 0; let longPressTimer;
      const longPressThreshold = 500, clickDelay = 250;
      let touchHandled = false;

      function handleClick() {
        const now = Date.now();
        if (now - lastClickTime < clickDelay) {
          clearTimeout(clickTimer);
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "split_button_double_click", id: id, part: partIndex }));
          }
          lastClickTime = 0;
        } else {
          lastClickTime = now;
          clickTimer = setTimeout(function() {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "split_button_click", id: id, part: partIndex }));
            }
          }, clickDelay);
        }
      }
      element.addEventListener("mousedown", function(e) {
        longPressTimer = setTimeout(function() {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "split_button_long_click", id: id, part: partIndex }));
          }
          element.dataset.longPressed = "true";
        }, longPressThreshold);
      });
      element.addEventListener("mouseup", function(e) {
        clearTimeout(longPressTimer);
      });
      element.addEventListener("touchstart", function(e) {
        touchHandled = true;
        longPressTimer = setTimeout(function() {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "split_button_long_click", id: id, part: partIndex }));
          }
          element.dataset.longPressed = "true";
        }, longPressThreshold);
      }, {passive: true});
      element.addEventListener("touchend", function(e) {
        clearTimeout(longPressTimer);
        if (isSwiping) {
          element.dataset.longPressed = "";
          return;
        }
        if (element.dataset.longPressed === "true") {
          element.dataset.longPressed = "";
          return;
        }
        handleClick();
      });
      element.addEventListener("touchcancel", function(e) {
        clearTimeout(longPressTimer);
      });
      element.addEventListener("click", function(e) {
        if (touchHandled) {
          touchHandled = false;
          return;
        }
        if (element.dataset.longPressed === "true") {
          element.dataset.longPressed = "";
          return;
        }
        handleClick();
      });
    }

    function attachSliderListeners(slider, btn) {
      let sliderLongPressTimer;
      slider.addEventListener("pointerdown", function(e) {
        if (slider.dataset.locked === "true") {
          sliderLongPressTimer = setTimeout(function(){
              if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: "slider_long_click", id: slider.id }));
              }
          }, 500);
          return;
        }
        sliderLongPressTimer = setTimeout(function(){
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "slider_long_click", id: slider.id }));
            }
        }, 500);
        e.preventDefault();
        slider.dragging = true;
        slider.setPointerCapture(e.pointerId);
        updateSliderValue(e);
      });
      slider.addEventListener("pointermove", function(e) {
        if (slider.dataset.locked === "true") return;
        if (slider.dragging) {
          e.preventDefault();
          updateSliderValue(e);
        }
      });
      slider.addEventListener("pointerup", function(e) {
        clearTimeout(sliderLongPressTimer);
        if (slider.dataset.locked === "true") return;
        slider.dragging = false;
        slider.releasePointerCapture(e.pointerId);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "slider_change", id: slider.id, value: slider.dataset.currentValue }));
        }
        if (slider.dataset.automaticReset !== undefined && slider.dataset.automaticReset !== "") {
          let resetValue = parseFloat(slider.dataset.automaticReset);
          slider.dataset.currentValue = resetValue;
          let min = parseFloat(slider.dataset.min);
          let max = parseFloat(slider.dataset.max);
          let percentage;
          if (slider.dataset.direction === "vertical") {
            percentage = ((resetValue - min) / (max - min));
            slider.querySelector(".sliderFill").style.height = (percentage * 100) + "%";
          } else {
            percentage = ((resetValue - min) / (max - min));
            slider.querySelector(".sliderFill").style.width = (percentage * 100) + "%";
          }
          slider.querySelector(".sliderValue").textContent = resetValue;
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "slider_change", id: slider.id, value: resetValue }));
          }
        }
      });
      slider.addEventListener("pointercancel", function(e) {
        clearTimeout(sliderLongPressTimer);
        if (slider.dataset.locked === "true") return;
        slider.dragging = false;
        slider.releasePointerCapture(e.pointerId);
      });

      function updateSliderValue(e) {
        e.preventDefault();
        const rect = slider.getBoundingClientRect();
        let min = parseFloat(slider.dataset.min);
        let max = parseFloat(slider.dataset.max);
        let value, percentage;
        if (slider.dataset.direction === "vertical") {
          let y = e.clientY - rect.top;
          percentage = 1 - Math.max(0, Math.min(1, y / rect.height));
          value = Math.round(min + percentage * (max - min));
          slider.querySelector(".sliderFill").style.height = (percentage * 100) + "%";
        } else {
          let x = e.clientX - rect.left;
          percentage = Math.max(0, Math.min(1, x / rect.width));
          value = Math.round(min + percentage * (max - min));
          slider.querySelector(".sliderFill").style.width = (percentage * 100) + "%";
        }
        slider.dataset.currentValue = value;
        slider.querySelector(".sliderValue").textContent = value;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "slider_change", id: slider.id, value: value }));
        }
      }
    }

    function attachJoystickListeners(element, item) {
      let jsLongPressTimer;
      const base = element.querySelector(".joystickBase");
      const knob = element.querySelector(".joystickKnob");
      let dragging = false, centerX, centerY, maxDistance;

      function updateDimensions() {
        const rect = base.getBoundingClientRect();
        centerX = rect.left + rect.width / 2;
        centerY = rect.top + rect.height / 2;
        maxDistance = rect.width / 2;
      }

      knob.style.transform = "translate(-50%, -50%)";

      base.addEventListener("pointerdown", function(e) {
        if (element.dataset.locked === "true") {
          jsLongPressTimer = setTimeout(function(){
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: "joystick_long_click", id: element.id }));
            }
          }, 500);
          return;
        }
        jsLongPressTimer = setTimeout(function(){
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "joystick_long_click", id: element.id }));
          }
        }, 500);
        e.preventDefault();
        e.stopPropagation();
        dragging = true;
        updateDimensions();
        base.setPointerCapture(e.pointerId);
      });

      base.addEventListener("pointermove", function(e) {
        if (element.dataset.locked === "true") return;
        e.stopPropagation();
        if (!dragging) return;
        let dx = e.clientX - centerX;
        let dy = e.clientY - centerY;
        let distance = Math.sqrt(dx * dx + dy * dy);
        if (distance > maxDistance) {
          let angle = Math.atan2(dy, dx);
          dx = maxDistance * Math.cos(angle);
          dy = maxDistance * Math.sin(angle);
        }
        const fixedAxis = element.dataset.fixed_axis;
        if (fixedAxis === "horizontal") {
          dy = 0;
        } else if (fixedAxis === "vertical") {
          dx = 0;
        }
        knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

        const normX = dx / maxDistance;
        const normY = -dy / maxDistance;
        element.dataset.x = normX.toFixed(2);
        element.dataset.y = normY.toFixed(2);
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "joystick_change", id: element.id, x: normX, y: normY }));
        }
      });

      base.addEventListener("pointerup", function(e) {
        clearTimeout(jsLongPressTimer);
        if (element.dataset.locked === "true") return;
        e.stopPropagation();
        if (!dragging) return;
        dragging = false;
        base.releasePointerCapture(e.pointerId);
        knob.style.transition = "transform 0.2s ease";
        knob.style.transform = "translate(-50%, -50%)";
        element.dataset.x = 0;
        element.dataset.y = 0;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "joystick_change", id: element.id, x: 0, y: 0 }));
        }
        setTimeout(() => { knob.style.transition = ""; }, 200);
      });

      base.addEventListener("pointercancel", function(e) {
        clearTimeout(jsLongPressTimer);
        if (element.dataset.locked === "true") return;
        e.stopPropagation();
        if (!dragging) return;
        dragging = false;
        base.releasePointerCapture(e.pointerId);
        knob.style.transition = "transform 0.2s ease";
        knob.style.transform = "translate(-50%, -50%)";
        element.dataset.x = 0;
        element.dataset.y = 0;
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: "joystick_change", id: element.id, x: 0, y: 0 }));
        }
        setTimeout(() => { knob.style.transition = ""; }, 200);
      });
    }

    /* ===================== GraphWidget Functions ===================== */
    function initGraphWidget(el) {
      const canvas = el.querySelector("canvas");
      // Calculate container size
      let containerHeight = el.clientHeight || 100;
      let containerWidth = el.clientWidth || 200;

      // Roughly reserve ~40px for titles/labels
      let canvasHeight = containerHeight - 40;
      if (canvasHeight < 40) { canvasHeight = 40; }
      let canvasWidth = containerWidth;

      // To reduce pixelation on Desktop, account for devicePixelRatio
      const dpr = window.devicePixelRatio || 1;
      canvas.width = canvasWidth * dpr;
      canvas.height = canvasHeight * dpr;
      // // Visually keep the canvas the same size
      // canvas.style.width = canvasWidth + "px";
      // canvas.style.height = canvasHeight + "px";

      // Initial draw
      drawGraph(el);
    }

    function drawGraph(el) {
      const canvas = el.querySelector("canvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");


      // We'll manage drawing coordinates with an internal scaling so that
      // everything is crisp on high-DPI screens.
      // const dpr = window.devicePixelRatio || 0.1;
      const dpr = 1;
      const width = canvas.width;  // in device pixels
      const height = canvas.height; // in device pixels
      const logicalWidth = width / dpr;
      const logicalHeight = height / dpr;

      // Clear the canvas
      ctx.save();
      ctx.scale(dpr, dpr);
      ctx.clearRect(0, 0, logicalWidth, logicalHeight);

      const yMin = parseFloat(el.dataset.yMin);
      const yMax = parseFloat(el.dataset.yMax);
      const now = Date.now();
      const windowTimeSec = parseFloat(el.dataset.windowTime);
      const lineColor = el.dataset.lineColor || "#F00";

      // For mapping a value v to vertical coordinate:
      //   y_px = logicalHeight - ((v - yMin) / (yMax - yMin)) * logicalHeight
      // We'll define a helper:
      function yToPixel(v) {
        return logicalHeight - ((v - yMin) / (yMax - yMin)) * logicalHeight;
      }

      // Draw axes (simple left/bottom lines)
      ctx.strokeStyle = "#888";
      ctx.lineWidth = 1;
      ctx.beginPath();
      // X axis along bottom
      ctx.moveTo(0, logicalHeight - 1);
      ctx.lineTo(logicalWidth, logicalHeight - 1);
      ctx.stroke();

      ctx.beginPath();
      // Y axis along left
      ctx.moveTo(1, 0);
      ctx.lineTo(1, logicalHeight);
      ctx.stroke();

      // --- Optional: Draw horizontal lines at user-provided y_ticks
      if (el.dataset.yTicks) {
        try {
          let yTicks = JSON.parse(el.dataset.yTicks);
          if (Array.isArray(yTicks)) {
            ctx.setLineDash([2, 2]);
            ctx.strokeStyle = "#444";  // Thinner dashed line
            yTicks.forEach((tickVal) => {
              if (tickVal >= yMin && tickVal <= yMax) {
                let yPix = yToPixel(tickVal);
                ctx.beginPath();
                ctx.moveTo(0, yPix);
                ctx.lineTo(logicalWidth, yPix);
                ctx.stroke();
              }
            });
            ctx.setLineDash([]);
          }
        } catch (err) {
          console.warn("Invalid y_ticks data:", err);
        }
      }

      // --- Draw a dashed line at y=0 if in range
      if (yMin < 0 && yMax > 0) {
        let zeroY = yToPixel(0);
        ctx.strokeStyle = "#555";
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(0, zeroY);
        ctx.lineTo(logicalWidth, zeroY);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // --- Optional: vertical grid lines based on x_ticks_spacing
      let xTickSpacing = parseFloat(el.dataset.xTicksSpacing);
      if (isNaN(xTickSpacing) || xTickSpacing <= 0) {
        // fallback: pick some small fraction of windowTimeSec
        // e.g. 5 vertical lines
        xTickSpacing = windowTimeSec / 5;
      }
      // We'll draw lines for t in [0..windowTimeSec] stepping by xTickSpacing
      // coordinate system: the right edge is "t=0", left edge is "t=windowTimeSec"
      ctx.strokeStyle = "#444";
      ctx.lineWidth = 1;
      ctx.setLineDash([2, 2]);
      for (let tSec = 0; tSec <= windowTimeSec + 0.0001; tSec += xTickSpacing) {
        // x coordinate goes from right to left
        let x = logicalWidth - (tSec / windowTimeSec) * logicalWidth;
        if (x >= 0 && x <= logicalWidth) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, logicalHeight);
          ctx.stroke();
        }
      }
      ctx.setLineDash([]);

      // --- Draw the actual data line
      let data = el.graphData || [];
      if (data.length > 0) {
        ctx.strokeStyle = lineColor;
        ctx.lineWidth = 2;
        ctx.beginPath();
        data.forEach((pt, index) => {
          let tSec = (now - pt.timestamp) / 1000;
          // x from right to left
          let xPos = logicalWidth - (tSec / windowTimeSec) * logicalWidth;
          let yPos = yToPixel(pt.value);
          if (index === 0) {
            ctx.moveTo(xPos, yPos);
          } else {
            ctx.lineTo(xPos, yPos);
          }
        });
        ctx.stroke();
      }

      ctx.restore(); // end of scale transform
    }

    function updatePageIndicators(current_page, total_pages) {
      const container = document.getElementById("pageIndicators");
      container.innerHTML = "";
      for (let i = 0; i < total_pages; i++) {
        const indicator = document.createElement("div");
        indicator.className = "pageIndicator";
        if (i === current_page) {
          indicator.classList.add("active");
        }
        indicator.addEventListener("click", function(e) {
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: "page_change", page: i }));
          }
        });
        container.appendChild(indicator);
      }
    }

    (function() {
      const logWindow = document.getElementById("logWindow");
      let isExpanded = false;
      logWindow.addEventListener("dblclick", function() {
        if (!isExpanded) {
          logWindow.dataset.originalHeight = logWindow.style.height || "15%";
          const statusBar = document.getElementById("statusBar");
          const statusRect = statusBar.getBoundingClientRect();
          logWindow.style.position = "absolute";
          logWindow.style.top = statusRect.bottom + "px";
          logWindow.style.left = "0";
          logWindow.style.width = "100%";
          logWindow.style.height = "82%";
          logWindow.style.zIndex = "3000";
          isExpanded = true;
          logWindow.scrollTop = logWindow.scrollHeight;
        } else {
          logWindow.style.position = "";
          logWindow.style.top = "";
          logWindow.style.left = "";
          logWindow.style.width = "";
          logWindow.style.height = logWindow.dataset.originalHeight;
          logWindow.style.zIndex = "";
          isExpanded = false;
        }
        setTimeout(() => {
          logWindow.scrollTop = logWindow.scrollHeight;
        }, 200);
      });
    })();

    var lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
      var now = new Date().getTime();
      if (now - lastTouchEnd <= 300) {
        event.preventDefault();
      }
      lastTouchEnd = now;
    }, false);

    // =================== Popup functions (UPDATED for image support) ===================
    function showPopup(data) {
      var overlay = document.getElementById("popupOverlay");
      var popupContent = document.getElementById("popupContent");
      var popupText = document.getElementById("popupText");
      var popupButtonsDiv = document.getElementById("popupButtons");

      // Remove any previous popup image if exists.
      var existingImg = popupContent.querySelector("img.popupImage");
      if(existingImg) {
        existingImg.remove();
      }
      // If an image is provided in the payload, create and insert an image element.
      if (data.image) {
        var imgElem = document.createElement("img");
        imgElem.className = "popupImage";
        imgElem.src = "data:image/png;base64," + data.image;
        popupContent.insertBefore(imgElem, popupText);
      }
      popupText.textContent = data.text;
      popupButtonsDiv.innerHTML = "";
      if (data.buttons && data.buttons.length > 0) {
          data.buttons.forEach(function(btn) {
              var button = document.createElement("button");
              button.className = "buttonItem";
              button.textContent = btn.label;
              button.style.backgroundColor = btn.color;
              button.onclick = function() {
                if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({type: "popup_response", button: btn.id}));
                }
                hidePopup();
              };
              popupButtonsDiv.appendChild(button);
          });
      }
      overlay.style.display = "block";
    }
    function hidePopup() {
      document.getElementById("popupOverlay").style.display = "none";
    }
  </script>
</body>
</html>
