<!DOCTYPE html>
<html>
<head>
    <!--    <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>-->
    <script src="/js/chart.umd.js"></script>
    <script src="/js/lib.js"></script>
    <link rel="stylesheet" href="/styles.css">
    <meta charset="UTF-8">
    <!-- The viewport tag disables pinch zooming when combined with user-scalable=no -->
    <meta name="viewport"
          content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no">
    <title>Dynamic Button App – Dark Mode with Folders</title>

    <!-- PWA manifest -->
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#000000">

    <!-- iOS-specific PWA meta -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="LandscapeApp">
    <link rel="apple-touch-icon" href="/icon-192.png">

</head>
<body>

<!-- Splash Screen -->
<div id="splashScreen">
    <img src="bilbolab_logo.png" alt="Logo" class="splash-logo">
</div>

<!-- Removed the login / connection page so the app shows immediately in landscape mode -->
<div id="rotateWarning">
    <img src="bilbolab_logo.png" alt="Logo" class="splash-logo rotate-logo">
    <p>Please rotate your device to landscape mode.</p>
</div>

<div id="statusBar">
    <div id="statusBarGrid">
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>
        <div class="statusBarCell"></div>

    </div>
</div>


<!-- Grid wrapper -->
<div id="gridWrapper">
    <div id="buttonGrid">
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>
        <div class="gridItem"></div>

    </div>
</div>
<div id="pageIndicators"></div>
<div id="pathBar"></div>

<div id="logWindow"></div>

<!-- Popup overlay (hidden by default) -->
<div id="popupOverlay">
    <div id="popupContent">
        <div id="popupText"></div>
        <div id="popupButtons"></div>
    </div>
</div>

<button id="openCommandBtn">💬</button>

<div id="commandOverlay">
    <div id="commandWindow">
        <div class="command-input-group">
            <input
                    type="text"
                    id="commandInput"
                    placeholder="Enter command…"
                    autocomplete="off"
                    autocorrect="off"
                    autocapitalize="none"
                    spellcheck="false"
                    inputmode="search"
                    enterkeyhint="send"
            />
            <button id="sendCommandBtn" type="button">Send</button>
        </div>
    </div>
</div>

<script>

    function deg2rad(deg) {
        return deg * Math.PI / 180;
    }

    function initRotaryDial(el) {
        const canvas = el.querySelector("canvas");
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext("2d");
        ctx.scale(dpr, dpr);
        drawRotaryDial(el);
    }

    function drawRotaryDial(el) {
        const canvas = el.querySelector("canvas");
        const ctx = canvas.getContext("2d");
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;
        const cx = w / 2, cy = h / 2;
        const radius = Math.min(w, h) / 2 * 0.8;

        const minVal = parseFloat(el.dataset.min);
        const maxVal = parseFloat(el.dataset.max);
        const curVal = parseFloat(el.dataset.value);
        const ticks = JSON.parse(el.dataset.ticks);
        const dialColor = el.dataset.dialColor;

        // Gauge angles (20° gap at bottom)
        const gapDeg = 20;
        const startDeg = 90 + gapDeg / 2;     // 100°
        const endDeg = 450 - gapDeg / 2;    // 440° → 80°
        const startAngle = deg2rad(startDeg);
        const endAngle = deg2rad(endDeg % 360);
        const totalAngle = ((endAngle <= startAngle)
            ? endAngle + 2 * Math.PI - startAngle
            : endAngle - startAngle);

        // Clear
        ctx.clearRect(0, 0, w, h);

        // 1) Draw background arc
        ctx.lineWidth = 8;
        ctx.strokeStyle = "#555";
        ctx.beginPath();
        ctx.arc(cx, cy, radius, startAngle, startAngle + totalAngle, false);
        ctx.stroke();

        // 2) Draw filled arc
        const pct = (curVal - minVal) / (maxVal - minVal);
        ctx.strokeStyle = dialColor;
        ctx.beginPath();
        ctx.arc(cx, cy, radius, startAngle, startAngle + totalAngle * pct, false);
        ctx.stroke();

        // 3) Draw ticks
        ctx.fillStyle = ctx.strokeStyle;  // same color
        ctx.fillStyle = "#FF0000";  // same color
        ticks.forEach(v => {
            const tPct = (v - minVal) / (maxVal - minVal);
            const ang = startAngle + totalAngle * tPct;
            const x1 = cx + Math.cos(ang) * (radius + 2);
            const y1 = cy + Math.sin(ang) * (radius + 2);
            const x2 = cx + Math.cos(ang) * (radius - 6);
            const y2 = cy + Math.sin(ang) * (radius - 6);
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        });
    }


    function formatGraphValue(num, totalLength, decimalPlaces) {
        const sign = num < 0 ? '-' : ' ';
        const absFixed = Math.abs(num).toFixed(decimalPlaces);
        const [intPart, fracPart] = absFixed.split('.');

        // totalLength includes everything: sign + intPart + '.' + fracPart
        // figure out how wide the intPart should be
        const intWidth = totalLength - 1 - 1 - decimalPlaces; // minus sign, dot, and fraction

        const paddedInt = intPart.padStart(intWidth, ' ');
        return sign + paddedInt + '.' + fracPart;
    }

    const synth = window.speechSynthesis;
    let VOICES = [];

    // 1) Kick off voice loading
    function loadVoices() {
        VOICES = synth.getVoices();
        if (VOICES.length) return;
        synth.addEventListener('voiceschanged', () => {
            VOICES = synth.getVoices();
        });
    }

    loadVoices();

    // 2) Prime the engine once on first user tap
    function primeTTS() {
        synth.speak(new SpeechSynthesisUtterance(''));
        document.removeEventListener('click', primeTTS);
    }

    document.addEventListener('click', primeTTS, {once: true});

    // 3) Your simplified speak()
    function speak(text) {
        const utter = new SpeechSynthesisUtterance(text);
        utter.voice = VOICES.find(v => v.name.includes('Samantha')) || VOICES[0];
        synth.speak(utter);
    }

    function addConnectionIndicator() {
        const grid = document.getElementById("statusBarGrid");
        let el = document.getElementById("ws-conn-indicator");
        if (!el) {
            el = document.createElement("div");
            el.id = "ws-conn-indicator";
            el.className = "status-widget circle";
            el.style.gridColumnStart = "1";
            el.style.gridColumnEnd = "span 1";
            el.style.gridRowStart = "1";
            el.style.gridRowEnd = "span 1";
            const circ = document.createElement("div");
            circ.className = "status-circle";
            el.appendChild(circ);
        }
        const color = (ws && ws.readyState === WebSocket.OPEN) ? "green" : "red";
        el.querySelector(".status-circle").style.backgroundColor = color;
        grid.insertBefore(el, grid.firstChild);
    }

    function clearStatusBar() {
        const grid = document.getElementById("statusBarGrid");
        grid.innerHTML = "";
        addConnectionIndicator();
        const COLS = 20, ROWS = 2, TOTAL = COLS * ROWS;
        for (let i = 0; i < TOTAL - 1; i++) {
            const ph = document.createElement("div");
            ph.className = "statusBarCell";
            grid.appendChild(ph);
        }
    }

    // ——— Clear out button-grid and refill with empty cells ———
    function clearButtonGrid() {
        const grid = document.getElementById("buttonGrid");
        _lastGridItems = [];
        _lastShowBack = false;
        grid.innerHTML = "";
        const TOTAL = 6 * 2;
        for (let i = 0; i < TOTAL; i++) {
            const ph = document.createElement("div");
            ph.className = "gridItem placeholder";
            grid.appendChild(ph);
        }
    }

    function updateStatusBar(message) {
        const widgets = message.data;                // array of {widget_type, widget_id, data: {...}}
        const grid = document.getElementById("statusBarGrid");
        grid.innerHTML = "";                         // wipe old
        const COLS = 20, ROWS = 2, TOTAL = COLS * ROWS;
        let occupied = 0;
        widgets.forEach(payload => {
            renderStatusBarWidget(payload, grid);
            const sz = payload.data.size;
            occupied += sz[0] * sz[1];
        });

        addConnectionIndicator();
        occupied += 1;
        for (let i = occupied; i < TOTAL; i++) {
            const ph = document.createElement("div");
            ph.className = "statusBarCell";  // uses your dashed-border styling :contentReference[oaicite:0]{index=0}&#8203;:contentReference[oaicite:1]{index=1}
            grid.appendChild(ph);
        }
    }

    // helper: update or insert a single widget
    function updateStatusBarWidget(message) {
        const payload = message.data;                // payload from Python: {widget_type, widget_id, data: {...}}
        const grid = document.getElementById("statusBarGrid");
        // remove existing if any
        const old = document.getElementById(payload.widget_id);
        if (old) old.remove();
        renderStatusBarWidget(payload, grid);
    }

    // core renderer
    function renderStatusBarWidget(payload, container) {
        const {widget_type, widget_id, data} = payload;
        const {position, size, visible} = data;
        if (!visible) return;

        // 1) create wrapper
        const el = document.createElement("div");
        el.id = widget_id;
        el.className = "status-widget " + widget_type;
        // 2) position in the 20×2 grid (zero-based in Python, one-based in CSS)
        el.style.gridColumnStart = position.column + 1;
        el.style.gridColumnEnd = `span ${size[0]}`;
        el.style.gridRowStart = position.row + 1;
        el.style.gridRowEnd = `span ${size[1]}`;

        // 3) fill content by type
        switch (widget_type) {
            case "image":
                const img = document.createElement("img");
                img.src = data.image_path;
                img.alt = "";
                img.style.maxWidth = "100%";
                img.style.maxHeight = "100%";
                img.style.objectFit = "contain";
                el.appendChild(img);
                break;

            case "connection":
                // three-bar indicator
                const bars = document.createElement("div");
                bars.className = "wifi-bars";
                const level = data.strength === "high" ? 3
                    : data.strength === "medium" ? 2 : 1;
                for (let i = 1; i <= 3; i++) {
                    const b = document.createElement("div");
                    b.className = `bar bar${i}` + (i <= level ? " active" : "");
                    b.style.backgroundColor = data.bar_color;
                    bars.appendChild(b);
                }
                el.appendChild(bars);
                break;

            case "internet":
                // globe, crossed-out when offline
                const globe = document.createElement("span");
                globe.className = "world-icon" + (data.has_internet ? "" : " offline");
                globe.textContent = "🌐";
                el.appendChild(globe);
                break;

            case "battery":
                // battery outline + fill
                const batt = document.createElement("div");
                batt.className = "battery-icon";
                const fill = document.createElement("div");
                fill.className = "battery-fill";
                fill.style.width = data.percentage + "%";
                // color ramp
                const [crit, low, med, high] = data.thresholds;
                fill.style.backgroundColor =
                    data.percentage > high ? "green" :
                        data.percentage > med ? "orange" :
                            data.percentage > low ? "orange" :
                                data.percentage > crit ? "red" :
                                    "red";
                batt.appendChild(fill);
                el.appendChild(batt);
                // voltage text
                if (data.show_voltage) {
                    const v = document.createElement("div");
                    v.textContent = data.voltage.toFixed(1) + "V";
                    v.className = "battery-voltage";
                    el.appendChild(v);
                }
                // critical alert
                if (data.percentage <= crit) {
                    const alert = document.createElement("span");
                    alert.className = "battery-alert";
                    alert.textContent = "!";
                    batt.appendChild(alert);
                }
                break;

            case "text":
                const txt = document.createElement("div");
                txt.className = "status-text";
                // txt.textContent = data.text;
                txt.innerHTML = data.text;
                txt.style.color = payload.textcolor;
                el.style.display = "flex";
                el.style.alignItems = "center";  // vertical center
                el.style.justifyContent = ({
                    left: "flex-start",
                    center: "center",
                    right: "flex-end"
                }[data.alignment] || "center");
                // alignment
                // txt.style.justifySelf = {
                //     left: "start",
                //     center: "center",
                //     right: "end"
                // }[data.alignment] || "center";
                // font size

                if (data.font_size === "small") {
                    txt.style.fontSize = "0.8em";
                } else if (data.font_size === "big") {
                    txt.style.fontSize = "1.2em";
                } else {
                    txt.style.fontSize = "1em";
                }
                if (data.bold === true) {
                    txt.style.fontWeight = "bold";
                } else {
                    txt.style.fontWeight = "normal";
                }
                if (data.italic === true) {
                    txt.style.fontStyle = "italic";
                } else {
                    txt.style.fontStyle = "normal";
                }
                el.appendChild(txt);
                break;

            case "circle":
                const circ = document.createElement("div");
                circ.className = "status-circle";
                circ.style.backgroundColor = data.color;
                el.appendChild(circ);
                break;
        }

        container.appendChild(el);
    }

    // wire them up
    window.updateStatusBar = updateStatusBar;
    window.updateStatusBarWidget = updateStatusBarWidget;


    // function updateBattery(voltage, percent) {
    //     const fill = document.getElementById("statusbar-battery-fill");
    //     fill.style.width = percent + "%";
    //     // color ramp: green→orange→red
    //     fill.style.backgroundColor =
    //         percent > 66 ? "green" :
    //             percent > 33 ? "orange" :
    //                 "red";
    //     document.getElementById("statusbar-battery-voltage")
    //         .textContent = voltage.toFixed(1) + "V";
    // }

    // function updateConnectionQuality(level) {
    //     const bars = document.querySelectorAll("#statusbar-connection .bar");
    //     let n = level === "high" ? 3
    //         : level === "medium" ? 2
    //             : 1;
    //     bars.forEach((el, i) => {
    //         el.classList.toggle("active", i < n);
    //     });
    // }
    //
    // function updateInternetStatus(online) {
    //     const icon = document.getElementById("statusbar-internet-icon");
    //     if (online) icon.classList.remove("offline");
    //     else icon.classList.add("offline");
    // }


    // Global graph data cache to persist GraphWidget data by widget ID
    var graphDataStore = {};

    // Global variables for swipe detection
    let isSwiping = false;
    let touchStartY = 0;
    const swipeThreshold = 50;

    // Disable pinch zoom (for iOS Safari)
    document.addEventListener('gesturestart', function (e) {
        e.preventDefault();
    });

    // Fix for iOS landscape height
    function setAppHeight() {
        document.documentElement.style.setProperty('--app-height', window.innerHeight + 'px');
    }

    window.addEventListener('resize', () => {
        setAppHeight();
        // **remove** the grid-rebuild here
    });

    // instead, rebuild only on orientation changes:
    window.addEventListener('orientationchange', () => {
        setAppHeight();
        _reallyCreateButtons(_lastGridItems, _lastShowBack);
    });


    setAppHeight();

    // Automatically use current hostname for WebSocket connection
    var wsHost = window.location.hostname;
    let ws;

    window.addEventListener('load', function () {
        setTimeout(function () {
            var splash = document.getElementById('splashScreen');
            if (splash) {
                splash.style.opacity = '0';
                setTimeout(function () {
                    splash.style.display = 'none';
                }, 500);
            }
        }, 2000);
        connectWebSocket();
    });

    function connectWebSocket() {
        let port = window.location.port || "80";
        ws = new WebSocket("ws://" + wsHost + ":" + port + "/ws");
        // wipe both grids
        clearStatusBar();
        clearButtonGrid();
        addConnectionIndicator();
        ws.onopen = function () {
            addConnectionIndicator();

            ws.send(JSON.stringify({
                'type': 'handshake',
                'client': 'web'
            }));

        };


        ws.onmessage = function (event) {
            const data = JSON.parse(event.data);
            if (data.type === "switch_set") {
                createButtons(data.grid_items, data.show_back);
                updatePathBar(data.path);
                if (data.pages !== undefined && data.current_page !== undefined) {
                    updatePageIndicators(data.current_page, data.pages);
                }
            } else if (data.type === "update_status_bar_widget") {
                updateStatusBarWidget(data);
            } else if (data.type === "update_status_bar") {
                updateStatusBar(data);

            } else if (data.type === "update_button") {
                updateButton(data.id, data.text, data.color, data.textcolor);
            } else if (data.type === "update_multi_state") {
                updateMultiStateButton(data.id, data.current_state, data.states, data.text, data.state, data.color, data.textcolor);
            } else if (data.type === "update_multi_select") {
                updateMultiSelectButton(data.id, data.value);
            } else if (data.type === "update_editable_value") {
                const container = document.getElementById(data.id);
                if (!container) return;
                const inp = container.querySelector(".evInput");
                // 1) update the value
                if (data.value !== undefined && inp.value !== data.value) {
                    inp.value = data.value;
                }
                // 2) update the lock state
                if (data.locked !== undefined) {
                    inp.disabled = data.locked;
                    container.dataset.locked = data.locked ? "true" : "false";
                }
            } else if (data.type === "update_rotary_dial") {
                const el = document.getElementById(data.id);
                if (!el) return;
                el.dataset.value = data.value;
                const p = parseInt(el.dataset.precision, 10);
                el.querySelector(".value").textContent = Number(data.value).toFixed(p);
                drawRotaryDial(el);

            } else if (data.type === "update_slider") {
                updateSlider(data.id, data.value);
            } else if (data.type === "update_text") {
                updateText(data.id, data.text);
            } else if (data.type === "update_digitalnumber") {
                updateDigitalNumber(data.id, data.value);
            } else if (data.type === "update_joystick") {
                updateJoystick(data.id, data.x, data.y);
            } else if (data.type === "status") {
                // updateStatus(data.status);
            } else if (data.type === "log") {
                addLog(data.message, data.color);
            } else if (data.type === "path_lookup") {
                console.log("Path lookup result:", data.result);
            }
            // Long press events
            else if (data.type === "slider_long_click") {
                console.log("Slider long press detected: " + data.id);
            } else if (data.type === "joystick_long_click") {
                console.log("Joystick long press detected: " + data.id);
            } else if (data.type === "multi_select_long_click") {
                console.log("Multi-select long press detected: " + data.id);
            }
            // Popup handling (including image popups)
            else if (data.type === "popup") {
                console.log("Popup message received:", data.text);
                showPopup(data);
            } else if (data.type === "hide_popup") {
                hidePopup();
            }
            // --- Updated push_value handler for GraphWidget ---
            else if (data.type === "push_value") {
                if (!graphDataStore[data.id]) {
                    graphDataStore[data.id] = [];
                }
                let ts;
                if ("timestamp" in data) {
                    ts = data.timestamp;
                } else if ("time" in data) {
                    ts = data.time * 1000;
                } else {
                    ts = Date.now();
                }
                graphDataStore[data.id].push({timestamp: ts, value: data.value});
                let graphElem = document.getElementById(data.id);
                if (graphElem && graphElem.classList.contains("graphWidget")) {
                    graphElem.graphData = graphDataStore[data.id];
                    let windowTimeMs = parseFloat(graphElem.dataset.windowTime) * 1000;
                    let now = Date.now();
                    graphDataStore[data.id] = graphDataStore[data.id].filter(pt => (now - pt.timestamp) <= windowTimeMs);
                    drawGraph(graphElem);
                    let currentValueDiv = graphElem.querySelector(".graphValueOverlay");
                    if (currentValueDiv) {
                        currentValueDiv.textContent = "Value: " + formatGraphValue(data.value, 6, 1);
                    }
                }
            }
            // NEW: speak(...) message from server
            else if (data.type === "speak") {
                console.log("Speak message received:", data.text);
                speak(data.text);
            }
            // NEW FOR STATUSWIDGET: update status widget
            else if (data.type === "update_statuswidget") {
                updateStatusWidget(data.id, data.items);
            }
        }
        ;

        ws.onclose = function () {
            graphDataStore = {};
            // 2) For any existing GraphWidget elements, also clear their Chart.js data
            document.querySelectorAll('.graphWidget').forEach(el => {
                if (el._chart) {
                    el._chart.data.datasets[0].data = [];
                    el._chart.update();       // redraw empty
                }
                // clear out the overlay value, too
                const overlay = el.querySelector('.graphValueOverlay');
                if (overlay) overlay.textContent = '';
            });
            // wipe both grids
            clearStatusBar();
            clearButtonGrid();
            addConnectionIndicator();
            setTimeout(connectWebSocket, 2000);
        };
        ws.onerror = function (err) {
            console.error("WebSocket error:", err);
        };
    }


    function updatePathBar(path) {
        document.getElementById("pathBar").textContent = "Path: " + path;
    }


    function setActivityIndicator(active) {
        // document.getElementById("activityIndicator").style.backgroundColor = active ? "green" : "red";
    }

    // keep a copy of the last grid state
    let _lastGridItems = [];
    let _lastShowBack = false;

    function createButtons(grid_items, showBack) {
        _lastGridItems = grid_items;
        _lastShowBack = showBack;
        _reallyCreateButtons(grid_items, showBack);
    }


    function _reallyCreateButtons(grid_items, showBack) {
        const grid = document.getElementById("buttonGrid");
        grid.innerHTML = "";
        let occupiedCells = 0;
        grid_items.forEach(function (item) {
                // create a rigid grid cell
                const cell = document.createElement("div");
                cell.className = "gridItem";

                let element;
                if (item.hidden) {
                    return;
                }

                // --- GraphWidget branch ---
                else if (item.widget_type === "graph") {
                    element = document.createElement("div");
                    element.className = "gridItem graphWidget";
                    element.id = item.id;
                    element.innerHTML =
                        '<canvas></canvas>' +
                        '<div class="graphTitleOverlay">' + (item.title || '') + '</div>' +
                        '<div class="graphValueOverlay"></div>';
                    element.style.backgroundColor = item.color;
                    element.style.color = item.textcolor;
                    element.dataset.yMin = item.y_min;
                    element.dataset.yMax = item.y_max;
                    element.dataset.windowTime = item.window_time;
                    element.dataset.lineColor = item.line_color;

                    if (item.y_ticks !== undefined) {
                        element.dataset.yTicks = JSON.stringify(item.y_ticks);
                    }
                    if (item.x_ticks_spacing !== undefined) {
                        element.dataset.xTicksSpacing = item.x_ticks_spacing;
                    }

                    if (graphDataStore[item.id]) {
                        element.graphData = graphDataStore[item.id];
                    } else {
                        element.graphData = [];
                        graphDataStore[item.id] = element.graphData;
                    }
                    initGraphWidget(element);
                } else if (item.widget_type === "editable_value") {
                    element = document.createElement("div");
                    element.className = "gridItem editableValueWidget";
                    element.id = item.id;
                    element.dataset.lockable = item.lockable ? "true" : "false";
                    element.dataset.locked = item.locked ? "true" : "false";

                    // remember the last good value
                    element.dataset.prevValue = item.value;

                    // pick the right input attributes
                    const isNum = item.is_numeric === true;
                    element.innerHTML = `
                                          <span class="evTitle">${item.title || ''}</span>
                                          <input
                                            type="text"
                                            inputmode="${isNum ? 'decimal' : 'text'}"
                                            ${isNum ? 'pattern="[0-9]*[.]?[0-9]*"' : ''}
                                            class="evInput"
                                            value="${item.value}"
                                            autocomplete="off"
                                            autocorrect="off"
                                            autocapitalize="none"
                                            spellcheck="false"
                                            enterkeyhint="send"
                                            ${item.lockable && item.locked ? 'disabled' : ''}
                                          />
    `;
                    // const overlay = document.createElement('div');
                    // overlay.className = 'evOverlay';
                    // element.appendChild(overlay);


                    // ––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––

                    element.style.backgroundColor = item.color;
                    element.style.color = item.textcolor;

                    const input = element.querySelector('.evInput');

                    // input.addEventListener('focus', () => {
                    //     overlay.classList.add('disabled');
                    // });


                    //  a) on Enter, blur + dispatch change
                    input.addEventListener('keydown', e => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            input.blur();
                            input.dispatchEvent(new Event('change'));
                        }
                    });

                    // b) when they leave the field, if it's empty, restore the old value
                    input.addEventListener('blur', () => {
                        // overlay.classList.remove('disabled');
                        if (input.value.trim() === '') {
                            const prev = element.dataset.prevValue;
                            input.value = prev;
                        }
                    });


                    // c) when they actually change it, update prevValue and send to backend
                    if (!item.lockable || !item.locked) {
                        input.addEventListener('change', e => {
                            let v = e.target.value;
                            // if this widget is numeric, normalize comma → dot
                            if (isNum) {
                                v = v.replace(/,/g, '.');
                            }
                            // store only if non-empty
                            if (v.trim() !== '') element.dataset.prevValue = v;
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'widget',
                                    event_type: 'editable_value_change',
                                    id: item.id,
                                    value: v
                                }));
                            }
                        });
                    }

                    // d) wire up the standard button-like long-press / double-tap / click handlers
                    attachCustomListeners(element, item.id, 'editable_value');
                } else if (item.widget_type === "rotary_dial") {
                    // 1) Build container
                    element = document.createElement("div");
                    element.className = "gridItem rotaryDialWidget";
                    element.id = item.id;
                    element.style.color = item.dial_color;
                    element.style.backgroundColor = item.color || "#333";

                    // 2) Store parameters
                    element.dataset.min = item.min;
                    element.dataset.max = item.max;
                    element.dataset.value = item.value;
                    element.dataset.ticks = JSON.stringify(item.ticks || []);
                    element.dataset.dialColor = item.dial_color || "#3399FF";
                    element.dataset.precision = item.precision;
                    element.dataset.valueType = item.value_type;          // "float" or "int"
                    element.dataset.limitToTicks = item.limit_to_ticks;
                    element.dataset.continuousUpdates = item.continuous_updates;

                    // 3) Insert canvas + value
                    // element.innerHTML = '<canvas></canvas><div class="value">' + item.value + '</div>';
                    element.innerHTML =
                        '<span class="rotaryTitle">' + item.title + '</span>' +
                        '<canvas></canvas>' +
                        '<div class="value">' +
                        Number(item.value)
                            .toFixed(item.value_type === "int" ? 0 : item.precision) +
                        '</div>';

                    if (item.continuous_updates) {
                        const icon = document.createElement('div');
                        icon.className = 'continuousIcon';
                        icon.textContent = '🔄';
                        element.appendChild(icon);
                    }

                    const canvas = element.querySelector('canvas');
                    let startX, startValue;
                    // keep track of last sent for continuous updates
                    element._lastSentValue = parseFloat(element.dataset.value);

                    canvas.addEventListener('pointerdown', e => {
                        if (element.dataset.continuousUpdates === "true") {
                            element.classList.add("dragging");
                        }

                        e.preventDefault();
                        startX = e.clientX;
                        startValue = parseFloat(element.dataset.value);
                        element._lastSentValue = startValue;
                        canvas.setPointerCapture(e.pointerId);
                    });

                    canvas.addEventListener('pointermove', e => {
                        if (startX == null) return;
                        const dx = e.clientX - startX;
                        const min = parseFloat(element.dataset.min);
                        const max = parseFloat(element.dataset.max);
                        const ticks = JSON.parse(element.dataset.ticks || '[]');
                        const precision = parseInt(element.dataset.precision, 10);
                        const valueType = element.dataset.valueType;             // "float" or "int"
                        const limitToTicks = element.dataset.limitToTicks === 'true';
                        const continuous = element.dataset.continuousUpdates === 'true';

                        // 1) raw value from drag
                        let raw = startValue + (dx / 150) * (max - min);

                        // 2) snap either to ticks or to grid of precision/int
                        if (limitToTicks && ticks.length) {
                            raw = ticks.reduce((prev, curr) =>
                                Math.abs(curr - raw) < Math.abs(prev - raw) ? curr : prev
                            );
                        } else if (valueType === 'int') {
                            raw = Math.round(raw);
                        } else {
                            raw = parseFloat(raw.toFixed(precision));
                        }

                        // 3) clamp
                        raw = Math.max(min, Math.min(max, raw));

                        // 4) update the dial’s UI
                        element.dataset.value = raw;
                        const disp = valueType === 'int' ? raw : raw.toFixed(precision);
                        element.querySelector('.value').textContent = disp;
                        drawRotaryDial(element);

                        // 5) optional continuous update
                        if (continuous && raw !== element._lastSentValue) {
                            ws.send(JSON.stringify({
                                type: 'widget',
                                event_type: 'rotary_dial_change',
                                id: element.id,
                                value: raw
                            }));
                            element._lastSentValue = raw;
                        }
                    });

                    canvas.addEventListener('pointerup', e => {
                        canvas.releasePointerCapture(e.pointerId);
                        startX = null;
                        // always send final
                        const raw = parseFloat(element.dataset.value);
                        ws.send(JSON.stringify({
                            type: 'widget',
                            event_type: 'rotary_dial_change',
                            id: element.id,
                            value: raw
                        }));
                        if (element.dataset.continuousUpdates !== 'true') {

                            // trigger the CSS blink
                            element.classList.add('accepted');
                            // remove so it can re‑trigger next time
                            element.addEventListener('animationend', () => {
                                element.classList.remove('accepted');
                            }, {once: true});
                        }

                    });

                    function endDrag(e) {
                        // remove the brightening class
                        element.classList.remove("dragging");
                        // … your existing pointerup logic (send final, reset, etc.) …
                    }

                    element.addEventListener("pointerup", endDrag);
                    element.addEventListener("pointercancel", endDrag);

                } else if (item.widget_type === "multi_select") {
                    element = document.createElement("div");
                    element.className = "gridItem multiSelectWidget";
                    element.id = item.id;
                    if (item.title) {
                        element.innerHTML = '<span class="msSelectTitle">' + item.title + '</span><select></select><span class="msSelectDropdown">&#x25BC;</span>';
                    } else {
                        element.innerHTML = '<select></select><span class="msSelectDropdown">&#x25BC;</span>';
                    }
                    const select = element.querySelector("select");
                    select.style.color = item.textcolor;
                    element.style.backgroundColor = item.color;
                    if (item.options && item.options.length > 0) {
                        item.options.forEach(function (option) {
                            const opt = document.createElement("option");
                            opt.value = option.value;
                            opt.textContent = option.label;
                            if (option.value === item.value) {
                                opt.selected = true;
                            }
                            select.appendChild(opt);
                        });
                    }
                    select.addEventListener("contextmenu", function (e) {
                        if (element.dataset.lockable === "true") {
                            e.preventDefault();
                        }
                    });
                    if (item.locked) {
                        select.disabled = true;
                    }
                    select.onchange = function () {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                type: 'widget',
                                event_type: "multi_select_change",
                                id: item.id,
                                value: select.value
                            }));
                        }
                    };
                    let msLongPressTimer;
                    element.addEventListener("mousedown", function (e) {
                        msLongPressTimer = setTimeout(function () {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'widget',
                                    event_type: "multi_select_long_click",
                                    id: item.id
                                }));
                            }
                        }, 500);
                    });
                    element.addEventListener("mouseup", function (e) {
                        clearTimeout(msLongPressTimer);
                    });
                    element.addEventListener("touchstart", function (e) {
                        msLongPressTimer = setTimeout(function () {
                            if (ws && ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    type: 'widget',
                                    event_type: "multi_select_long_click",
                                    id: item.id
                                }));
                            }
                        }, 500);
                    }, {passive: true});
                    element.addEventListener("touchend", function (e) {
                        clearTimeout(msLongPressTimer);
                    });
                } else if (item.widget_type === "iframe") {
                    element = document.createElement("div");
                    element.className = "gridItem iframeWidget";
                    element.id = item.id;
                    // optional background
                    element.style.backgroundColor = item.color || "transparent";

                    // Create the iframe
                    const frame = document.createElement("iframe");
                    frame.src = item.url;
                    element.appendChild(frame);

                    // Make it clickable like a normal button:
                    attachCustomListeners(element, item.id, "button");
                } else if (item.widget_type === "multi_state_button") {
                    element = document.createElement("button");
                    element.className = "gridItem buttonItem multiStateButtonMain";
                    element.id = item.id;
                    element.dataset.name = item.name;
                    element.style.backgroundColor = item.color;
                    element.style.color = item.textcolor;
                    let indicatorsHTML = '<div class="msbIndicators">';
                    for (let i = 0; i < item.states.length; i++) {
                        indicatorsHTML += (i === item.current_state) ? '<span class="msbIndicator active"></span>' : '<span class="msbIndicator"></span>';
                    }
                    indicatorsHTML += '</div>';
                    element.innerHTML =
                        '<span class="msbTitle">' + (item.text || "") + '</span>' +
                        '<span class="msbState">' + item.state + '</span>' +
                        indicatorsHTML;
                    attachCustomListeners(element, item.id, "multi_state_button");
                } else if (item.widget_type === "slider") {
                    element = document.createElement("div");
                    element.className = "gridItem sliderWidget";
                    element.id = item.id;
                    element.dataset.min = item.min;
                    element.dataset.max = item.max;
                    element.dataset.continuousUpdates = item.continuous_updates;
                    element._lastSentValue = item.value;
                    element.dataset.limitToTicks = item.limit_to_ticks;
                    element.dataset.currentValue = item.value;
                    element.dataset.direction = item.direction || "horizontal";
                    element.dataset.precision = item.precision;
                    element.dataset.valueType = item.value_type;
                    element.dataset.ticks = JSON.stringify(item.ticks);

                    if (item.automatic_reset !== undefined && item.automatic_reset !== null) {
                        element.dataset.automaticReset = item.automatic_reset;
                    }
                    let percentage;
                    if (item.direction === "vertical") {
                        percentage = ((item.value - item.min) / (item.max - item.min)) * 100;
                        element.innerHTML =
                            '<span class="sliderTitle">' + item.title + '</span>' +
                            // '<div class="sliderBar"></div>' +
                            '<div class="sliderFill" style="height:' + percentage + '%; width:100%; bottom:0; top:auto;"></div>' +
                            '<span class="sliderValue">'
                            + Number(item.value).toFixed(item.precision)
                            + '</span>';
                    } else {
                        percentage = ((item.value - item.min) / (item.max - item.min)) * 100;
                        element.innerHTML =
                            '<span class="sliderTitle">' + item.title + '</span>' +
                            // '<div class="sliderBar"></div>' +
                            '<div class="sliderFill" style="width:' + percentage + '%;"></div>' +
                            '<span class="sliderValue">'
                            + Number(item.value).toFixed(item.precision)
                            + '</span>';
                    }
                    element.style.backgroundColor = item.color;
                    element.style.color = item.textcolor;

                    if (item.continuous_updates) {
                        const icon = document.createElement('div');
                        icon.className = 'continuousIcon';
                        icon.textContent = '🔄';
                        // icon.textContent = '↻'
                        element.appendChild(icon);
                    }

                    // draw tick marks
                    if (item.ticks && item.ticks.length > 0) {
                        item.ticks.forEach(v => {
                            const tick = document.createElement("div");
                            tick.className = "sliderTick";
                            const pct = ((v - item.min) / (item.max - item.min)) * 100;
                            if (item.direction === "vertical") {
                                // horizontal line
                                tick.style.top = (100 - pct) + "%";
                                tick.style.left = "0";
                                tick.style.width = "100%";
                                tick.style.height = "1px";
                            } else {
                                // vertical line
                                tick.style.left = pct + "%";
                                tick.style.top = "0";
                                tick.style.height = "100%";
                                tick.style.width = "1px";
                            }
                            element.appendChild(tick);
                        });
                    }

                    attachSliderListeners(element, item);
                } else if (item.widget_type === "text") {
                    element = document.createElement("div");
                    element.className = "gridItem textWidget";
                    element.id = item.id;
                    element.innerHTML =
                        '<span class="textTitle">' + (item.title || "") + '</span>' +
                        '<span class="textContent">' + (item.text || "") + '</span>';
                    element.style.backgroundColor = item.color;
                    element.style.color = item.textcolor;
                } else if (item.widget_type === "digitalnumber") {
                    element = document.createElement("div");
                    element.className = "gridItem digitalNumberWidget";
                    element.id = item.id;
                    element.style.backgroundColor = item.color;
                    element.style.color = item.textcolor;
                    element.max_length = item.max_length;
                    element.decimals = item.decimals;
                    var computedFontSize = 12;
                    if (item.max_length) {
                        computedFontSize = Math.max(12, 30 - 2 * item.max_length);
                    }
                    element.innerHTML =
                        '<span class="digitalNumberTitle">' + (item.title || "") + '</span>' +
                        '<span class="digitalNumberValue" style="font-size: ' + computedFontSize + 'px;">' + item.value + '</span>';
                } else if (item.widget_type === "split_button") {
                    element = document.createElement("div");
                    element.className = "gridItem splitButtonContainer";
                    element.id = item.id;
                    let rows = item.split[0], cols = item.split[1];
                    element.style.gridTemplateRows = "repeat(" + rows + ", 1fr)";
                    element.style.gridTemplateColumns = "repeat(" + cols + ", 1fr)";
                    element.style.gap = "2px";
                    if (item.parts && item.parts.length > 0) {
                        item.parts.forEach((part, index) => {
                            let partElem = document.createElement("div");
                            partElem.className = "splitButtonPart";
                            partElem.textContent = part.text;
                            partElem.style.backgroundColor = part.color;
                            partElem.style.color = part.textcolor;
                            attachSplitButtonListeners(partElem, item.id, index);
                            element.appendChild(partElem);
                        });
                    }
                } else if (item.widget_type === "joystick") {
                    element = document.createElement("div");
                    element.className = "gridItem joystickWidget";
                    element.id = item.id;
                    element.dataset.x = item.x;
                    element.dataset.y = item.y;
                    if (item.fixed_axis) {
                        element.dataset.fixed_axis = item.fixed_axis;
                    }
                    element.innerHTML =
                        '<span class="joystickTitle">' + (item.title || "") + '</span>' +
                        '<div class="joystickBase"><div class="joystickKnob"></div></div>';

                    const icon = document.createElement('div');
                    icon.className = 'continuousIcon';
                    icon.textContent = '🔄';
                    // icon.textContent = '↻'
                    element.appendChild(icon);
                    attachJoystickListeners(element, item);
                }
                // NEW FOR STATUSWIDGET
                else if (item.widget_type === "status") {
                    element = document.createElement("div");
                    element.className = "gridItem statusWidget";
                    element.id = item.id;
                    element.style.backgroundColor = item.color;
                    element.style.color = item.textcolor;
                    buildStatusTable(element, item.items);
                } else {
                    element = document.createElement("button");
                    element.className = "gridItem buttonItem";
                    if (item.is_folder) {
                        element.classList.add("folderButton");
                        element.innerHTML = '<span>' + (item.text || item.name) + '</span>';
                        if (item.is_proxy) {
                            let proxyIcon = document.createElement("div");
                            proxyIcon.className = "proxyIcon";
                            proxyIcon.textContent = "🌐";
                            element.appendChild(proxyIcon);
                        } else {
                            // now append a real folder icon
                            const folderIcon = document.createElement("div");
                            folderIcon.className = "folderIcon";
                            // folderIcon.textContent = "📁";   // or any SVG/text you like 🗂
                            folderIcon.textContent = "🗂";   // or any SVG/text you like
                            element.appendChild(folderIcon);
                        }
                    } else {
                        element.textContent = item.text || item.name;
                    }
                    element.id = item.id;
                    element.style.backgroundColor = item.color;
                    element.style.color = item.textcolor;
                    attachCustomListeners(element, item.id, "button");
                }

                if (item.hasOwnProperty("lockable") && item.lockable) {
                    element.dataset.lockable = "true";
                    element.dataset.locked = item.locked ? "true" : "false";
                    if (item.locked) {
                        element.classList.add("locked");
                        let lockIcon = document.createElement("div");
                        lockIcon.className = "widgetLock";
                        lockIcon.textContent = "🔒";
                        element.appendChild(lockIcon);
                    } else {
                        element.classList.add("unlocked");
                        let lockIcon = document.createElement("div");
                        lockIcon.className = "widgetLock";
                        lockIcon.textContent = "🔓";
                        lockIcon.style.opacity = "0.5";
                        element.appendChild(lockIcon);
                    }
                } else {
                    element.dataset.lockable = "false";
                }

                if (item.position && item.grid_size) {
                    // our new dict shape: { column:…, row:… }
                    const col = item.position.column;
                    const row = item.position.row;

                    element.style.gridColumnStart = col + 1;
                    element.style.gridColumnEnd = "span " + item.grid_size[0];
                    element.style.gridRowStart = row + 1;
                    element.style.gridRowEnd = "span " + item.grid_size[1];
                    if (!(item.grid_size[0] === 1 && item.grid_size[1] === 1)) {
                        element.style.aspectRatio = "auto";
                    }
                }
                grid.appendChild(element);

                if (item.widget_type === "rotary_dial") {
                    initRotaryDial(element);
                }

                // now count how many grid‐cells this one took up:
                const size = item.grid_size
                    ? item.grid_size[0] * item.grid_size[1]
                    : 1;              // default to 1×1 if no grid_size
                occupiedCells += size;
            }
        )
        ;
        const TOTAL = 6 * 2;
        for (let i = occupiedCells; i < TOTAL; i++) {
            const ph = document.createElement("div");
            ph.className = "gridItem placeholder";
            grid.appendChild(ph);
        }
    }

    // NEW FOR STATUSWIDGET: builds the table (no borders) with circle / name / status
    function buildStatusTable(container, items) {
        container.innerHTML = ""; // Clear existing
        let table = document.createElement("table");
        let tbody = document.createElement("tbody");
        table.appendChild(tbody);

        // If we want each row to occupy an equal fraction of the widget’s height:
        // we can set row heights in % if we have > 0 items
        if (items && items.length > 0) {
            for (let i = 0; i < items.length; i++) {
                let row = document.createElement("tr");
                // Row height
                row.style.height = (100 / items.length) + "%";
                let tdMarker = document.createElement("td");
                let tdName = document.createElement("td");
                let tdStatus = document.createElement("td");

                let markerDiv = document.createElement("div");
                markerDiv.className = "statusMarker";
                markerDiv.style.backgroundColor = items[i].marker_color || "#FFFFFF";

                tdMarker.appendChild(markerDiv);
                tdName.textContent = items[i].name || "";
                tdStatus.textContent = items[i].status || "";

                row.appendChild(tdMarker);
                row.appendChild(tdName);
                row.appendChild(tdStatus);
                tbody.appendChild(row);
            }
        }
        container.appendChild(table);
    }

    // NEW FOR STATUSWIDGET: function to update items
    function updateStatusWidget(id, items) {
        let container = document.getElementById(id);
        if (container && container.classList.contains("statusWidget")) {
            buildStatusTable(container, items);
        }
    }

    function updateButton(id, text, color, textcolor) {
        const button = document.getElementById(id);
        if (button) {
            if (text) button.textContent = text;
            if (color) button.style.backgroundColor = color;
            if (textcolor) button.style.color = textcolor;
        }
    }

    function updateMultiStateButton(id, current_state, states, text, state, color, textcolor) {
        const button = document.getElementById(id);
        if (button) {
            let indicatorsHTML = '<div class="msbIndicators">';
            for (let i = 0; i < states.length; i++) {
                indicatorsHTML += (i === current_state) ? '<span class="msbIndicator active"></span>' : '<span class="msbIndicator"></span>';
            }
            indicatorsHTML += '</div>';
            button.style.backgroundColor = color;
            button.style.color = textcolor;
            button.innerHTML =
                '<span class="msbTitle">' + (text || "") + '</span>' +
                '<span class="msbState">' + state + '</span>' +
                indicatorsHTML;
        }
    }

    function updateMultiSelectButton(id, value) {
        const container = document.getElementById(id);
        if (container) {
            const select = container.querySelector("select");
            if (select) {
                select.value = value;
            }
        }
    }

    function updateSlider(id, value) {
        const slider = document.getElementById(id);
        if (slider) {
            slider.dataset.currentValue = value;
            const sliderValueSpan = slider.querySelector(".sliderValue");
            if (sliderValueSpan) {
                const prec = parseInt(slider.dataset.precision, 10);
                sliderValueSpan.textContent = Number(value).toFixed(prec);

            }
            let min = parseFloat(slider.dataset.min);
            let max = parseFloat(slider.dataset.max);
            let percentage;
            if (slider.dataset.direction === "vertical") {
                percentage = ((value - min) / (max - min));
                slider.querySelector(".sliderFill").style.height = (percentage * 100) + "%";
            } else {
                percentage = ((value - min) / (max - min));
                slider.querySelector(".sliderFill").style.width = (percentage * 100) + "%";
            }
        }
    }

    function updateText(id, text) {
        const widget = document.getElementById(id);
        if (widget) {
            const textContent = widget.querySelector(".textContent");
            if (textContent) {
                textContent.textContent = text;
            }
        }
    }

    function updateDigitalNumber(id, value) {
        const widget = document.getElementById(id);
        if (widget) {
            const valueSpan = widget.querySelector(".digitalNumberValue");
            if (valueSpan) {
                valueSpan.textContent = formatNumber(value, widget.max_length, widget.decimals);
            }
        }
    }

    function updateJoystick(id, x, y) {
        const widget = document.getElementById(id);
        if (widget) {
            const knob = widget.querySelector(".joystickKnob");
            const base = widget.querySelector(".joystickBase");
            const rect = base.getBoundingClientRect();
            const maxDistance = rect.width / 2;
            let dx = x * maxDistance;
            let dy = -y * maxDistance;
            const fixedAxis = widget.dataset.fixed_axis;
            if (fixedAxis === "horizontal") {
                dy = 0;
            } else if (fixedAxis === "vertical") {
                dx = 0;
            }
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
        }
    }

    function addLog(message, color) {
        const logWindow = document.getElementById("logWindow");
        const p = document.createElement("p");
        p.textContent = message;
        if (color) {
            // if color is e.g. "#f00" or "red"
            p.style.color = color;
        }
        logWindow.appendChild(p);
        logWindow.scrollTop = logWindow.scrollHeight;
    }

    // Global swipe detection on gridWrapper
    const gridWrapper = document.getElementById("gridWrapper");
    gridWrapper.addEventListener("touchstart", function (e) {
        if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
        touchStartY = e.changedTouches[0].screenY;
    }, {passive: true});
    gridWrapper.addEventListener("touchmove", function (e) {
        if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
        let currentY = e.changedTouches[0].screenY;
        if (Math.abs(touchStartY - currentY) > 10) {
            isSwiping = true;
        }
    }, {passive: true});
    gridWrapper.addEventListener("touchend", function (e) {
        if (e.target.closest(".sliderWidget") || e.target.closest(".joystickWidget")) return;
        let currentY = e.changedTouches[0].screenY;
        let deltaY = touchStartY - currentY;
        if (Math.abs(deltaY) > swipeThreshold) {
            let direction = deltaY > 0 ? "down" : "up";
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({type: 'navigation', event_type: "page_change", direction: direction}));
            }
        }
        setTimeout(() => {
            isSwiping = false;
        }, 100);
    }, {passive: true});

    function attachCustomListeners(element, id, baseType) {
        let clickTimer;
        let lastClickTime = 0;
        let longPressTimer;
        const longPressThreshold = 500, clickDelay = 250;
        let touchHandled = false;

        // function handleClick() {
        //     const now = Date.now();
        //     if (now - lastClickTime < clickDelay) {
        //         clearTimeout(clickTimer);
        //         if (ws && ws.readyState === WebSocket.OPEN) {
        //             ws.send(JSON.stringify({type: 'widget', event_type: baseType + "_double_click", id: id}));
        //         }
        //         lastClickTime = 0;
        //     } else {
        //         lastClickTime = now;
        //         clickTimer = setTimeout(function () {
        //             if (ws && ws.readyState === WebSocket.OPEN) {
        //                 ws.send(JSON.stringify({type: 'widget', event_type: baseType + "_click", id: id}));
        //             }
        //         }, clickDelay);
        //     }
        // }
        function handleClick() {
            // if it's editable_value, focus the input (leave current value)
            if (baseType === 'editable_value' && element.dataset.locked === 'false') {
                const inp = element.querySelector('.evInput');
                if (inp) inp.focus();
            }

            const now = Date.now();
            if (now - lastClickTime < clickDelay) {
                clearTimeout(clickTimer);
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'widget',
                        event_type: baseType + "_double_click",
                        id: id
                    }));
                }
                lastClickTime = 0;
            } else {
                lastClickTime = now;
                clickTimer = setTimeout(function () {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'widget',
                            event_type: baseType + "_click",
                            id: id
                        }));
                    }
                }, clickDelay);
            }
        }

        element.addEventListener("mousedown", function (e) {
            longPressTimer = setTimeout(function () {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({type: 'widget', event_type: baseType + "_long_click", id: id}));
                }
                element.dataset.longPressed = "true";
                // VISUAL FEEDBACK: blink just like the rotary-dial “accepted” animation
                element.classList.add('accepted');

                element.addEventListener('animationend', () => {
                    element.classList.remove('accepted');
                }, {once: true});


                // If this is an editable_value, clear + focus the input
                if (baseType === 'editable_value' && element.dataset.locked === 'false') {
                    const inp = element.querySelector('.evInput');
                    if (inp) {
                        inp.value = '';
                        inp.focus();
                    }
                }
            }, longPressThreshold);
        });
        element.addEventListener("mouseup", function (e) {
            clearTimeout(longPressTimer);
        });
        element.addEventListener("touchstart", function (e) {
            touchHandled = true;
            longPressTimer = setTimeout(function () {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({type: 'widget', event_type: baseType + "_long_click", id: id}));
                }
                element.dataset.longPressed = "true";

                // VISUAL FEEDBACK: blink just like the rotary-dial “accepted” animation
                element.classList.add('accepted');

                element.addEventListener('animationend', () => {
                    element.classList.remove('accepted');
                }, {once: true});


                // If this is an editable_value, clear + focus the input
                if (baseType === 'editable_value' && element.dataset.locked === 'false') {
                    const inp = element.querySelector('.evInput');
                    if (inp) {
                        inp.value = '';
                        inp.focus();
                    }
                }
            }, longPressThreshold);
        }, {passive: true});
        element.addEventListener("touchend", function (e) {
            clearTimeout(longPressTimer);
            if (isSwiping) {
                element.dataset.longPressed = "";
                return;
            }
            if (element.dataset.longPressed === "true") {
                element.dataset.longPressed = "";
                return;
            }
            handleClick();
        });
        element.addEventListener("touchcancel", function (e) {
            clearTimeout(longPressTimer);
        });
        element.addEventListener("click", function (e) {
            if (touchHandled) {
                touchHandled = false;
                return;
            }
            if (element.dataset.longPressed === "true") {
                element.dataset.longPressed = "";
                return;
            }
            handleClick();
        });
    }

    function attachSplitButtonListeners(element, id, partIndex) {
        let clickTimer;
        let lastClickTime = 0;
        let longPressTimer;
        const longPressThreshold = 500, clickDelay = 250;
        let touchHandled = false;

        function handleClick() {
            const now = Date.now();
            if (now - lastClickTime < clickDelay) {
                clearTimeout(clickTimer);
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'widget',
                        event_type: "split_button_double_click",
                        id: id,
                        part: partIndex
                    }));
                }
                lastClickTime = 0;
            } else {
                lastClickTime = now;
                clickTimer = setTimeout(function () {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'widget',
                            event_type: "split_button_click",
                            id: id,
                            part: partIndex
                        }));
                    }
                }, clickDelay);
            }
        }

        element.addEventListener("mousedown", function (e) {
            longPressTimer = setTimeout(function () {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'widget',
                        event_type: "split_button_long_click",
                        id: id,
                        part: partIndex
                    }));
                }
                element.dataset.longPressed = "true";
            }, longPressThreshold);
        });
        element.addEventListener("mouseup", function (e) {
            clearTimeout(longPressTimer);
        });
        element.addEventListener("touchstart", function (e) {
            touchHandled = true;
            longPressTimer = setTimeout(function () {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'widget',
                        event_type: "split_button_long_click",
                        id: id,
                        part: partIndex
                    }));
                }
                element.dataset.longPressed = "true";
            }, longPressThreshold);
        }, {passive: true});
        element.addEventListener("touchend", function (e) {
            clearTimeout(longPressTimer);
            if (isSwiping) {
                element.dataset.longPressed = "";
                return;
            }
            if (element.dataset.longPressed === "true") {
                element.dataset.longPressed = "";
                return;
            }
            handleClick();
        });
        element.addEventListener("touchcancel", function (e) {
            clearTimeout(longPressTimer);
        });
        element.addEventListener("click", function (e) {
            if (touchHandled) {
                touchHandled = false;
                return;
            }
            if (element.dataset.longPressed === "true") {
                element.dataset.longPressed = "";
                return;
            }
            handleClick();
        });
    }

    function attachSliderListeners(slider, btn) {


        let sliderLongPressTimer;
        slider.addEventListener("pointerdown", function (e) {
            if (slider.dataset.continuousUpdates === "true") {
                slider.classList.add("dragging");
            }
            if (slider.dataset.locked === "true") {
                sliderLongPressTimer = setTimeout(function () {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({type: 'widget', event_type: "slider_long_click", id: slider.id}));
                    }
                }, 500);
                return;
            }
            sliderLongPressTimer = setTimeout(function () {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({type: 'widget', event_type: "slider_long_click", id: slider.id}));
                }
            }, 500);
            e.preventDefault();
            slider.dragging = true;
            slider.setPointerCapture(e.pointerId);
            updateSliderValue(e);
        });
        slider.addEventListener("pointermove", function (e) {
            if (slider.dataset.locked === "true") return;
            if (slider.dragging) {
                e.preventDefault();
                updateSliderValue(e);
            }
        });
        slider.addEventListener("pointerup", function (e) {
                clearTimeout(sliderLongPressTimer);
                if (slider.dataset.locked === "true") return;
                slider.dragging = false;
                slider.releasePointerCapture(e.pointerId);

                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'widget',
                        event_type: "slider_change",
                        id: slider.id,
                        value: slider.dataset.currentValue
                    }));
                }
                if (slider.dataset.automaticReset !== undefined && slider.dataset.automaticReset !== "") {
                    let resetValue = parseFloat(slider.dataset.automaticReset);
                    slider.dataset.currentValue = resetValue;
                    let min = parseFloat(slider.dataset.min);
                    let max = parseFloat(slider.dataset.max);
                    let percentage;
                    if (slider.dataset.direction === "vertical") {
                        percentage = ((resetValue - min) / (max - min));
                        slider.querySelector(".sliderFill").style.height = (percentage * 100) + "%";
                    } else {
                        percentage = ((resetValue - min) / (max - min));
                        slider.querySelector(".sliderFill").style.width = (percentage * 100) + "%";
                    }
                    slider.querySelector(".sliderValue").textContent = resetValue;
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'widget',
                            event_type: "slider_change",
                            id: slider.id,
                            value: resetValue
                        }));
                    }
                }
                if (slider.dataset.continuousUpdates !== 'true') {

                    // trigger the CSS blink
                    slider.classList.add('accepted');
                    // remove so it can re‑trigger next time
                    slider.addEventListener('animationend', () => {
                        slider.classList.remove('accepted');
                    }, {once: true});
                }
            }
        )
        ;
        slider.addEventListener("pointercancel", function (e) {
            clearTimeout(sliderLongPressTimer);
            if (slider.dataset.locked === "true") return;
            slider.dragging = false;
            slider.releasePointerCapture(e.pointerId);
        });

        function updateSliderValue(e) {
            e.preventDefault();
            const rect = slider.getBoundingClientRect();
            const min = parseFloat(slider.dataset.min),
                max = parseFloat(slider.dataset.max),
                dir = slider.dataset.direction,
                precision = parseInt(slider.dataset.precision, 10),
                valueType = slider.dataset.valueType,
                ticks = JSON.parse(slider.dataset.ticks || "[]"),
                limitToTicks = slider.dataset.limitToTicks === "true";

            // 1) raw pct
            let pct = dir === "vertical"
                ? 1 - Math.max(0, Math.min(1, (e.clientY - rect.top) / rect.height))
                : Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));

            // 2) raw value
            let raw = min + pct * (max - min);

            // 3) snap to explicit ticks first (if requested)
            if (limitToTicks && ticks.length) {
                raw = ticks.reduce((prev, curr) =>
                    Math.abs(curr - raw) < Math.abs(prev - raw) ? curr : prev
                );
            }
            // 4) then enforce int vs float snapping
            else if (valueType === "int") {
                raw = Math.round(raw);
            } else {
                // this rounds to nearest 0.1, 0.01, etc.
                raw = parseFloat(raw.toFixed(precision));
            }

            // 5) recompute pct so fill is exact
            pct = (raw - min) / (max - min);

            // 6) update DOM
            slider.dataset.currentValue = raw;
            slider.querySelector(".sliderValue")
                .textContent = raw.toFixed(valueType === "int" ? 0 : precision);

            const fill = slider.querySelector(".sliderFill");
            if (dir === "vertical") {
                fill.style.height = (pct * 100) + "%";
            } else {
                fill.style.width = (pct * 100) + "%";
            }

            // 7) continuous updates?
            if (slider.dataset.continuousUpdates === "true" &&
                ws && ws.readyState === WebSocket.OPEN &&
                slider._lastSentValue !== raw) {
                ws.send(JSON.stringify({
                    type: 'widget',
                    event_type: "slider_change",
                    id: slider.id,
                    value: raw
                }));
                slider._lastSentValue = raw;

            }
        }

        function endDrag(e) {
            // remove the brightening class
            slider.classList.remove("dragging");
            // … your existing pointerup logic (send final, reset, etc.) …
        }

        slider.addEventListener("pointerup", endDrag);
        slider.addEventListener("pointercancel", endDrag);

    }

    function attachJoystickListeners(element, item) {
        let jsLongPressTimer;
        const base = element.querySelector(".joystickBase");
        const knob = element.querySelector(".joystickKnob");
        let dragging = false, centerX, centerY, maxDistance;

        function updateDimensions() {
            const rect = base.getBoundingClientRect();
            centerX = rect.left + rect.width / 2;
            centerY = rect.top + rect.height / 2;
            maxDistance = rect.width / 2;
        }

        knob.style.transform = "translate(-50%, -50%)";

        base.addEventListener("pointerdown", function (e) {
            if (element.dataset.locked === "true") {
                jsLongPressTimer = setTimeout(function () {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'widget',
                            event_type: "joystick_long_click",
                            id: element.id
                        }));
                    }
                }, 500);
                return;
            }
            jsLongPressTimer = setTimeout(function () {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({type: 'widget', event_type: "joystick_long_click", id: element.id}));
                }
            }, 500);
            e.preventDefault();
            e.stopPropagation();
            dragging = true;
            updateDimensions();
            base.setPointerCapture(e.pointerId);
        });

        base.addEventListener("pointermove", function (e) {
            if (element.dataset.locked === "true") return;
            e.stopPropagation();
            if (!dragging) return;
            let dx = e.clientX - centerX;
            let dy = e.clientY - centerY;
            let distance = Math.sqrt(dx * dx + dy * dy);
            if (distance > maxDistance) {
                let angle = Math.atan2(dy, dx);
                dx = maxDistance * Math.cos(angle);
                dy = maxDistance * Math.sin(angle);
            }
            const fixedAxis = element.dataset.fixed_axis;
            if (fixedAxis === "horizontal") {
                dy = 0;
            } else if (fixedAxis === "vertical") {
                dx = 0;
            }
            knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

            const normX = dx / maxDistance;
            const normY = -dy / maxDistance;
            element.dataset.x = normX.toFixed(2);
            element.dataset.y = normY.toFixed(2);
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'widget',
                    event_type: "joystick_change",
                    id: element.id,
                    x: normX,
                    y: normY
                }));
            }
        });

        base.addEventListener("pointerup", function (e) {
            clearTimeout(jsLongPressTimer);
            if (element.dataset.locked === "true") return;
            e.stopPropagation();
            if (!dragging) return;
            dragging = false;
            base.releasePointerCapture(e.pointerId);
            knob.style.transition = "transform 0.2s ease";
            knob.style.transform = "translate(-50%, -50%)";
            element.dataset.x = 0;
            element.dataset.y = 0;
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'widget',
                    event_type: "joystick_change",
                    id: element.id,
                    x: 0,
                    y: 0
                }));
            }
            setTimeout(() => {
                knob.style.transition = "";
            }, 200);
        });

        base.addEventListener("pointercancel", function (e) {
            clearTimeout(jsLongPressTimer);
            if (element.dataset.locked === "true") return;
            e.stopPropagation();
            if (!dragging) return;
            dragging = false;
            base.releasePointerCapture(e.pointerId);
            knob.style.transition = "transform 0.2s ease";
            knob.style.transform = "translate(-50%, -50%)";
            element.dataset.x = 0;
            element.dataset.y = 0;
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'widget',
                    event_type: "joystick_change",
                    id: element.id,
                    x: 0,
                    y: 0
                }));
            }
            setTimeout(() => {
                knob.style.transition = "";
            }, 200);
        });
    }

    /* ===================== GraphWidget Functions ===================== */
    /**
     * Initialize a Chart.js line chart on the GraphWidget element.
     * Reads yMin, yMax, windowTime (sec), lineColor, yTicks, xTicksSpacing from data‑attributes.
     */
    function initGraphWidget(el) {
        const canvas = el.querySelector('canvas');
        // make the <canvas> fill its container
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        const ctx = canvas.getContext('2d');

        // grab config from data-attrs
        const yMin = parseFloat(el.dataset.yMin);
        const yMax = parseFloat(el.dataset.yMax);
        const windowTime = parseFloat(el.dataset.windowTime);        // in seconds
        const lineColor = el.dataset.lineColor || '#f00';
        const yTicks = el.dataset.yTicks ? JSON.parse(el.dataset.yTicks) : undefined;
        const xTickSpacing = parseFloat(el.dataset.xTicksSpacing) || (windowTime / 5);

        // Chart.js instance attached to element for later updates
        el._chart = new Chart(ctx, {
            type: 'line',
            data: {
                datasets: [{
                    data: [],
                    borderColor: lineColor,
                    borderWidth: 2,
                    tension: 0,       // straight lines
                    pointRadius: 0,   // no dots
                    fill: false
                }]
            },
            options: {
                animation: false,
                responsive: false,      // we manage sizing ourselves
                maintainAspectRatio: false,
                scales: {
                    x: {
                        type: 'linear',
                        position: 'bottom',
                        min: 0,
                        max: windowTime,
                        reverse: true,   // so newer data (t=0) appears at right
                        ticks: {
                            stepSize: xTickSpacing,
                            callback: val => `${Math.round(val)}s`
                        },
                        grid: {
                            color: '#444',
                            borderDash: [2, 2]
                        }
                    },
                    y: {
                        min: yMin,
                        max: yMax,
                        ticks: {
                            // Chart.js accepts an array of tick values via `values`
                            values: yTicks
                        },
                        grid: {
                            color: '#444',
                            borderDash: [2, 2]
                        }
                    }
                },
                plugins: {
                    legend: {display: false},
                    tooltip: {enabled: false}
                }
            }
        });
    }

    /**
     * Update the Chart.js chart from el.graphData, enforcing the rolling window.
     * Also refreshes the current‑value overlay.
     */
    function drawGraph(el) {
        const chart = el._chart;
        if (!chart) return;

        const now = Date.now();
        const windowTime = parseFloat(el.dataset.windowTime); // sec
        const rawData = el.graphData || [];

        // keep only points within windowTime, and map to {x, y}
        const pts = rawData
            .filter(pt => (now - pt.timestamp) / 1000 <= windowTime)
            .map(pt => ({x: (now - pt.timestamp) / 1000, y: pt.value}));

        chart.data.datasets[0].data = pts;
        chart.update('none');

        // update the overlay with the very latest pushed value
        const overlay = el.querySelector('.graphValueOverlay');
        if (overlay && rawData.length) {
            const latest = rawData[rawData.length - 1].value;
            overlay.textContent = 'Value: ' + formatGraphValue(latest, 6, 1);
        }
    }

    function updatePageIndicators(current_page, total_pages) {
        const container = document.getElementById("pageIndicators");
        container.innerHTML = "";
        for (let i = 0; i < total_pages; i++) {
            const indicator = document.createElement("div");
            indicator.className = "pageIndicator";
            if (i === current_page) {
                indicator.classList.add("active");
            }
            indicator.addEventListener("click", function (e) {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({type: 'navigation', event_type: "page_change", page: i}));
                }
            });
            container.appendChild(indicator);
        }
    }

    (function () {
        const logWindow = document.getElementById("logWindow");
        let isExpanded = false;
        logWindow.addEventListener("dblclick", function () {
            if (!isExpanded) {
                logWindow.dataset.originalHeight = logWindow.style.height || "15%";
                const statusBar = document.getElementById("statusBar");
                const statusRect = statusBar.getBoundingClientRect();
                logWindow.style.position = "absolute";
                logWindow.style.top = statusRect.bottom + "px";
                logWindow.style.left = "0";
                logWindow.style.width = "100%";
                logWindow.style.height = "86%";
                logWindow.style.zIndex = "3000";
                isExpanded = true;
                logWindow.scrollTop = logWindow.scrollHeight;
            } else {
                logWindow.style.position = "";
                logWindow.style.top = "";
                logWindow.style.left = "";
                logWindow.style.width = "";
                logWindow.style.height = logWindow.dataset.originalHeight;
                logWindow.style.zIndex = "";
                isExpanded = false;
            }
            setTimeout(() => {
                logWindow.scrollTop = logWindow.scrollHeight;
            }, 200);
        });
    })();

    var lastTouchEnd = 0;
    document.addEventListener('touchend', function (event) {
        var now = new Date().getTime();
        if (now - lastTouchEnd <= 300) {
            event.preventDefault();
        }
        lastTouchEnd = now;
    }, false);

    // =================== Popup functions (UPDATED for image support) ===================
    // ===================== Popup functions (UPDATED for image & uuid support) ===================
    function showPopup(data) {
        var overlay = document.getElementById("popupOverlay");
        var popupContent = document.getElementById("popupContent");
        var popupText = document.getElementById("popupText");
        var popupButtonsDiv = document.getElementById("popupButtons");

        // remove any previous image
        var existingImg = popupContent.querySelector("img.popupImage");
        if (existingImg) {
            existingImg.remove();
        }

        // if the backend sent an image, prepend it
        if (data.image) {
            var imgElem = document.createElement("img");
            imgElem.className = "popupImage";
            imgElem.src = "data:image/png;base64," + data.image;
            popupContent.insertBefore(imgElem, popupText);
        }

        // set the text
        popupText.textContent = data.text;

        // clear old buttons
        popupButtonsDiv.innerHTML = "";

        // add new buttons, wiring each to send back the popup_id + button id
        if (data.buttons && data.buttons.length > 0) {
            data.buttons.forEach(function (btn) {
                var button = document.createElement("button");
                button.className = "buttonItem";
                button.textContent = btn.label;
                button.style.backgroundColor = btn.color;
                button.onclick = function () {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'special',
                            event_type: "popup_response",
                            popup_id: data.popup_id,
                            button: btn.id
                        }));
                    }
                    hidePopup();
                };
                popupButtonsDiv.appendChild(button);
            });
        }

        // finally show the overlay
        overlay.style.display = "block";
    }

    function hidePopup() {
        document.getElementById("popupOverlay").style.display = "none";
    }

    // 1) Show the overlay and focus the input
    function showCommandOverlay() {
        document.getElementById('commandOverlay').style.display = 'block';
        const inp = document.getElementById('commandInput');
        inp.value = '';
        inp.focus();
    }

    // 2) Hide/clear the overlay
    function hideCommandOverlay() {
        document.getElementById('commandOverlay').style.display = 'none';
        document.getElementById('commandInput').value = '';
        document.getElementById('commandInput').blur();
    }

    // 3) Send the current command via WebSocket and close
    function sendCommand() {
        const cmd = document.getElementById('commandInput').value.trim();
        if (cmd && ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({
                type: 'command',    // adjust to whatever your backend expects
                command: cmd
            }));
        }
        hideCommandOverlay();
    }

    // hide overlay when user taps outside the window
    const cmdOverlay = document.getElementById('commandOverlay');
    cmdOverlay.addEventListener('click', e => {
        // only if the backdrop itself was clicked
        if (e.target === cmdOverlay) {
            hideCommandOverlay();
        }
    });

    function initCommandUI() {
        document.getElementById('openCommandBtn')
            .addEventListener('click', showCommandOverlay);
        document.getElementById('sendCommandBtn')
            .addEventListener('click', sendCommand);
        document.getElementById('commandInput')
            .addEventListener('keydown', e => {
                if (e.key === 'Enter') sendCommand();
            });
    }


    // call it once your page/script has loaded
    window.addEventListener('load', initCommandUI);

</script>


</body>
</html>
